<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Infinispan HotRod C++ Client: infinispan::hotrod::RemoteCache&lt; K, V &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Infinispan HotRod C++ Client
   &#160;<span id="projectnumber">8.2.1.Final</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceinfinispan.html">infinispan</a></li><li class="navelem"><a class="el" href="namespaceinfinispan_1_1hotrod.html">hotrod</a></li><li class="navelem"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">RemoteCache</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classinfinispan_1_1hotrod_1_1RemoteCache-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">infinispan::hotrod::RemoteCache&lt; K, V &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="CacheClientListener_8h_source.html">CacheClientListener.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for infinispan::hotrod::RemoteCache&lt; K, V &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classinfinispan_1_1hotrod_1_1RemoteCache.png" usemap="#infinispan::hotrod::RemoteCache&lt; K, V &gt;_map" alt=""/>
  <map id="infinispan::hotrod::RemoteCache&lt; K, V &gt;_map" name="infinispan::hotrod::RemoteCache&lt; K, V &gt;_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a895dc86326bd3ed90f8a7ba350d9057e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a895dc86326bd3ed90f8a7ba350d9057e">getName</a> ()</td></tr>
<tr class="separator:a895dc86326bd3ed90f8a7ba350d9057e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe553aa4fc2ccd65fe560acea3e4a5d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#acfe553aa4fc2ccd65fe560acea3e4a5d">getVersion</a> ()</td></tr>
<tr class="separator:acfe553aa4fc2ccd65fe560acea3e4a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d52129f2aa9bdd2faa7442ba1bd8549"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a3d52129f2aa9bdd2faa7442ba1bd8549">getProtocolVersion</a> ()</td></tr>
<tr class="separator:a3d52129f2aa9bdd2faa7442ba1bd8549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09e72a491c778cb4a3c61018f22b6f4"><td class="memItemLeft" align="right" valign="top">V *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#ae09e72a491c778cb4a3c61018f22b6f4">get</a> (const K &amp;key)</td></tr>
<tr class="separator:ae09e72a491c778cb4a3c61018f22b6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa7d309807ce2fd3a9b4f11520b5601"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::shared_ptr&lt; K &gt;<br class="typebreak"/>
, std::shared_ptr&lt; V &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a1aa7d309807ce2fd3a9b4f11520b5601">getAll</a> (const std::set&lt; K &gt; &amp;<a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a4ce2d43a2e32f67c3f9798d42d462fd7">keySet</a>)</td></tr>
<tr class="separator:a1aa7d309807ce2fd3a9b4f11520b5601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9571500e8059e378a4583325104b30ea"><td class="memItemLeft" align="right" valign="top">std::future&lt; V * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a9571500e8059e378a4583325104b30ea">getAsync</a> (const K &amp;key, std::function&lt; V *(V *)&gt; success=nullptr, std::function&lt; V *(std::exception &amp;)&gt; fail=nullptr)</td></tr>
<tr class="separator:a9571500e8059e378a4583325104b30ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27c4a87f130672d085b3b70def3539c"><td class="memItemLeft" align="right" valign="top">V *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#ae27c4a87f130672d085b3b70def3539c">put</a> (const K &amp;key, const V &amp;val, uint64_t lifespan=0, uint64_t maxIdle=0)</td></tr>
<tr class="separator:ae27c4a87f130672d085b3b70def3539c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1dec546f8ef967b680b82be92a558e0"><td class="memItemLeft" align="right" valign="top">V *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#ae1dec546f8ef967b680b82be92a558e0">put</a> (const K &amp;key, const V &amp;val, uint64_t lifespan, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> lifespanUnit)</td></tr>
<tr class="separator:ae1dec546f8ef967b680b82be92a558e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549ccefc14a3e37f78e57595831b6da3"><td class="memItemLeft" align="right" valign="top">V *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a549ccefc14a3e37f78e57595831b6da3">put</a> (const K &amp;key, const V &amp;val, uint64_t lifespan, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> lifespanUnit, uint64_t maxIdle, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> maxIdleUnit)</td></tr>
<tr class="separator:a549ccefc14a3e37f78e57595831b6da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96546fc36545343be56c7fb06cc80178"><td class="memItemLeft" align="right" valign="top">std::future&lt; V * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a96546fc36545343be56c7fb06cc80178">putAsync</a> (const K &amp;key, const V &amp;val, uint64_t lifespan=0, uint64_t maxIdle=0, std::function&lt; V *(V *)&gt; success=nullptr, std::function&lt; V *(std::exception &amp;)&gt; fail=nullptr)</td></tr>
<tr class="separator:a96546fc36545343be56c7fb06cc80178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6245a5950f78c867c087ba1fb24c61"><td class="memItemLeft" align="right" valign="top">std::future&lt; V * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#acb6245a5950f78c867c087ba1fb24c61">putAsync</a> (const K &amp;key, const V &amp;val, uint64_t lifespan, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> lifespanUnit, std::function&lt; V *(V *)&gt; success=nullptr, std::function&lt; V *(std::exception &amp;)&gt; fail=nullptr)</td></tr>
<tr class="separator:acb6245a5950f78c867c087ba1fb24c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce18807a84df7681e00b0c4d022c499"><td class="memItemLeft" align="right" valign="top">std::future&lt; V * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a7ce18807a84df7681e00b0c4d022c499">putAsync</a> (const K &amp;key, const V &amp;val, uint64_t lifespan, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> lifespanUnit, uint64_t maxIdle, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> maxIdleUnit, std::function&lt; V *(V *)&gt; success=nullptr, std::function&lt; V *(std::exception &amp;)&gt; fail=nullptr)</td></tr>
<tr class="separator:a7ce18807a84df7681e00b0c4d022c499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a05c79135f4737840c0cb2b268ac520"><td class="memItemLeft" align="right" valign="top">V *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a3a05c79135f4737840c0cb2b268ac520">putIfAbsent</a> (const K &amp;key, const V &amp;val, uint64_t lifespan=0, uint64_t maxIdle=0)</td></tr>
<tr class="separator:a3a05c79135f4737840c0cb2b268ac520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481952f947f707ac38dbba5e8345c1fc"><td class="memItemLeft" align="right" valign="top">V *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a481952f947f707ac38dbba5e8345c1fc">putIfAbsent</a> (const K &amp;key, const V &amp;val, uint64_t lifespan, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> lifespanUnit)</td></tr>
<tr class="separator:a481952f947f707ac38dbba5e8345c1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ec23edf1ecbcef31ec73aaf670d63b"><td class="memItemLeft" align="right" valign="top">V *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a75ec23edf1ecbcef31ec73aaf670d63b">putIfAbsent</a> (const K &amp;key, const V &amp;val, uint64_t lifespan, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> lifespanUnit, uint64_t maxIdle, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> maxIdleUnit)</td></tr>
<tr class="separator:a75ec23edf1ecbcef31ec73aaf670d63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab3a1868d38e5be9db91a9157207a3b"><td class="memItemLeft" align="right" valign="top">std::future&lt; V * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#abab3a1868d38e5be9db91a9157207a3b">putIfAbsentAsync</a> (const K &amp;key, const V &amp;val, uint64_t lifespan=0, uint64_t maxIdle=0, std::function&lt; V *(V *)&gt; success=nullptr, std::function&lt; V *(std::exception &amp;)&gt; fail=nullptr)</td></tr>
<tr class="separator:abab3a1868d38e5be9db91a9157207a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bae2ae96a689a1d82543c115601ac65"><td class="memItemLeft" align="right" valign="top">std::future&lt; V * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a1bae2ae96a689a1d82543c115601ac65">putIfAbsentAsync</a> (const K &amp;key, const V &amp;val, uint64_t lifespan, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> lifespanUnit, std::function&lt; V *(V *)&gt; success=nullptr, std::function&lt; V *(std::exception &amp;)&gt; fail=nullptr)</td></tr>
<tr class="separator:a1bae2ae96a689a1d82543c115601ac65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6776d217eafba5fcea7312f277e89b"><td class="memItemLeft" align="right" valign="top">std::future&lt; V * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a2b6776d217eafba5fcea7312f277e89b">putIfAbsentAsync</a> (const K &amp;key, const V &amp;val, uint64_t lifespan, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> lifespanUnit, uint64_t maxIdle, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> maxIdleUnit, std::function&lt; V *(V *)&gt; success=nullptr, std::function&lt; V *(std::exception &amp;)&gt; fail=nullptr)</td></tr>
<tr class="separator:a2b6776d217eafba5fcea7312f277e89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af3996ae717f9c1950e8d73a4feeeaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a6af3996ae717f9c1950e8d73a4feeeaf">putAll</a> (const std::map&lt; K, V &gt; &amp;map, uint64_t lifespan=0, uint64_t maxIdle=0)</td></tr>
<tr class="separator:a6af3996ae717f9c1950e8d73a4feeeaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6495a5b64cb2e8869a9406c11ac900"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a2c6495a5b64cb2e8869a9406c11ac900">putAll</a> (const std::map&lt; K, V &gt; &amp;map, uint64_t lifespan, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> lifespanUnit)</td></tr>
<tr class="separator:a2c6495a5b64cb2e8869a9406c11ac900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c7801b431cd7c339fceebd81d83825"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a70c7801b431cd7c339fceebd81d83825">putAll</a> (const std::map&lt; K, V &gt; &amp;map, uint64_t lifespan, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> lifespanUnit, uint64_t maxIdle, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> maxIdleUnit)</td></tr>
<tr class="separator:a70c7801b431cd7c339fceebd81d83825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf61dc1ed6ca655ed3b461ef72c18609"><td class="memItemLeft" align="right" valign="top">std::future&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#abf61dc1ed6ca655ed3b461ef72c18609">putAllAsync</a> (const std::map&lt; K, V &gt; &amp;map, uint64_t lifespan=0, uint64_t maxIdle=0, std::function&lt; void()&gt; success=nullptr, std::function&lt; void(std::exception &amp;)&gt; fail=nullptr)</td></tr>
<tr class="separator:abf61dc1ed6ca655ed3b461ef72c18609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef55b3d80e751df089777787d05db28"><td class="memItemLeft" align="right" valign="top">std::future&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a0ef55b3d80e751df089777787d05db28">putAllAsync</a> (const std::map&lt; K, V &gt; &amp;map, uint64_t lifespan, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> lifespanUnit, std::function&lt; void(void)&gt; success=nullptr, std::function&lt; void(std::exception &amp;)&gt; fail=nullptr)</td></tr>
<tr class="separator:a0ef55b3d80e751df089777787d05db28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc46decb9403927c0f68b4f37b0a69d"><td class="memItemLeft" align="right" valign="top">std::future&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a5cc46decb9403927c0f68b4f37b0a69d">putAllAsync</a> (const std::map&lt; K, V &gt; &amp;map, uint64_t lifespan, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> lifespanUnit, uint64_t maxIdle, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> maxIdleUnit, std::function&lt; void(void)&gt; success=nullptr, std::function&lt; void(std::exception &amp;)&gt; fail=nullptr)</td></tr>
<tr class="separator:a5cc46decb9403927c0f68b4f37b0a69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7c62098b4d7f5b42531a010ab13692"><td class="memItemLeft" align="right" valign="top">V *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#afa7c62098b4d7f5b42531a010ab13692">replace</a> (const K &amp;key, const V &amp;val, uint64_t lifespan=0, uint64_t maxIdle=0)</td></tr>
<tr class="separator:afa7c62098b4d7f5b42531a010ab13692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c5e9cb17d096f11127e1c710d09bbd"><td class="memItemLeft" align="right" valign="top">V *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a06c5e9cb17d096f11127e1c710d09bbd">replace</a> (const K &amp;key, const V &amp;val, uint64_t lifespan, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> lifespanUnit)</td></tr>
<tr class="separator:a06c5e9cb17d096f11127e1c710d09bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a66ff47ed1ea9ffcb5934708975d92f"><td class="memItemLeft" align="right" valign="top">V *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a3a66ff47ed1ea9ffcb5934708975d92f">replace</a> (const K &amp;key, const V &amp;val, uint64_t lifespan, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> lifespanUnit, uint64_t maxIdle, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> maxIdleUnit)</td></tr>
<tr class="separator:a3a66ff47ed1ea9ffcb5934708975d92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6212108a46b949b84c5a1a2b04be1a75"><td class="memItemLeft" align="right" valign="top">V *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a6212108a46b949b84c5a1a2b04be1a75">replace</a> (const K &amp;key, const V &amp;oldVal, const V &amp;val, uint64_t lifespan=0, uint64_t maxIdle=0)</td></tr>
<tr class="separator:a6212108a46b949b84c5a1a2b04be1a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574b7c33d4cdb7b9afc14ff0f3a14031"><td class="memItemLeft" align="right" valign="top">V *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a574b7c33d4cdb7b9afc14ff0f3a14031">replace</a> (const K &amp;key, const V &amp;oldVal, const V &amp;val, uint64_t lifespan, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> lifespanUnit)</td></tr>
<tr class="separator:a574b7c33d4cdb7b9afc14ff0f3a14031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e36590898ab93468236de1bde9e6d8"><td class="memItemLeft" align="right" valign="top">V *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a71e36590898ab93468236de1bde9e6d8">replace</a> (const K &amp;key, const V &amp;oldVal, const V &amp;val, uint64_t lifespan, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> lifespanUnit, uint64_t maxIdle, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> maxIdleUnit)</td></tr>
<tr class="separator:a71e36590898ab93468236de1bde9e6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421c4d5c3ccac25b92636238f1ffad24"><td class="memItemLeft" align="right" valign="top">std::future&lt; V * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a421c4d5c3ccac25b92636238f1ffad24">replaceAsync</a> (const K &amp;key, const V &amp;val, uint64_t lifespan=0, uint64_t maxIdle=0, std::function&lt; V *(V *)&gt; success=nullptr, std::function&lt; V *(std::exception &amp;)&gt; fail=nullptr)</td></tr>
<tr class="separator:a421c4d5c3ccac25b92636238f1ffad24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a13a695c15c57e6d2b52b5859f3228"><td class="memItemLeft" align="right" valign="top">std::future&lt; V * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#ad0a13a695c15c57e6d2b52b5859f3228">replaceAsync</a> (const K &amp;key, const V &amp;val, uint64_t lifespan, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> lifespanUnit, std::function&lt; V *(V *)&gt; success=nullptr, std::function&lt; V *(std::exception &amp;)&gt; fail=nullptr)</td></tr>
<tr class="separator:ad0a13a695c15c57e6d2b52b5859f3228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf6b30ce09d4771330586da42b6e634"><td class="memItemLeft" align="right" valign="top">std::future&lt; V * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#acdf6b30ce09d4771330586da42b6e634">replaceAsync</a> (const K &amp;key, const V &amp;val, uint64_t lifespan, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> lifespanUnit, uint64_t maxIdle, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> maxIdleUnit, std::function&lt; V *(V *)&gt; success=nullptr, std::function&lt; V *(std::exception &amp;)&gt; fail=nullptr)</td></tr>
<tr class="separator:acdf6b30ce09d4771330586da42b6e634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6294e4e99bccf1691eb16441f583e9ba"><td class="memItemLeft" align="right" valign="top">std::future&lt; V * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a6294e4e99bccf1691eb16441f583e9ba">replaceAsync</a> (const K &amp;key, const V &amp;oldVal, const V &amp;val, uint64_t lifespan=0, uint64_t maxIdle=0, std::function&lt; V *(V *)&gt; success=nullptr, std::function&lt; V *(std::exception &amp;)&gt; fail=nullptr)</td></tr>
<tr class="separator:a6294e4e99bccf1691eb16441f583e9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95ac1cf008ddca21c81c09dc8ee2813"><td class="memItemLeft" align="right" valign="top">std::future&lt; V * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#af95ac1cf008ddca21c81c09dc8ee2813">replaceAsync</a> (const K &amp;key, const V &amp;oldVal, const V &amp;val, uint64_t lifespan, <a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a> lifespanUnit, std::function&lt; V *(V *)&gt; success=nullptr, std::function&lt; V *(std::exception &amp;)&gt; fail=nullptr)</td></tr>
<tr class="separator:af95ac1cf008ddca21c81c09dc8ee2813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e507ee49060d1fabd7c3ac6238f0d6"><td class="memItemLeft" align="right" valign="top">V *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#ad2e507ee49060d1fabd7c3ac6238f0d6">remove</a> (const K &amp;key)</td></tr>
<tr class="separator:ad2e507ee49060d1fabd7c3ac6238f0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32aca3ed89425119fdc474b8b3bf9fa4"><td class="memItemLeft" align="right" valign="top">std::future&lt; V * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a32aca3ed89425119fdc474b8b3bf9fa4">removeAsync</a> (const K &amp;key, std::function&lt; V *(V *)&gt; success=nullptr, std::function&lt; V *(std::exception &amp;)&gt; fail=nullptr)</td></tr>
<tr class="separator:a32aca3ed89425119fdc474b8b3bf9fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dba0a6f41f27d2ec3a7b95dac011431"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a0dba0a6f41f27d2ec3a7b95dac011431">containsKey</a> (const K &amp;key)</td></tr>
<tr class="separator:a0dba0a6f41f27d2ec3a7b95dac011431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadca2a06739ab7090ef70444d8e7a7cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#aadca2a06739ab7090ef70444d8e7a7cd">containsValue</a> (const V &amp;val)</td></tr>
<tr class="separator:aadca2a06739ab7090ef70444d8e7a7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa97af7e1eaf33cb3f32cfc56cfb009f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#afa97af7e1eaf33cb3f32cfc56cfb009f">replaceWithVersion</a> (const K &amp;key, const V &amp;val, uint64_t version, uint64_t lifespan=0, uint64_t maxIdle=0)</td></tr>
<tr class="separator:afa97af7e1eaf33cb3f32cfc56cfb009f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e2b03a691e417e79ad921923b02bd6"><td class="memItemLeft" align="right" valign="top">std::future&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a76e2b03a691e417e79ad921923b02bd6">replaceWithVersionAsync</a> (const K &amp;key, const V &amp;val, uint64_t version, uint64_t lifespan, uint64_t maxIdle, std::function&lt; bool(bool)&gt; success=nullptr, std::function&lt; bool(std::exception &amp;)&gt; fail=nullptr)</td></tr>
<tr class="separator:a76e2b03a691e417e79ad921923b02bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57985bda583ef7363c46b15982699f40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a57985bda583ef7363c46b15982699f40">removeWithVersion</a> (const K &amp;key, uint64_t version)</td></tr>
<tr class="separator:a57985bda583ef7363c46b15982699f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad937bd75bf386036fa954fedb1c7b752"><td class="memItemLeft" align="right" valign="top">std::future&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#ad937bd75bf386036fa954fedb1c7b752">removeWithVersionAsync</a> (const K &amp;key, uint64_t version, std::function&lt; bool(bool)&gt; success=nullptr, std::function&lt; bool(std::exception &amp;)&gt; fail=nullptr)</td></tr>
<tr class="separator:ad937bd75bf386036fa954fedb1c7b752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53354bd49905316f95109f003db1832c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::shared_ptr&lt; V &gt;<br class="typebreak"/>
, <a class="el" href="classinfinispan_1_1hotrod_1_1VersionedValue.html">VersionedValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a53354bd49905316f95109f003db1832c">getWithVersion</a> (const K &amp;key)</td></tr>
<tr class="separator:a53354bd49905316f95109f003db1832c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5e8159131d653479fc623bd109a696"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::shared_ptr&lt; V &gt;<br class="typebreak"/>
, <a class="el" href="classinfinispan_1_1hotrod_1_1MetadataValue.html">MetadataValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#afb5e8159131d653479fc623bd109a696">getWithMetadata</a> (const K &amp;key)</td></tr>
<tr class="separator:afb5e8159131d653479fc623bd109a696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4d5e3d895db02f3277898dfcd7a520"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::shared_ptr&lt; K &gt;<br class="typebreak"/>
, std::shared_ptr&lt; V &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a2c4d5e3d895db02f3277898dfcd7a520">getBulk</a> ()</td></tr>
<tr class="separator:a2c4d5e3d895db02f3277898dfcd7a520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcfd0830004affe9af29c0fc59e5790"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::shared_ptr&lt; K &gt;<br class="typebreak"/>
, std::shared_ptr&lt; V &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#afbcfd0830004affe9af29c0fc59e5790">getBulk</a> (int nrOfEntries)</td></tr>
<tr class="separator:afbcfd0830004affe9af29c0fc59e5790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6872e9a22eb71bd71e1cb2e184d0496b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a6872e9a22eb71bd71e1cb2e184d0496b">execute</a> (const std::string &amp;name, const std::map&lt; std::string, std::string &gt; &amp;args)</td></tr>
<tr class="separator:a6872e9a22eb71bd71e1cb2e184d0496b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96caf2583f019ec27e1b0c873edad3d6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a96caf2583f019ec27e1b0c873edad3d6">execute</a> (const std::string &amp;name, const std::map&lt; std::vector&lt; char &gt;, std::vector&lt; char &gt; &gt; &amp;args)</td></tr>
<tr class="separator:a96caf2583f019ec27e1b0c873edad3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434c60cac73f3d82a75b8a8aae4234d9"><td class="memItemLeft" align="right" valign="top">QueryResponse&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a434c60cac73f3d82a75b8a8aae4234d9">query</a> (const <a class="el" href="classorg_1_1infinispan_1_1query_1_1remote_1_1client_1_1QueryRequest.html">QueryRequest</a> &amp;qr)</td></tr>
<tr class="separator:a434c60cac73f3d82a75b8a8aae4234d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9b8e24981493b5c7702c275cc9c355"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a1b9b8e24981493b5c7702c275cc9c355">query</a> (std::vector&lt; unsigned char &gt; qr, size_t <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a77b266e88a0ec6021dfe95a75b65804c">size</a>)</td></tr>
<tr class="separator:a1b9b8e24981493b5c7702c275cc9c355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b597ca928b1a893841fa6b7c845e19d"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::pair&lt; K, V &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a1b597ca928b1a893841fa6b7c845e19d">entrySet</a> ()</td></tr>
<tr class="separator:a1b597ca928b1a893841fa6b7c845e19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce2d43a2e32f67c3f9798d42d462fd7"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::shared_ptr&lt; K &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a4ce2d43a2e32f67c3f9798d42d462fd7">keySet</a> ()</td></tr>
<tr class="separator:a4ce2d43a2e32f67c3f9798d42d462fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b266e88a0ec6021dfe95a75b65804c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a77b266e88a0ec6021dfe95a75b65804c">size</a> ()</td></tr>
<tr class="separator:a77b266e88a0ec6021dfe95a75b65804c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe22b5c1eec003f874f407fb997a171"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a3fe22b5c1eec003f874f407fb997a171">isEmpty</a> ()</td></tr>
<tr class="separator:a3fe22b5c1eec003f874f407fb997a171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b53d237dc4f500d320678a74b3ea967"><td class="memItemLeft" align="right" valign="top">std::vector&lt; V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a8b53d237dc4f500d320678a74b3ea967">values</a> ()</td></tr>
<tr class="separator:a8b53d237dc4f500d320678a74b3ea967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ccb45d732f94e461835a0c1a8efba8"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a74ccb45d732f94e461835a0c1a8efba8">stats</a> ()</td></tr>
<tr class="separator:a74ccb45d732f94e461835a0c1a8efba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322919c71536c5a9734d8affdfc8ecaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a322919c71536c5a9734d8affdfc8ecaa">clear</a> ()</td></tr>
<tr class="separator:a322919c71536c5a9734d8affdfc8ecaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ac50bb4b27d1bce98b64e68c4215d6"><td class="memItemLeft" align="right" valign="top">std::future&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a86ac50bb4b27d1bce98b64e68c4215d6">clearAsync</a> (std::function&lt; void(void)&gt; success=nullptr, std::function&lt; void(std::exception &amp;)&gt; fail=nullptr)</td></tr>
<tr class="separator:a86ac50bb4b27d1bce98b64e68c4215d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edca57d13d5045960437bc4407c6eba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a0edca57d13d5045960437bc4407c6eba">ping</a> ()</td></tr>
<tr class="separator:a0edca57d13d5045960437bc4407c6eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eee2e6eeea8b62094bd6ee42163c7c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a6eee2e6eeea8b62094bd6ee42163c7c8">addClientListener</a> (<a class="el" href="classinfinispan_1_1hotrod_1_1event_1_1ClientListener.html">ClientListener</a> &amp;clientListener, std::vector&lt; std::vector&lt; char &gt; &gt; filterFactoryParams, std::vector&lt; std::vector&lt; char &gt; &gt; converterFactoryParams, const std::function&lt; void()&gt; &amp;recoveryCallback=nullptr)</td></tr>
<tr class="separator:a6eee2e6eeea8b62094bd6ee42163c7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d253799622312ab77a4e2d0c4d7867"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a05d253799622312ab77a4e2d0c4d7867">removeClientListener</a> (<a class="el" href="classinfinispan_1_1hotrod_1_1event_1_1ClientListener.html">ClientListener</a> &amp;clientListener)</td></tr>
<tr class="separator:a05d253799622312ab77a4e2d0c4d7867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dfb5687fb7fba63229f69a40c2efc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a41dfb5687fb7fba63229f69a40c2efc3">addContinuousQueryListener</a> (<a class="el" href="classinfinispan_1_1hotrod_1_1event_1_1ContinuousQueryListener.html">ContinuousQueryListener</a>&lt; K, V &gt; &amp;cql)</td></tr>
<tr class="separator:a41dfb5687fb7fba63229f69a40c2efc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac821e465b64793c990f07ce445a171a2"><td class="memTemplParams" colspan="2">template&lt;typename... Params&gt; </td></tr>
<tr class="memitem:ac821e465b64793c990f07ce445a171a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#ac821e465b64793c990f07ce445a171a2">addContinuousQueryListener</a> (<a class="el" href="classinfinispan_1_1hotrod_1_1event_1_1ContinuousQueryListener.html">ContinuousQueryListener</a>&lt; K, V, Params...&gt; &amp;cql)</td></tr>
<tr class="separator:ac821e465b64793c990f07ce445a171a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9fd345533ec44dd603f8ff860ef73ba"><td class="memTemplParams" colspan="2">template&lt;typename... Params&gt; </td></tr>
<tr class="memitem:ac9fd345533ec44dd603f8ff860ef73ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#ac9fd345533ec44dd603f8ff860ef73ba">removeContinuousQueryListener</a> (<a class="el" href="classinfinispan_1_1hotrod_1_1event_1_1ContinuousQueryListener.html">ContinuousQueryListener</a>&lt; Params...&gt; &amp;cql)</td></tr>
<tr class="separator:ac9fd345533ec44dd603f8ff860ef73ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc847ec92ea82c639b189d60c2b426d0"><td class="memItemLeft" align="right" valign="top">CacheTopologyInfo&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#abc847ec92ea82c639b189d60c2b426d0">getCacheTopologyInfo</a> ()</td></tr>
<tr class="separator:abc847ec92ea82c639b189d60c2b426d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e311f6f8744cad478ff9ab3fce15a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">RemoteCache</a>&lt; K, V &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#aa5e311f6f8744cad478ff9ab3fce15a3">withFlags</a> (<a class="el" href="namespaceinfinispan_1_1hotrod.html#a28ac91e3e8787e94b91bb12aa824a95a">Flag</a> flags)</td></tr>
<tr class="separator:aa5e311f6f8744cad478ff9ab3fce15a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1227f48994b55977a7ef863897b74300"><td class="memTemplParams" colspan="2">template&lt;class M  = JBossMarshaller&gt; </td></tr>
<tr class="memitem:a1227f48994b55977a7ef863897b74300"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteExecution.html">RemoteExecution</a>&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a1227f48994b55977a7ef863897b74300">getRemoteExecution</a> ()</td></tr>
<tr class="separator:a1227f48994b55977a7ef863897b74300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f56055dff40131f5e3d9c58620b7a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a28f56055dff40131f5e3d9c58620b7a0">RemoteCache</a> (const <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">RemoteCache</a> &amp;other)</td></tr>
<tr class="separator:a28f56055dff40131f5e3d9c58620b7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e781a2aae6093640297eca9b3fe5ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">RemoteCache</a>&lt; K, V &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a31e781a2aae6093640297eca9b3fe5ba">operator=</a> (const <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">RemoteCache</a> &amp;other)</td></tr>
<tr class="separator:a31e781a2aae6093640297eca9b3fe5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a78416eddf63198e7505e487b95f9874c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a78416eddf63198e7505e487b95f9874c">RemoteCache</a> ()</td></tr>
<tr class="separator:a78416eddf63198e7505e487b95f9874c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a12e3f9cc9c40b896d316366b5a26c23f"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a12e3f9cc9c40b896d316366b5a26c23f">RemoteCacheManager</a></td></tr>
<tr class="separator:a12e3f9cc9c40b896d316366b5a26c23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class K, class V&gt;<br/>
class infinispan::hotrod::RemoteCache&lt; K, V &gt;</h3>

<p>Provides remote reference to a cache residing on a Hot Rod server/cluster.</p>
<p>RemoteCache is intended to be similar to Infinispan Java RemoteCache interface as much as possible. Just like RemoteCache interface in its Java HotRod counterpart RemoteCache features:</p>
<p><b>New methods</b>: Although some methods are very simila to Java Map interface, RemoteCache also adds new methods to optimize/reduce network traffic: e.g. versioned put operation.</p>
<p><b>Concurrency</b>: implementations will support multi-threaded access.</p>
<p><b>Return values</b>: previously existing values for certain methods are not returned, NULL is returned instead unless method is using fluent variant withFlags (see below).</p>
<p><b>Synthetic methods</b>: aggregate methods are being implemented based on other Hot Rod operations. For example, putAll method is implemented using multiple individual puts. Therefore these methods are not atomic and that they are costly, e.g. as the number of network round-trips is not one, but the size of the added map.</p>
<p>It is possible change the default method behavior using Flag enum. For example: </p>
<pre>
     RemoteCache cache = ...;
     std::auto_ptr&lt;std::string&gt; rv(cache.withFlags(FORCE_RETURN_VALUE).put(k,v));
</pre><p>In the previous example Flag enum FORCE_RETURN_VALUE will make the client to also return previously existing value associated with <code>k</code> key. If this flag would not be present, RemoteCache would return (by default) <code>NULL</code>. This is in order to avoid fetching a possibly large object from the remote server, which might not be needed.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a28f56055dff40131f5e3d9c58620b7a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::<a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">RemoteCache</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">RemoteCache</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a78416eddf63198e7505e487b95f9874c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::<a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">RemoteCache</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6eee2e6eeea8b62094bd6ee42163c7c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::addClientListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinfinispan_1_1hotrod_1_1event_1_1ClientListener.html">ClientListener</a> &amp;&#160;</td>
          <td class="paramname"><em>clientListener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; char &gt; &gt;&#160;</td>
          <td class="paramname"><em>filterFactoryParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; char &gt; &gt;&#160;</td>
          <td class="paramname"><em>converterFactoryParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>recoveryCallback</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start client listener and register it on the server</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clientListener</td><td>object defining the listener, filter and converter and the callback funcs </td></tr>
    <tr><td class="paramname">filterFactoryParams</td><td>parameters for optional server filter setup </td></tr>
    <tr><td class="paramname">converterFactoryParams</td><td>parameter for optional server converter setup </td></tr>
    <tr><td class="paramname">recoveryCallback</td><td>function to be called if transport goes down </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a41dfb5687fb7fba63229f69a40c2efc3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::addContinuousQueryListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinfinispan_1_1hotrod_1_1event_1_1ContinuousQueryListener.html">ContinuousQueryListener</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>cql</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start a client listener on the specified query and register it on the server</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cql</td><td>object defining the query to be observed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac821e465b64793c990f07ce445a171a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<div class="memtemplate">
template&lt;typename... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::addContinuousQueryListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinfinispan_1_1hotrod_1_1event_1_1ContinuousQueryListener.html">ContinuousQueryListener</a>&lt; K, V, Params...&gt; &amp;&#160;</td>
          <td class="paramname"><em>cql</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start a client listener on a query that returns projection or aggregate and register it on the server</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cql</td><td>object defining the query to be observed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a322919c71536c5a9734d8affdfc8ecaa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears all entries in this cache </p>

</div>
</div>
<a class="anchor" id="a86ac50bb4b27d1bce98b64e68c4215d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt;void&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::clearAsync </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(void)&gt;&#160;</td>
          <td class="paramname"><em>success</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(std::exception &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fail</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronous version of <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a322919c71536c5a9734d8affdfc8ecaa">clear()</a> See the synchronous doc for parameters not explained here </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>function to be executed on success </td></tr>
    <tr><td class="paramname">fail</td><td>function to be executed if exceptions occur </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future containing a bool. True if the entry has been removed </dd></dl>

</div>
</div>
<a class="anchor" id="a0dba0a6f41f27d2ec3a7b95dac011431"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::containsKey </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this cache contains a key/value pair where the key is equal to a specified key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if such key is present in this cache </dd></dl>

</div>
</div>
<a class="anchor" id="aadca2a06739ab7090ef70444d8e7a7cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::containsValue </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsupported operation in this release of Hot Rod client. <a class="el" href="structinfinispan_1_1hotrod_1_1UnsupportedOperationException.html">UnsupportedOperationException</a> is thrown if his method is invoked. </p>

</div>
</div>
<a class="anchor" id="a1b597ca928b1a893841fa6b7c845e19d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;std::pair&lt;K, V&gt; &gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::entrySet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsupported operation in this release of Hot Rod client. <a class="el" href="structinfinispan_1_1hotrod_1_1UnsupportedOperationException.html">UnsupportedOperationException</a> is thrown if his method is invoked. </p>

</div>
</div>
<a class="anchor" id="a6872e9a22eb71bd71e1cb2e184d0496b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned char&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::execute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Execute script on server </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the script </td></tr>
    <tr><td class="paramname">args</td><td>maps of (name,value) arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte[] result in dark matter shape </dd></dl>

</div>
</div>
<a class="anchor" id="a96caf2583f019ec27e1b0c873edad3d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned char&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::execute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::vector&lt; char &gt;, std::vector&lt; char &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Execute script on server </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the script </td></tr>
    <tr><td class="paramname">args</td><td>maps of (name,value) arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte[] result in dark matter shape </dd></dl>

</div>
</div>
<a class="anchor" id="ae09e72a491c778cb4a3c61018f22b6f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V* <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value to which the specified key is mapped, or NULL if this cache contains no mapping for the key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key whose associated value is to be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value to which the specified key is mapped, or NULL if this map contains no mapping for the key </dd></dl>

</div>
</div>
<a class="anchor" id="a1aa7d309807ce2fd3a9b4f11520b5601"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::shared_ptr&lt;K&gt;, std::shared_ptr&lt;V&gt; &gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::getAll </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keySet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a map of key,value pairs according to the set of keys passed in input</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keySet</td><td>the set of the keys whose associated values are to be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a map containing the key, value pairs </dd></dl>

</div>
</div>
<a class="anchor" id="a9571500e8059e378a4583325104b30ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt;V*&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::getAsync </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(V *)&gt;&#160;</td>
          <td class="paramname"><em>success</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(std::exception &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fail</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronous version of get. Executes function f when <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#ae09e72a491c778cb4a3c61018f22b6f4">get()</a> returns</p>
<p>See the synchronous doc for parameters not explained here </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key whose associated value is to be returned </td></tr>
    <tr><td class="paramname">success</td><td>function to be executed on success </td></tr>
    <tr><td class="paramname">fail</td><td>function to be executed if exceptions occur </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future that will contain a pointer to the requested value or null </dd></dl>

</div>
</div>
<a class="anchor" id="a2c4d5e3d895db02f3277898dfcd7a520"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::shared_ptr&lt;K&gt;, std::shared_ptr&lt;V&gt; &gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::getBulk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsupported operation in this release of Hot Rod client. <a class="el" href="structinfinispan_1_1hotrod_1_1UnsupportedOperationException.html">UnsupportedOperationException</a> is thrown if his method is invoked. </p>

</div>
</div>
<a class="anchor" id="afbcfd0830004affe9af29c0fc59e5790"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::shared_ptr&lt;K&gt;, std::shared_ptr&lt;V&gt; &gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::getBulk </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrOfEntries</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns nrOfEntries from a remote cache in map. TODO </p>

</div>
</div>
<a class="anchor" id="abc847ec92ea82c639b189d60c2b426d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CacheTopologyInfo <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::getCacheTopologyInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a895dc86326bd3ed90f8a7ba350d9057e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves the name of the cache</p>
<dl class="section return"><dt>Returns</dt><dd>the name of the cache </dd></dl>

</div>
</div>
<a class="anchor" id="a3d52129f2aa9bdd2faa7442ba1bd8549"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::getProtocolVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves the protocol version</p>
<dl class="section return"><dt>Returns</dt><dd>protocol version as string </dd></dl>

</div>
</div>
<a class="anchor" id="a1227f48994b55977a7ef863897b74300"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<div class="memtemplate">
template&lt;class M  = JBossMarshaller&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteExecution.html">RemoteExecution</a>&lt;M&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::getRemoteExecution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a remote execution context</p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteExecution.html">RemoteExecution</a> object that simplify the call of a remote execution task </dd></dl>

</div>
</div>
<a class="anchor" id="acfe553aa4fc2ccd65fe560acea3e4a5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::getVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves the version of Infinispan</p>
<dl class="section return"><dt>Returns</dt><dd>a version string </dd></dl>

</div>
</div>
<a class="anchor" id="afb5e8159131d653479fc623bd109a696"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::shared_ptr&lt;V&gt;, <a class="el" href="classinfinispan_1_1hotrod_1_1MetadataValue.html">MetadataValue</a>&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::getWithMetadata </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the std::pair with value and <a class="el" href="classinfinispan_1_1hotrod_1_1MetadataValue.html">MetadataValue</a> associated to the supplied key parameter or a default initialized std::pair if it doesn't exist</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair where first entry is a pointer to a value and second pair entry is an accompanying <a class="el" href="classinfinispan_1_1hotrod_1_1MetadataValue.html">MetadataValue</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a53354bd49905316f95109f003db1832c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::shared_ptr&lt;V&gt;, <a class="el" href="classinfinispan_1_1hotrod_1_1VersionedValue.html">VersionedValue</a>&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::getWithVersion </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the std::pair with value and <a class="el" href="classinfinispan_1_1hotrod_1_1VersionedValue.html">VersionedValue</a> associated with the supplied key parameter or a default initialized std::pair if it doesn't exist</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair where first entry is a pointer to a value and second pair entry is an accompanying <a class="el" href="classinfinispan_1_1hotrod_1_1VersionedValue.html">VersionedValue</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3fe22b5c1eec003f874f407fb997a171"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if and only if this cache has no entries.</p>
<dl class="section return"><dt>Returns</dt><dd>true if cache is empty </dd></dl>

</div>
</div>
<a class="anchor" id="a4ce2d43a2e32f67c3f9798d42d462fd7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;std::shared_ptr&lt;K&gt; &gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::keySet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns all keys in the remote server. It'll invoke a command over the network each time this method is called. If the remote cache is a distributed cache, it will retrieve all of the keys from all nodes in the cluster. Please use with care for cache with large data set.</p>
<dl class="section return"><dt>Returns</dt><dd>a std::set of pointers to all keys in this given cache </dd></dl>

</div>
</div>
<a class="anchor" id="a31e781a2aae6093640297eca9b3fe5ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">RemoteCache</a>&lt;K, V&gt;&amp; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">RemoteCache</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0edca57d13d5045960437bc4407c6eba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::ping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pings remote cache on a Hot Rod server </p>

</div>
</div>
<a class="anchor" id="ae27c4a87f130672d085b3b70def3539c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V* <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::put </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>maxIdle</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Associates the specified value with the specified key in this cache.</p>
<p>If the cache previously contained a mapping for the key, the old value is replaced by the specified value.</p>
<p>If the return value of this operation will be ignored by the application, the user is strongly encouraged to use the IGNORE_RETURN_VALUES Flag when invoking this method in order to make it behave as efficiently as possible (i.e. avoiding needless remote or network calls).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td class="paramname">val</td><td>value value to be associated with the specified key </td></tr>
    <tr><td class="paramname">lifespan</td><td>the lifespan of this entry. A negative value is interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">maxIdle</td><td>the maximum amount of time this entry is allowed to be idle before it is considered as expired</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value associated with key, or NULL if there was no mapping for key. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1dec546f8ef967b680b82be92a558e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V* <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::put </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>lifespanUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Associates the specified value with the specified key in this cache.</p>
<p>If the cache previously contained a mapping for the key, the old value is replaced by the specified value.</p>
<p>If the return value of this operation will be ignored by the application, the user is strongly encouraged to use the IGNORE_RETURN_VALUES Flag when invoking this method in order to make it behave as efficiently as possible (i.e. avoiding needless remote or network calls).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td class="paramname">val</td><td>value value to be associated with the specified key </td></tr>
    <tr><td class="paramname">lifespan</td><td>the lifespan of this entry. A negative value is interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">lifespanUnit</td><td>TimeUnit for the lifespan param</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value associated with key, or NULL if there was no mapping for key. </dd></dl>

</div>
</div>
<a class="anchor" id="a549ccefc14a3e37f78e57595831b6da3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V* <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::put </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>lifespanUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>maxIdle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>maxIdleUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Associates the specified value with the specified key in this cache. </p>
<p>If the cache previously contained a mapping for the key, the old value is replaced by the specified value. </p>
<p>If the return value of this operation will be ignored by the application, the user is strongly encouraged to use the IGNORE_RETURN_VALUES Flag when invoking this method in order to make it behave as efficiently as possible (i.e. avoiding needless remote or network calls).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td class="paramname">val</td><td>value value to be associated with the specified key </td></tr>
    <tr><td class="paramname">lifespan</td><td>the lifespan of this entry. A negative value is interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">lifespanUnit</td><td>TimeUnit for the lifespan param </td></tr>
    <tr><td class="paramname">maxIdle</td><td>the maximum amount of time this entry is allowed to be idle before it is considered as expired </td></tr>
    <tr><td class="paramname">maxIdleUnit</td><td>TimeUnit for the maxIdle param</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value associated with key, or NULL if there was no mapping for key. </dd></dl>

</div>
</div>
<a class="anchor" id="a6af3996ae717f9c1950e8d73a4feeeaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::putAll </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>maxIdle</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies all of the mappings from the specified map to this cache. The effect of this call is equivalent to that of calling put(k, v) on this cache once for each mapping from key k to value v in the specified map. The behavior of this operation is undefined if the specified map is modified while the operation is in progress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>to be stored in this cache </td></tr>
    <tr><td class="paramname">lifespan</td><td>the lifespan of this entry. A negative value is interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">maxIdle</td><td>the maximum amount of time these object are allowed to be idle before they are considered as expired </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c6495a5b64cb2e8869a9406c11ac900"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::putAll </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>lifespanUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies all of the mappings from the specified map to this cache. The effect of this call is equivalent to that of calling put(k, v) on this cache once for each mapping from key k to value v in the specified map. The behavior of this operation is undefined if the specified map is modified while the operation is in progress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>to be stored in this cache </td></tr>
    <tr><td class="paramname">lifespan</td><td>the lifespan of this entry. A negative value is interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">lifespanUnit</td><td>TimeUnit for the lifespan param </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70c7801b431cd7c339fceebd81d83825"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::putAll </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>lifespanUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>maxIdle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>maxIdleUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies all of the mappings from the specified map to this cache. The effect of this call is equivalent to that of calling put(k, v) on this cache once for each mapping from key k to value v in the specified map. The behavior of this operation is undefined if the specified map is modified while the operation is in progress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>to be stored in this cache </td></tr>
    <tr><td class="paramname">lifespan</td><td>the lifespan of this entry. A negative value is interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">lifespanUnit</td><td>TimeUnit for the lifespan param </td></tr>
    <tr><td class="paramname">maxIdle</td><td>the maximum amount of time these object are allowed to be idle before they are considered as expired </td></tr>
    <tr><td class="paramname">maxIdleUnit</td><td>TimeUnit for the maxIdle param </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf61dc1ed6ca655ed3b461ef72c18609"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt;void&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::putAllAsync </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>maxIdle</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>success</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(std::exception &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fail</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronous version of <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a6af3996ae717f9c1950e8d73a4feeeaf">putAll()</a> See the synchronous doc for parameters not explained here </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>to be stored in this cache </td></tr>
    <tr><td class="paramname">lifespan</td><td>the lifespan of these entries. A negative value is interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">maxIdle</td><td>the maximum amount of time these objects are allowed to be idle before they are considered as expired </td></tr>
    <tr><td class="paramname">success</td><td>function to be executed on success </td></tr>
    <tr><td class="paramname">fail</td><td>function to be executed if exceptions occur </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future containing a pointer to the previous value stored in the cache for the given key or null </dd></dl>

</div>
</div>
<a class="anchor" id="a0ef55b3d80e751df089777787d05db28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt;void&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::putAllAsync </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>lifespanUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(void)&gt;&#160;</td>
          <td class="paramname"><em>success</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(std::exception &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fail</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronous version of <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a6af3996ae717f9c1950e8d73a4feeeaf">putAll()</a> See the synchronous doc for parameters not explained here </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>to be stored in this cache </td></tr>
    <tr><td class="paramname">lifespan</td><td>the lifespan of these entries. A negative value is interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">lifespanUnit</td><td>TimeUnit for the lifespan param </td></tr>
    <tr><td class="paramname">success</td><td>function to be executed on success </td></tr>
    <tr><td class="paramname">fail</td><td>function to be executed if exceptions occur </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future containing a pointer to the previous value stored in the cache for the given key or null </dd></dl>

</div>
</div>
<a class="anchor" id="a5cc46decb9403927c0f68b4f37b0a69d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt;void&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::putAllAsync </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>lifespanUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>maxIdle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>maxIdleUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(void)&gt;&#160;</td>
          <td class="paramname"><em>success</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(std::exception &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fail</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronous version of <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a6af3996ae717f9c1950e8d73a4feeeaf">putAll()</a> See the synchronous doc for parameters not explained here </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>to be stored in this cache </td></tr>
    <tr><td class="paramname">lifespan</td><td>the lifespan of these entries. A negative value is interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">lifespanUnit</td><td>TimeUnit for the lifespan param </td></tr>
    <tr><td class="paramname">maxIdle</td><td>the maximum amount of time these are allowed to be idle before they are considered as expired </td></tr>
    <tr><td class="paramname">maxIdleUnit</td><td>TimeUnit for the maxIdle param </td></tr>
    <tr><td class="paramname">success</td><td>function to be executed on success </td></tr>
    <tr><td class="paramname">fail</td><td>function to be executed if exceptions occur </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future containing a pointer to the previous value stored in the cache for the given key or null </dd></dl>

</div>
</div>
<a class="anchor" id="a96546fc36545343be56c7fb06cc80178"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt;V*&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::putAsync </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>maxIdle</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(V *)&gt;&#160;</td>
          <td class="paramname"><em>success</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(std::exception &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fail</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronous version of <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#ae27c4a87f130672d085b3b70def3539c">put()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td class="paramname">val</td><td>value value to be associated with the specified key </td></tr>
    <tr><td class="paramname">lifespan</td><td>the lifespan of this entry. A negative value is interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">maxIdle</td><td>the maximum amount of time this entry is allowed to be idle before it is considered as expired </td></tr>
    <tr><td class="paramname">success</td><td>function to be executed on success </td></tr>
    <tr><td class="paramname">fail</td><td>function to be executed if exceptions occur </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future containing a pointer to the previous value stored in the cache for the given key or null </dd></dl>

</div>
</div>
<a class="anchor" id="acb6245a5950f78c867c087ba1fb24c61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt;V*&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::putAsync </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>lifespanUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(V *)&gt;&#160;</td>
          <td class="paramname"><em>success</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(std::exception &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fail</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronous version of <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#ae27c4a87f130672d085b3b70def3539c">put()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td class="paramname">val</td><td>value value to be associated with the specified key </td></tr>
    <tr><td class="paramname">lifespan</td><td>the lifespan of this entry. A negative value is interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">lifespanUnit</td><td>TimeUnit for the lifespan param </td></tr>
    <tr><td class="paramname">success</td><td>function to be executed on success </td></tr>
    <tr><td class="paramname">fail</td><td>function to be executed if exceptions occur </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future containing a pointer to the previous value stored in the cache for the given key or null </dd></dl>

</div>
</div>
<a class="anchor" id="a7ce18807a84df7681e00b0c4d022c499"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt;V*&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::putAsync </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>lifespanUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>maxIdle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>maxIdleUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(V *)&gt;&#160;</td>
          <td class="paramname"><em>success</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(std::exception &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fail</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronous version of <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#ae27c4a87f130672d085b3b70def3539c">put()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td class="paramname">val</td><td>value value to be associated with the specified key </td></tr>
    <tr><td class="paramname">lifespan</td><td>the lifespan of this entry. A negative value is interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">lifespanUnit</td><td>TimeUnit for the lifespan param </td></tr>
    <tr><td class="paramname">maxIdle</td><td>the maximum amount of time this entry is allowed to be idle before it is considered as expired </td></tr>
    <tr><td class="paramname">maxIdleUnit</td><td>TimeUnit for the maxIdle param </td></tr>
    <tr><td class="paramname">success</td><td>function to be executed on success </td></tr>
    <tr><td class="paramname">fail</td><td>function to be executed if exceptions occur </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future containing a pointer to the previous value stored in the cache for the given key or null </dd></dl>

</div>
</div>
<a class="anchor" id="a3a05c79135f4737840c0cb2b268ac520"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V* <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::putIfAbsent </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>maxIdle</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Associates the specified value with the specified key in this cache if the specified key is not already associated with some value. In such case key is associated with the given value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td class="paramname">val</td><td>value value to be associated with the specified key </td></tr>
    <tr><td class="paramname">lifespan</td><td>the lifespan of this entry. A negative value is interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">maxIdle</td><td>the maximum amount of time this entry is allowed to be idle before it is considered as expired </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value associated with the specified key, or NULL if there was no mapping for the key. </dd></dl>

</div>
</div>
<a class="anchor" id="a481952f947f707ac38dbba5e8345c1fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V* <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::putIfAbsent </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>lifespanUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Associates the specified value with the specified key in this cache if the specified key is not already associated with some value. In such case key is associated with the given value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td class="paramname">val</td><td>value value to be associated with the specified key </td></tr>
    <tr><td class="paramname">lifespan</td><td>the lifespan of this entry. A negative value is interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">lifespanUnit</td><td>TimeUnit for the lifespan param </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value associated with the specified key, or NULL if there was no mapping for the key. </dd></dl>

</div>
</div>
<a class="anchor" id="a75ec23edf1ecbcef31ec73aaf670d63b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V* <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::putIfAbsent </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>lifespanUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>maxIdle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>maxIdleUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Associates the specified value with the specified key in this cache if the specified key is not already associated with some value. In such case key is associated with the given value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td class="paramname">val</td><td>value value to be associated with the specified key </td></tr>
    <tr><td class="paramname">lifespan</td><td>the lifespan of this entry. A negative value is interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">lifespanUnit</td><td>TimeUnit for the lifespan param </td></tr>
    <tr><td class="paramname">maxIdle</td><td>the maximum amount of time this entry is allowed to be idle before it is considered as expired </td></tr>
    <tr><td class="paramname">maxIdleUnit</td><td>TimeUnit for the maxIdle param </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value associated with the specified key, or NULL if there was no mapping for the key. </dd></dl>

</div>
</div>
<a class="anchor" id="abab3a1868d38e5be9db91a9157207a3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt;V*&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::putIfAbsentAsync </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>maxIdle</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(V *)&gt;&#160;</td>
          <td class="paramname"><em>success</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(std::exception &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fail</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronous version of <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#abab3a1868d38e5be9db91a9157207a3b">putIfAbsentAsync()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td class="paramname">val</td><td>value value to be associated with the specified key </td></tr>
    <tr><td class="paramname">lifespan</td><td>the lifespan of this entry. A negative value is interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">maxIdle</td><td>the maximum amount of time this entry is allowed to be idle before it is considered as expired </td></tr>
    <tr><td class="paramname">success</td><td>function to be executed on success </td></tr>
    <tr><td class="paramname">fail</td><td>function to be executed if exceptions occur </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future containing a pointer to the previous value stored in the cache for the given key or null </dd></dl>

</div>
</div>
<a class="anchor" id="a1bae2ae96a689a1d82543c115601ac65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt;V*&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::putIfAbsentAsync </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>lifespanUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(V *)&gt;&#160;</td>
          <td class="paramname"><em>success</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(std::exception &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fail</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronous version of <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#abab3a1868d38e5be9db91a9157207a3b">putIfAbsentAsync()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td class="paramname">val</td><td>value value to be associated with the specified key </td></tr>
    <tr><td class="paramname">lifespan</td><td>the lifespan of this entry. A negative value is interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">lifespanUnit</td><td>TimeUnit for the lifespan param </td></tr>
    <tr><td class="paramname">success</td><td>function to be executed on success </td></tr>
    <tr><td class="paramname">fail</td><td>function to be executed if exceptions occur </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future containing a pointer to the previous value stored in the cache for the given key or null </dd></dl>

</div>
</div>
<a class="anchor" id="a2b6776d217eafba5fcea7312f277e89b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt;V*&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::putIfAbsentAsync </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>lifespanUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>maxIdle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>maxIdleUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(V *)&gt;&#160;</td>
          <td class="paramname"><em>success</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(std::exception &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fail</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronous version of <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#abab3a1868d38e5be9db91a9157207a3b">putIfAbsentAsync()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td class="paramname">val</td><td>value value to be associated with the specified key </td></tr>
    <tr><td class="paramname">lifespan</td><td>the lifespan of this entry. A negative value is interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">lifespanUnit</td><td>TimeUnit for the lifespan param </td></tr>
    <tr><td class="paramname">maxIdle</td><td>the maximum amount of time this entry is allowed to be idle before it is considered as expired </td></tr>
    <tr><td class="paramname">maxIdleUnit</td><td>TimeUnit for the maxIdle param </td></tr>
    <tr><td class="paramname">success</td><td>function to be executed on success </td></tr>
    <tr><td class="paramname">fail</td><td>function to be executed if exceptions occur </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future containing a pointer to the previous value stored in the cache for the given key or null </dd></dl>

</div>
</div>
<a class="anchor" id="a434c60cac73f3d82a75b8a8aae4234d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QueryResponse <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::query </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classorg_1_1infinispan_1_1query_1_1remote_1_1client_1_1QueryRequest.html">QueryRequest</a> &amp;&#160;</td>
          <td class="paramname"><em>qr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Execute a query on server </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qr</td><td>the QueryRequest oject </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a QueryResponse object with the query result </dd></dl>

</div>
</div>
<a class="anchor" id="a1b9b8e24981493b5c7702c275cc9c355"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned char&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::query </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Execute a query on server </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qr</td><td>the query string </td></tr>
    <tr><td class="paramname">size</td><td>the length of the query string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte[] result in dark matter shape </dd></dl>

</div>
</div>
<a class="anchor" id="ad2e507ee49060d1fabd7c3ac6238f0d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V* <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes key/value pair from the cache given a key. Optionally return a value stored under the given key</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the of the entry to be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL or value stored under this key </dd></dl>

</div>
</div>
<a class="anchor" id="a32aca3ed89425119fdc474b8b3bf9fa4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt;V*&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::removeAsync </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(V *)&gt;&#160;</td>
          <td class="paramname"><em>success</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(std::exception &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fail</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronous version of <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a57985bda583ef7363c46b15982699f40">removeWithVersion()</a> See the synchronous doc for parameters not explained here </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the of the entry to be removed </td></tr>
    <tr><td class="paramname">success</td><td>function to be executed on success </td></tr>
    <tr><td class="paramname">fail</td><td>function to be executed if exceptions occur </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future containing a bool. True if the entry has been removed </dd></dl>

</div>
</div>
<a class="anchor" id="a05d253799622312ab77a4e2d0c4d7867"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::removeClientListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinfinispan_1_1hotrod_1_1event_1_1ClientListener.html">ClientListener</a> &amp;&#160;</td>
          <td class="paramname"><em>clientListener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stop and remove client listener</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clientListener</td><td>the listener to be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ac9fd345533ec44dd603f8ff860ef73ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<div class="memtemplate">
template&lt;typename... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::removeContinuousQueryListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinfinispan_1_1hotrod_1_1event_1_1ContinuousQueryListener.html">ContinuousQueryListener</a>&lt; Params...&gt; &amp;&#160;</td>
          <td class="paramname"><em>cql</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start a client listener on the specified query and register it on the server</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cql</td><td>object defining the query to be observed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57985bda583ef7363c46b15982699f40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::removeWithVersion </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes the given entry only if its version matches the supplied version.</p>
<p>A typical use case looks like this: </p>
<pre>
std::pair&lt;std::shared_ptr&lt;std::string&gt;, <a class="el" href="classinfinispan_1_1hotrod_1_1VersionedValue.html">VersionedValue</a>&gt; rv = remoteCache.getWithVersioned(key);
//some processing...
remoteCache.removeWithVersion(key, rv.second().version);
</pre><p> Last call (removeWithVersion) will make sure that the entry will only be removed if it hasn't been changed in the meantime.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key </td></tr>
    <tr><td class="paramname">version</td><td>version of entry to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entry has been removed </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classinfinispan_1_1hotrod_1_1VersionedValue.html">VersionedValue</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad937bd75bf386036fa954fedb1c7b752"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt;bool&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::removeWithVersionAsync </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(bool)&gt;&#160;</td>
          <td class="paramname"><em>success</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(std::exception &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fail</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronous version of <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#a57985bda583ef7363c46b15982699f40">removeWithVersion()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key </td></tr>
    <tr><td class="paramname">version</td><td>version of entry to remove </td></tr>
    <tr><td class="paramname">success</td><td>function to be executed on success </td></tr>
    <tr><td class="paramname">fail</td><td>function to be executed if exceptions occur </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future containing a bool. True if the entry has been removed </dd></dl>

</div>
</div>
<a class="anchor" id="afa7c62098b4d7f5b42531a010ab13692"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V* <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>maxIdle</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replaces the entry for a key with a given new value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td class="paramname">val</td><td>value to be associated with the specified key </td></tr>
    <tr><td class="paramname">lifespan</td><td>lifespan of the entry. Negative values are interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">maxIdle</td><td>the maximum amount of time this entry is allowed to be idle before it is considered as expired</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value associated with the specified key, or NULL if there was no mapping for the key. </dd></dl>

</div>
</div>
<a class="anchor" id="a06c5e9cb17d096f11127e1c710d09bbd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V* <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>lifespanUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replaces the entry for a key with a given new value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td class="paramname">val</td><td>value to be associated with the specified key </td></tr>
    <tr><td class="paramname">lifespan</td><td>lifespan of the entry. Negative values are interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">lifespanUnit</td><td>TimeUnit for the lifespan param</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value associated with the specified key, or NULL if there was no mapping for the key. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a66ff47ed1ea9ffcb5934708975d92f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V* <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>lifespanUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>maxIdle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>maxIdleUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replaces the entry for a key with a given new value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td class="paramname">val</td><td>value to be associated with the specified key </td></tr>
    <tr><td class="paramname">lifespan</td><td>lifespan of the entry. Negative values are interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">lifespanUnit</td><td>TimeUnit for the lifespan param </td></tr>
    <tr><td class="paramname">maxIdle</td><td>the maximum amount of time this entry is allowed to be idle before it is considered as expired </td></tr>
    <tr><td class="paramname">maxIdleUnit</td><td>TimeUnit for the maxIdle param</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value associated with the specified key, or NULL if there was no mapping for the key. </dd></dl>

</div>
</div>
<a class="anchor" id="a6212108a46b949b84c5a1a2b04be1a75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V* <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>oldVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>maxIdle</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replaces the entry for a key with a new value only if currently mapped to a given old value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td class="paramname">oldVal</td><td>value expected to be associated with the specified key </td></tr>
    <tr><td class="paramname">val</td><td>value to be associated with the specified key </td></tr>
    <tr><td class="paramname">lifespan</td><td>lifespan of the entry. Negative values are interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">maxIdle</td><td>the maximum amount of time this entry is allowed to be idle before it is considered as expired</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value associated with the specified key, or NULL if there was no mapping for the key. </dd></dl>

</div>
</div>
<a class="anchor" id="a574b7c33d4cdb7b9afc14ff0f3a14031"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V* <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>oldVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>lifespanUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replaces the entry for a key with a new value only if currently mapped to a given old value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td class="paramname">oldVal</td><td>value expected to be associated with the specified key </td></tr>
    <tr><td class="paramname">val</td><td>value to be associated with the specified key </td></tr>
    <tr><td class="paramname">lifespan</td><td>lifespan of the entry. Negative values are interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">lifespanUnit</td><td>TimeUnit for the lifespan param</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value associated with the specified key, or NULL if there was no mapping for the key. </dd></dl>

</div>
</div>
<a class="anchor" id="a71e36590898ab93468236de1bde9e6d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V* <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>oldVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>lifespanUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>maxIdle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>maxIdleUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replaces the entry for a key with a new value only if currently mapped to a given old value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td class="paramname">oldVal</td><td>value expected to be associated with the specified key </td></tr>
    <tr><td class="paramname">val</td><td>value to be associated with the specified key </td></tr>
    <tr><td class="paramname">lifespan</td><td>lifespan of the entry. Negative values are interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">lifespanUnit</td><td>TimeUnit for the lifespan param </td></tr>
    <tr><td class="paramname">maxIdle</td><td>the maximum amount of time this entry is allowed to be idle before it is considered as expired </td></tr>
    <tr><td class="paramname">maxIdleUnit</td><td>TimeUnit for the maxIdle param </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value associated with the specified key, or NULL if there was no mapping for the key. </dd></dl>

</div>
</div>
<a class="anchor" id="a421c4d5c3ccac25b92636238f1ffad24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt;V*&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::replaceAsync </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>maxIdle</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(V *)&gt;&#160;</td>
          <td class="paramname"><em>success</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(std::exception &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fail</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronous version of <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#afa7c62098b4d7f5b42531a010ab13692">replace()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td class="paramname">val</td><td>value to be associated with the specified key </td></tr>
    <tr><td class="paramname">lifespan</td><td>lifespan of the entry. Negative values are interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">maxIdle</td><td>the maximum amount of time this entry is allowed to be idle before it is considered as expired </td></tr>
    <tr><td class="paramname">success</td><td>function to be executed on success </td></tr>
    <tr><td class="paramname">fail</td><td>function to be executed if exceptions occur </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future containing a pointer to the previous value stored in the cache for the given key or null </dd></dl>

</div>
</div>
<a class="anchor" id="ad0a13a695c15c57e6d2b52b5859f3228"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt;V*&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::replaceAsync </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>lifespanUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(V *)&gt;&#160;</td>
          <td class="paramname"><em>success</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(std::exception &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fail</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronous version of <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#afa7c62098b4d7f5b42531a010ab13692">replace()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td class="paramname">val</td><td>value to be associated with the specified key </td></tr>
    <tr><td class="paramname">lifespan</td><td>lifespan of the entry. Negative values are interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">lifespanUnit</td><td>TimeUnit for the lifespan param </td></tr>
    <tr><td class="paramname">success</td><td>function to be executed on success </td></tr>
    <tr><td class="paramname">fail</td><td>function to be executed if exceptions occur </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future containing a pointer to the previous value stored in the cache for the given key or null </dd></dl>

</div>
</div>
<a class="anchor" id="acdf6b30ce09d4771330586da42b6e634"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt;V*&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::replaceAsync </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>lifespanUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>maxIdle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>maxIdleUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(V *)&gt;&#160;</td>
          <td class="paramname"><em>success</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(std::exception &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fail</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronous version of <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#afa7c62098b4d7f5b42531a010ab13692">replace()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td class="paramname">val</td><td>value to be associated with the specified key </td></tr>
    <tr><td class="paramname">lifespan</td><td>lifespan of the entry. Negative values are interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">lifespanUnit</td><td>TimeUnit for the lifespan param </td></tr>
    <tr><td class="paramname">maxIdle</td><td>the maximum amount of time this entry is allowed to be idle before it is considered as expired </td></tr>
    <tr><td class="paramname">maxIdleUnit</td><td>TimeUnit for the maxIdle param </td></tr>
    <tr><td class="paramname">success</td><td>function to be executed on success </td></tr>
    <tr><td class="paramname">fail</td><td>function to be executed if exceptions occur </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future containing a pointer to the previous value stored in the cache for the given key or null </dd></dl>

</div>
</div>
<a class="anchor" id="a6294e4e99bccf1691eb16441f583e9ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt;V*&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::replaceAsync </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>oldVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>maxIdle</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(V *)&gt;&#160;</td>
          <td class="paramname"><em>success</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(std::exception &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fail</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronous version of <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#afa7c62098b4d7f5b42531a010ab13692">replace()</a> See the synchronous doc for parameters not explained here </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td class="paramname">oldVal</td><td>value expected to be associated with the specified key </td></tr>
    <tr><td class="paramname">val</td><td>value to be associated with the specified key </td></tr>
    <tr><td class="paramname">lifespan</td><td>lifespan of the entry. Negative values are interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">maxIdle</td><td>the maximum amount of time this entry is allowed to be idle before it is considered as expired </td></tr>
    <tr><td class="paramname">success</td><td>function to be executed on success </td></tr>
    <tr><td class="paramname">fail</td><td>function to be executed if exceptions occur </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future containing a pointer to the previous value stored in the cache for the given key or null </dd></dl>

</div>
</div>
<a class="anchor" id="af95ac1cf008ddca21c81c09dc8ee2813"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt;V*&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::replaceAsync </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>oldVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#ae229ad5f1bb2b8451e95d3e9a1776fe4">TimeUnit</a>&#160;</td>
          <td class="paramname"><em>lifespanUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(V *)&gt;&#160;</td>
          <td class="paramname"><em>success</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; V *(std::exception &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fail</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronous version of <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#afa7c62098b4d7f5b42531a010ab13692">replace()</a> See the synchronous doc for parameters not explained here </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td class="paramname">oldVal</td><td>value expected to be associated with the specified key </td></tr>
    <tr><td class="paramname">val</td><td>value to be associated with the specified key </td></tr>
    <tr><td class="paramname">lifespan</td><td>lifespan of the entry. Negative values are interpreted as unlimited lifespan </td></tr>
    <tr><td class="paramname">lifespanUnit</td><td>TimeUnit for the lifespan param </td></tr>
    <tr><td class="paramname">success</td><td>function to be executed on success </td></tr>
    <tr><td class="paramname">fail</td><td>function to be executed if exceptions occur </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future containing a pointer to the previous value stored in the cache for the given key or null </dd></dl>

</div>
</div>
<a class="anchor" id="afa97af7e1eaf33cb3f32cfc56cfb009f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::replaceWithVersion </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>maxIdle</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replaces the given value only if its version matches the supplied version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key </td></tr>
    <tr><td class="paramname">val</td><td>the new value for the given key </td></tr>
    <tr><td class="paramname">version</td><td>numeric version that should match the one in the server for the operation to succeed </td></tr>
    <tr><td class="paramname">lifespan</td><td>the new lifespan for this key/value entry pair </td></tr>
    <tr><td class="paramname">maxIdle</td><td>the maximum amount of time this entry is allowed to be idle before it is considered as expired </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value has been replaced</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classinfinispan_1_1hotrod_1_1VersionedValue.html">VersionedValue</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a76e2b03a691e417e79ad921923b02bd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt;bool&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::replaceWithVersionAsync </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lifespan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>maxIdle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(bool)&gt;&#160;</td>
          <td class="paramname"><em>success</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(std::exception &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fail</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronous version of <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html#afa97af7e1eaf33cb3f32cfc56cfb009f">replaceWithVersion()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key </td></tr>
    <tr><td class="paramname">val</td><td>the new value for the given key </td></tr>
    <tr><td class="paramname">version</td><td>numeric version that should match the one in the server for the operation to succeed </td></tr>
    <tr><td class="paramname">lifespan</td><td>the new lifespan for this key/value entry pair </td></tr>
    <tr><td class="paramname">maxIdle</td><td>the maximum amount of time this entry is allowed to be idle before it is considered as expired </td></tr>
    <tr><td class="paramname">success</td><td>function to be executed on success </td></tr>
    <tr><td class="paramname">fail</td><td>function to be executed if exceptions occur </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future containing a pointer to the previous value stored in the cache for the given key or null </dd></dl>

</div>
</div>
<a class="anchor" id="a77b266e88a0ec6021dfe95a75b65804c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an approximate number of key/value pairs in this cache.</p>
<dl class="section return"><dt>Returns</dt><dd>number of entries in cache </dd></dl>

</div>
</div>
<a class="anchor" id="a74ccb45d732f94e461835a0c1a8efba8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::string&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::stats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns statistics for this cache.</p>
<dl class="section return"><dt>Returns</dt><dd>a std::map of string key/value pairs where each key is a certain statistic property while the matching value represents the value for that property </dd></dl>

</div>
</div>
<a class="anchor" id="a8b53d237dc4f500d320678a74b3ea967"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;V&gt; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsupported operation in this release of Hot Rod client. <a class="el" href="structinfinispan_1_1hotrod_1_1UnsupportedOperationException.html">UnsupportedOperationException</a> is thrown if his method is invoked. </p>

</div>
</div>
<a class="anchor" id="aa5e311f6f8744cad478ff9ab3fce15a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">RemoteCache</a>&lt;K, V&gt;&amp; <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">infinispan::hotrod::RemoteCache</a>&lt; K, V &gt;::withFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceinfinispan_1_1hotrod.html#a28ac91e3e8787e94b91bb12aa824a95a">Flag</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies one or more Flag enums to the scope of a single invocation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>the flags to apply to an invocation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCache.html">RemoteCache</a> instance </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a12e3f9cc9c40b896d316366b5a26c23f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classinfinispan_1_1hotrod_1_1RemoteCacheManager.html">RemoteCacheManager</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/infinispan/workspace/CppRelease/8.2.1.Final/include/infinispan/hotrod/<a class="el" href="CacheClientListener_8h_source.html">CacheClientListener.h</a></li>
<li>/home/infinispan/workspace/CppRelease/8.2.1.Final/include/infinispan/hotrod/<a class="el" href="RemoteCache_8h_source.html">RemoteCache.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
