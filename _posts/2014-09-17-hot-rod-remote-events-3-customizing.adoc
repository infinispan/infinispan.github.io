---
layout: blog
title: 'Hot Rod Remote Events #3: Customizing events'
permalink: /blog/:year/:month/:day/hot-rod-remote-events-3-customizing
date: '2014-09-17T04:30:00.005-07:00'
author: galder
tags: [ " hotrod", "event", "remote events" ]
blogger_id: tag:blogger.com,1999:blog-5717179571414330874.post-4329307644857210827
blogger_orig_url: https://blog.infinispan.org/2014/09/hot-rod-remote-events-3-customizing.html
---
This blog post is the third in a series that looks at the forthcoming
Hot Rod Remote Events functionality included in Infinispan 7.0. In the
http://blog.infinispan.org/2014/08/hot-rod-remote-events-1-getting-started.html[first
article] we looked at how to get started receiving remote events from
Hot Rod servers. In the
http://blog.infinispan.org/2014/08/hot-rod-remote-events-2-filtering-events.html[second
article], we saw how Hot Rod remote events can be filtered providing
key/value filter factories that can create instances that filter which
events are sent to clients, and how these filters can act on client
provided information.



This time we are going to focus on how to customize events sent to
clients. Events generated by default contain just enough information to
make the event relevant but avoid cramming too much information in order
to reduce the cost of sending them. Normally, this information consists
of key and type of event.



Optionally, the information shipped in these events can be customized in
order to contain more information, such as values, or to contain even
less information. This customization is done
with org.infinispan.notifications.cachelistener.filter.CacheEventConverter
instances which are created by implementing
a org.infinispan.notifications.cachelistener.filter.CacheEventConverterFactory class.
Each factory must have a name associated to it via the
org.infinispan.filter.NamedFactory annotation.



When a listener is added, we can provide the name of a converter factory
to use with this listener, and when the listener is added, the server
will look up the factory and invoke getConverter method to get
a org.infinispan.notifications.cachelistener.filter.CacheEventConverter class
instance to customize events server side.



Here's a sample implementation which will send custom events containing
value information back to clients for a cache of Integers and Strings:


In the example above, the converter generates a new custom event which
includes the value as well as the key in the event. This will result in
bigger event payloads compared with default events, but if combined with
filtering, it can reduce its network bandwidth cost.

In another converter implementation, the user could decide to send back
an event that contains no key or event type information. This would
result in extremely lightweight events at the expense of richness of
information provided by the event itself.

Plugging the server with this converter requires deploying this
converter factory (and associated converter class) within a jar file
including a service definition inside the
META-INF/services/org.infinispan.notifications.cachelistener.filter.CacheEventConverterFactory file:



With the server plugged with the converter, the next step is adding a
remote client listener that will use this converter. How to implement a
listener for custom events is slightly different to the listeners we've
seen in the last couple of blog posts because we know have to deal with
customised events as opposed to the default ones. To do so, the same
annotations are used as previous blog posts, but the callbacks receive
instances
of org.infinispan.client.hotrod.event.ClientCacheEntryCustomEvent<T>,
where T is the type of custom event we are sending from the server:


Now it's time to write a simple main java class which adds the remote
event listener and executes some operations against the remote cache:


Once executed, we should see a console console output similar to this:


Similar to events, converters can also act on client provided
information, enabling converter instances to customize events depending
on the information given when the listener was added. The API provides
an extra parameter to pass in converter parameters when the listener is
added. Given the similarities with filtering, this part is not covered
by this blog post.

A final note on the marshalling aspects of this example. In order to
facilitate both server and client writing against type safe APIs, both
the client and server need to be aware of custom event type and be able
to marshall it. Client side, this is done by an optional marshaller
configurable via the RemoteCacheManager. Server side, this is done by a
marshaller recently added to the Hot Rod server configuration.

In the next blog post in the Hot Rod remote events series, we will look
at how to receive remote events in a clustered environment, how to deal
with failover situations...etc.

Cheers,
Galder

