<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.16">
<title>Developing for Infinispan 14.0</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;-webkit-tap-highlight-color:transparent}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="canonical" href="https://infinispan.org/docs/stable/index.html">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.1/themes/default/style.min.css">
<link rel="stylesheet" href="../../css/css.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.1/jstree.min.js"></script>
<script src="../../js/js.js"></script>
<style>
.hidden {
    display: none;
}

.switch {
    border-width: 1px 1px 0 1px;
    border-style: solid;
    border-color: #7a2518;
    display: inline-block;
}

.switch--item {
    padding: 10px;
    background-color: #ffffff;
    color: #7a2518;
    display: inline-block;
    cursor: pointer;
}

.switch--item.selected {
    background-color: #7a2519;
    color: #ffffff;
}

</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
    $('.primary').each(function() {
        primary = $(this);
        createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
        primary.children('.title').remove();
    });
    $('.secondary').each(function(idx, node) {
        secondary = $(node);
        primary = findPrimary(secondary);
        switchItem = createSwitchItem(secondary, primary.children('.switch'));
        switchItem.content.addClass('hidden');
        findPrimary(secondary).append(switchItem.content);
        secondary.remove();
    });
}

function createBlockSwitch(primary) {
    blockSwitch = $('<div class="switch"></div>');
    primary.prepend(blockSwitch);
    return blockSwitch;
}

function findPrimary(secondary) {
    candidate = secondary.prev();
    while (!candidate.is('.primary')) {
        candidate = candidate.prev();
    }
    return candidate;
}

function createSwitchItem(block, blockSwitch) {
    blockName = block.children('.title').text();
    content = block.children('.content').first().append(block.next('.colist'));
    item = $('<div class="switch--item">' + blockName + '</div>');
    item.on('click', '', content, function(e) {
        $(this).addClass('selected');
        $(this).siblings().removeClass('selected');
        e.data.siblings('.content').addClass('hidden');
        e.data.removeClass('hidden');
    });
    blockSwitch.append(item);
    return {'item': item, 'content': content};
}

$(addBlockSwitches);

</script>

</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Developing for Infinispan 14.0</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#configuring-maven-repository">1. Configuring the Infinispan Maven repository</a>
<ul class="sectlevel2">
<li><a href="#configuring-pom-xml_configuring-maven-repository">1.1. Configuring your Infinispan POM</a></li>
</ul>
</li>
<li><a href="#cache_manager">2. Cache Managers</a>
<ul class="sectlevel2">
<li><a href="#obtaining_caches">2.1. Obtaining caches</a></li>
<li><a href="#clustering_information">2.2. Clustering Information</a></li>
<li><a href="#member_information">2.3. Member Information</a></li>
</ul>
</li>
<li><a href="#cache_api">3. Cache Interface</a>
<ul class="sectlevel2">
<li><a href="#cache_api_2">3.1. Cache API</a>
<ul class="sectlevel3">
<li><a href="#performance_concerns_of_certain_map_methods">3.1.1. Performance Concerns of Certain Map Methods</a></li>
<li><a href="#mortal_and_immortal_data">3.1.2. Mortal and Immortal Data</a></li>
<li><a href="#putforexternalread_operation">3.1.3. putForExternalRead operation</a></li>
</ul>
</li>
<li><a href="#advancedcache_api">3.2. AdvancedCache API</a>
<ul class="sectlevel3">
<li><a href="#flags">3.2.1. Flags</a></li>
</ul>
</li>
<li><a href="#listeners_and_notifications">3.3. Listeners and Notifications</a>
<ul class="sectlevel3">
<li><a href="#cache_level_notifications">3.3.1. Cache-level notifications</a>
<ul class="sectlevel4">
<li><a href="#cluster_listeners">Cluster Listeners</a></li>
<li><a href="#event_filtering_and_conversion">Event filtering and conversion</a></li>
<li><a href="#initial_state_events">Initial State Events</a></li>
<li><a href="#duplicate_events">Duplicate Events</a></li>
</ul>
</li>
<li><a href="#cache_manager_level_notifications">3.3.2. Cache manager-level notifications</a></li>
<li><a href="#synchronicity_of_events">3.3.3. Synchronicity of events</a>
<ul class="sectlevel4">
<li><a href="#asynchronous_thread_pool">Asynchronous thread pool</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#cache_asynchronous_api">3.4. Asynchronous API</a>
<ul class="sectlevel3">
<li><a href="#why_use_such_an_api">3.4.1. Why use such an API?</a></li>
<li><a href="#which_processes_actually_happen_asynchronously">3.4.2. Which processes actually happen asynchronously?</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#clustered_locks">4. Clustered Locks</a>
<ul class="sectlevel2">
<li><a href="#lock_api-locking">4.1. Lock API</a></li>
<li><a href="#using_clustered_locks-locking">4.2. Using Clustered Locks</a></li>
<li><a href="#configuring_clustered_locks-locking">4.3. Configuring Internal Caches for Locks</a></li>
</ul>
</li>
<li><a href="#clustered_counters">5. Clustered Counters</a>
<ul class="sectlevel2">
<li><a href="#installation_and_configuration">5.1. Installation and Configuration</a>
<ul class="sectlevel3">
<li><a href="#list_counter_names">5.1.1. List counter names</a></li>
</ul>
</li>
<li><a href="#countermanager_interface">5.2. <code>CounterManager</code> interface</a>
<ul class="sectlevel3">
<li><a href="#remove_a_counter_via_countermanager">5.2.1. Remove a counter via CounterManager</a></li>
</ul>
</li>
<li><a href="#the_counter">5.3. The Counter</a>
<ul class="sectlevel3">
<li><a href="#the_strongcounter_interface_when_the_consistency_or_bounds_matters">5.3.1. The <code>StrongCounter</code> interface: when the consistency or bounds matters.</a>
<ul class="sectlevel4">
<li><a href="#bounded_strongcounter">Bounded <code>StrongCounter</code></a></li>
<li><a href="#uses_cases">Uses cases</a></li>
<li><a href="#usage_examples">Usage Examples</a></li>
</ul>
</li>
<li><a href="#the_weakcounter_interface_when_speed_is_needed">5.3.2. The <code>WeakCounter</code> interface: when speed is needed</a>
<ul class="sectlevel4">
<li><a href="#weak_counter_interface">Weak Counter Interface</a></li>
<li><a href="#uses_cases_2">Uses cases</a></li>
<li><a href="#examples">Examples</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#clustered_counters_notify_events">5.4. Notifications and Events</a></li>
</ul>
</li>
<li><a href="#cdi_support">6. Using the CDI Extension</a>
<ul class="sectlevel2">
<li><a href="#cdi_dependencies">6.1. CDI Dependencies</a></li>
<li><a href="#cdi_inject_embed">6.2. Injecting Embedded Caches</a></li>
<li><a href="#cdi_inject_remote">6.3. Injecting Remote Caches</a></li>
<li><a href="#jcache_annotations">6.4. JCache Caching Annotations</a></li>
<li><a href="#cache_events">6.5. Receiving Cache and Cache Manager Events</a></li>
</ul>
</li>
<li><a href="#locking_concurrency">7. Locking and Concurrency</a>
<ul class="sectlevel2">
<li><a href="#locking_implementation_details">7.1. Locking implementation details</a>
<ul class="sectlevel3">
<li><a href="#clustered_caches_and_locks">7.1.1. Clustered caches and locks</a></li>
<li><a href="#the_lockmanager">7.1.2. The LockManager</a></li>
<li><a href="#lock_striping">7.1.3. Lock striping</a></li>
<li><a href="#concurrency_levels">7.1.4. Concurrency levels</a></li>
<li><a href="#lock_timeout">7.1.5. Lock timeout</a></li>
<li><a href="#consistency">7.1.6. Consistency</a></li>
</ul>
</li>
<li><a href="#data_versioning">7.2. Data Versioning</a></li>
</ul>
</li>
<li><a href="#transaction_manager">8. Transactions</a>
<ul class="sectlevel2">
<li><a href="#tx_configuration">8.1. Configuring transactions</a></li>
<li><a href="#tx_isolation_levels">8.2. Isolation levels</a></li>
<li><a href="#tx_locking">8.3. Transaction locking</a>
<ul class="sectlevel3">
<li><a href="#pessimistic_transactional_cache">8.3.1. Pessimistic transactional cache</a></li>
<li><a href="#optimistic_transactional_cache">8.3.2. Optimistic transactional cache</a></li>
<li><a href="#what_do_i_need_pessimistic_or_optimistic_transactions">8.3.3. What do I need - pessimistic or optimistic transactions?</a></li>
</ul>
</li>
<li><a href="#tx_write_skew">8.4. Write Skews</a>
<ul class="sectlevel3">
<li><a href="#forcing_write_locks_on_keys_in_pessimitic_transactions">8.4.1. Forcing write locks on keys in pessimitic transactions</a></li>
</ul>
</li>
<li><a href="#dealing_with_exceptions">8.5. Dealing with exceptions</a></li>
<li><a href="#tx_sync_enlist">8.6. Enlisting Synchronizations</a></li>
<li><a href="#tx_batching">8.7. Batching</a>
<ul class="sectlevel3">
<li><a href="#api">8.7.1. API</a></li>
<li><a href="#batching_and_jta">8.7.2. Batching and JTA</a></li>
</ul>
</li>
<li><a href="#tx_recovery">8.8. Transaction recovery</a>
<ul class="sectlevel3">
<li><a href="#when_to_use_recovery">8.8.1. When to use recovery</a></li>
<li><a href="#how_does_it_work">8.8.2. How does it work</a></li>
<li><a href="#configuring_recovery">8.8.3. Configuring recovery   </a>
<ul class="sectlevel4">
<li><a href="#enable_jmx_support">Enable JMX support</a></li>
</ul>
</li>
<li><a href="#recovery_cache">8.8.4. Recovery cache</a></li>
<li><a href="#integration_with_the_transaction_manager">8.8.5. Integration with the transaction manager</a></li>
<li><a href="#tx_recovery_reconciliation">8.8.6. Reconciliation</a>
<ul class="sectlevel4">
<li><a href="#force_commitrollback_based_on_xid">Force commit/rollback based on XID</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#functional_map_api">9. Functional Map API</a>
<ul class="sectlevel2">
<li><a href="#asynchronous_and_lazy">9.1. Asynchronous and Lazy</a></li>
<li><a href="#function_transparency">9.2. Function transparency</a></li>
<li><a href="#constructing_functional_maps">9.3. Constructing Functional Maps</a></li>
<li><a href="#read_only_map_api">9.4. Read-Only Map API</a>
<ul class="sectlevel3">
<li><a href="#read_only_entry_view">9.4.1. Read-Only Entry View</a></li>
</ul>
</li>
<li><a href="#write_only_map_api">9.5. Write-Only Map API</a>
<ul class="sectlevel3">
<li><a href="#write_only_entry_view">9.5.1. Write-Only Entry View</a></li>
</ul>
</li>
<li><a href="#read_write_map_api">9.6. Read-Write Map API</a>
<ul class="sectlevel3">
<li><a href="#read_write_entry_view">9.6.1. Read-Write Entry View</a></li>
</ul>
</li>
<li><a href="#meta_parameter">9.7. Metadata Parameter Handling</a></li>
<li><a href="#_invocation_parameter">9.8. Invocation Parameter</a></li>
<li><a href="#functional_listeners">9.9. Functional Listeners</a>
<ul class="sectlevel3">
<li><a href="#write_listeners">9.9.1. Write Listeners</a></li>
<li><a href="#read_write_listeners">9.9.2. Read-Write Listeners</a></li>
</ul>
</li>
<li><a href="#marshalling_of_functions">9.10. Marshalling of Functions</a></li>
<li><a href="#use_cases_for_functional_api">9.11. Use Cases for Functional API</a></li>
</ul>
</li>
<li><a href="#execute_code_grid">10. Executing Code in the Grid</a>
<ul class="sectlevel2">
<li><a href="#cluster_executor">10.1. Cluster Executor</a>
<ul class="sectlevel3">
<li><a href="#filtering_execution_nodes">10.1.1. Filtering execution nodes</a></li>
<li><a href="#timeout">10.1.2. Timeout</a></li>
<li><a href="#single_node_submission">10.1.3. Single Node Submission</a>
<ul class="sectlevel4">
<li><a href="#failover">Failover</a></li>
</ul>
</li>
<li><a href="#example_pi_approximation">10.1.4. Example: PI Approximation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#streams">11. Streams</a>
<ul class="sectlevel2">
<li><a href="#common_stream_operations">11.1. Common stream operations</a></li>
<li><a href="#key_filtering">11.2. Key filtering</a></li>
<li><a href="#segment_based_filtering">11.3. Segment based filtering</a></li>
<li><a href="#localinvalidation">11.4. Local/Invalidation</a></li>
<li><a href="#example">11.5. Example</a></li>
<li><a href="#distributionreplicationscattered">11.6. Distribution/Replication/Scattered</a>
<ul class="sectlevel3">
<li><a href="#rehash_aware">11.6.1. Rehash Aware</a></li>
<li><a href="#serialization">11.6.2. Serialization</a></li>
</ul>
</li>
<li><a href="#parallel_computation">11.7. Parallel Computation</a></li>
<li><a href="#task_timeout">11.8. Task timeout</a></li>
<li><a href="#injection">11.9. Injection</a></li>
<li><a href="#distributed_stream_execution">11.10. Distributed Stream execution</a></li>
<li><a href="#key_based_rehash_aware_operators">11.11. Key based rehash aware operators</a></li>
<li><a href="#intermediate_operation_exceptions">11.12. Intermediate operation exceptions</a></li>
<li><a href="#examples_2">11.13. Examples</a></li>
</ul>
</li>
<li><a href="#jcache_jsr_107">12. JCache (JSR-107) API</a>
<ul class="sectlevel2">
<li><a href="#creating_embedded_caches">12.1. Creating embedded caches</a>
<ul class="sectlevel3">
<li><a href="#configuring_embedded_caches">12.1.1. Configuring embedded caches</a></li>
</ul>
</li>
<li><a href="#creating_remote_caches">12.2. Creating remote caches</a>
<ul class="sectlevel3">
<li><a href="#configuring_remote_caches">12.2.1. Configuring remote caches</a></li>
</ul>
</li>
<li><a href="#store_and_retrieve_data">12.3. Store and retrieve data</a></li>
<li><a href="#comparing_java_util_concurrent_concurrentmap_and_javax_cache_cache_apis">12.4. Comparing java.util.concurrent.ConcurrentMap and javax.cache.Cache APIs</a></li>
<li><a href="#clustering_jcache_instances">12.5. Clustering JCache instances</a></li>
</ul>
</li>
<li><a href="#multimap_cache">13. Multimap Cache</a>
<ul class="sectlevel2">
<li><a href="#installation_and_configuration_2">13.1. Installation and configuration</a></li>
<li><a href="#multimapcache_api">13.2. MultimapCache API</a></li>
<li><a href="#creating_a_multimap_cache">13.3. Creating a Multimap Cache</a>
<ul class="sectlevel3">
<li><a href="#embedded_mode">13.3.1. Embedded mode</a></li>
</ul>
</li>
<li><a href="#multimap_limitations">13.4. Limitations</a>
<ul class="sectlevel3">
<li><a href="#support_for_duplicates">13.4.1. Support for duplicates</a></li>
<li><a href="#eviction">13.4.2. Eviction</a></li>
<li><a href="#transactions">13.4.3. Transactions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#anchored_keys_module">14. Anchored Keys module</a>
<ul class="sectlevel2">
<li><a href="#background">14.1. Background</a></li>
<li><a href="#architecture">14.2. Architecture</a></li>
<li><a href="#limitations">14.3. Limitations</a></li>
<li><a href="#configuration">14.4. Configuration</a></li>
<li><a href="#implementation_status">14.5. Implementation status</a>
<ul class="sectlevel3">
<li><a href="#functional_commands">14.5.1. Functional commands</a></li>
<li><a href="#partition_handling">14.5.2. Partition handling</a></li>
<li><a href="#listeners">14.5.3. Listeners</a></li>
</ul>
</li>
<li><a href="#performance_considerations">14.6. Performance considerations</a>
<ul class="sectlevel3">
<li><a href="#clientserver_latency">14.6.1. Client/Server Latency</a></li>
<li><a href="#memory_overhead">14.6.2. Memory overhead</a></li>
<li><a href="#state_transfer">14.6.3. State transfer</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#cloudevents_integration_module">15. CloudEvents Integration Module (Experimental)</a>
<ul class="sectlevel2">
<li><a href="#configuration_2">15.1. Configuration</a></li>
<li><a href="#event_format">15.2. Event Format</a></li>
</ul>
</li>
<li><a href="#ispn_modules">16. Infinispan Modules for WildFly</a>
<ul class="sectlevel2">
<li><a href="#install_ispn_modules">16.1. Installing Infinispan Modules</a></li>
<li><a href="#configure_ispn_modules">16.2. Configuring Applications to Use Infinispan Modules</a></li>
</ul>
</li>
<li><a href="#custom_interceptors_chapter">17. Custom Interceptors</a>
<ul class="sectlevel2">
<li><a href="#adding_custom_interceptors_declaratively">17.1. Adding custom interceptors declaratively</a></li>
<li><a href="#adding_custom_interceptors_programmatically">17.2. Adding custom interceptors programmatically</a></li>
<li><a href="#custom_interceptor_design">17.3. Custom interceptor design</a></li>
</ul>
</li>
<li><a href="#extending">18. Extending Infinispan</a>
<ul class="sectlevel2">
<li><a href="#custom_commands">18.1. Custom Commands</a>
<ul class="sectlevel3">
<li><a href="#an_example">18.1.1. An Example</a></li>
<li><a href="#preassigned_custom_command_id_ranges">18.1.2. Preassigned Custom Command Id Ranges</a></li>
</ul>
</li>
<li><a href="#extending_the_configuration_builders_and_parsers">18.2. Extending the configuration builders and parsers</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="configuring-maven-repository"><a class="anchor" href="#configuring-maven-repository"></a>1. Configuring the Infinispan Maven repository</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Infinispan Java distributions are available from Maven.</p>
</div>
<div class="paragraph">
<p>Infinispan artifacts are available from Maven central. See the <a href="https://search.maven.org/search?q=g:org.infinispan">org.infinispan</a> group for available Infinispan artifacts.</p>
</div>
<div class="sect2">
<h3 id="configuring-pom-xml_configuring-maven-repository"><a class="anchor" href="#configuring-pom-xml_configuring-maven-repository"></a>1.1. Configuring your Infinispan POM</h3>
<div class="paragraph">
<p>Maven uses configuration files called Project Object Model (POM) files to
define projects and manage builds. POM files are in XML format and describe the
module and component dependencies, build order, and targets for the resulting
project packaging and output.</p>
</div>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Open your project <code>pom.xml</code> for editing.</p>
</li>
<li>
<p>Define the <code>version.infinispan</code> property with the correct Infinispan version.</p>
</li>
<li>
<p>Include the <code>infinispan-bom</code> in a <code>dependencyManagement</code> section.</p>
<div class="paragraph">
<p>The Bill Of Materials (BOM) controls dependency versions, which avoids version
conflicts and means you do not need to set the version for each Infinispan
artifact you add as a dependency to your project.</p>
</div>
</li>
<li>
<p>Save and close <code>pom.xml</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following example shows the Infinispan version and BOM:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-xml" data-lang="xml">&lt;properties&gt;
  &lt;version.infinispan&gt;14.0.0.Dev01&lt;/version.infinispan&gt;
&lt;/properties&gt;

&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.infinispan&lt;/groupId&gt;
      &lt;artifactId&gt;infinispan-bom&lt;/artifactId&gt;
      &lt;version&gt;${version.infinispan}&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">Next Steps</div>
<p>Add Infinispan artifacts as dependencies to your <code>pom.xml</code> as required.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cache_manager"><a class="anchor" href="#cache_manager"></a>2. Cache Managers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The main entry point to Infinispan is the <code>CacheManager</code> interface that lets you:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Configure and obtain caches.</p>
</li>
<li>
<p>Manage and monitor clustered Infinispan nodes.</p>
</li>
<li>
<p>Execute code across your cluster.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you embed Infinispan in your application, then you use an
<code>EmbeddedCacheManager</code>. If you run Infinispan as a remote server, then you use
a <code>RemoteCacheManager</code>.</p>
</div>
<div class="paragraph">
<p>Cache Managers are heavyweight objects so you should instantiate only one
<code>CacheManager</code> instance per JVM in most cases.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">EmbeddedCacheManager manager = new DefaultCacheManager(); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Starts a local, non-clustered, Cache Manager with no caches.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Cache Managers have lifecycles and the default constructors also call the
<code>start()</code> method. Overloaded versions of the constructors are available, but
they do not start the <code>CacheManager</code>. However, you must always start the
<code>CacheManager</code> before you can create caches.</p>
</div>
<div class="paragraph">
<p>Likewise, you must call <code>stop()</code> when you no longer require a running
<code>CacheManager</code> so that it releases resources. This also ensures that the Cache
Manager safely stops any caches that it controls.</p>
</div>
<div class="sect2">
<h3 id="obtaining_caches"><a class="anchor" href="#obtaining_caches"></a>2.1. Obtaining caches</h3>
<div class="paragraph">
<p>After you configure the <code>CacheManager</code>, you can obtain and control caches.</p>
</div>
<div class="paragraph">
<p>Invoke the <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/manager/EmbeddedCacheManager.html#getCache(java.lang.String)"><code>getCache(String)</code></a> method to obtain caches, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-java" data-lang="java">Cache&lt;String, String&gt; myCache = manager.getCache("myCache");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding operation creates a cache named <code>myCache</code>, if it does not already exist, and returns it.</p>
</div>
<div class="paragraph">
<p>Using the <code>getCache()</code> method creates the cache only on the node where you invoke the method. In other words, it performs a local operation that must be invoked on each node across the cluster. Typically, applications deployed across multiple nodes obtain caches during initialization to ensure that caches are <em>symmetric</em> and exist on each node.</p>
</div>
<div class="paragraph">
<p>Invoke the <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/manager/EmbeddedCacheManagerAdmin.html#createCache(java.lang.String,java.lang.String)"><code>createCache()</code></a> method to create caches dynamically across the entire cluster, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Cache&lt;String, String&gt; myCache = manager.administration().createCache("myCache", "myTemplate");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding operation also automatically creates caches on any nodes that subsequently join the cluster.</p>
</div>
<div class="paragraph">
<p>Caches that you create with the <code>createCache()</code> method are ephemeral by default. If the entire cluster shuts down, the cache is not automatically created again when it restarts.</p>
</div>
<div class="paragraph">
<p>Use the PERMANENT flag to ensure that caches can survive restarts, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-java" data-lang="java">Cache&lt;String, String&gt; myCache = manager.administration().withFlags(AdminFlag.PERMANENT).createCache("myCache", "myTemplate");</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the PERMANENT flag to take effect, you must enable global state and set a configuration storage provider.</p>
</div>
<div class="paragraph">
<p>For more information about configuration storage providers, see <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/configuration/global/GlobalStateConfigurationBuilder.html#configurationStorage(org.infinispan.globalstate.ConfigurationStorage)">GlobalStateConfigurationBuilder#configurationStorage()</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="clustering_information"><a class="anchor" href="#clustering_information"></a>2.2. Clustering Information</h3>
<div class="paragraph">
<p>The <code>EmbeddedCacheManager</code> has quite a few methods to provide information
as to how the cluster is operating.  The following methods only really make
sense when being used in a clustered environment (that is when a Transport
is configured).</p>
</div>
</div>
<div class="sect2">
<h3 id="member_information"><a class="anchor" href="#member_information"></a>2.3. Member Information</h3>
<div class="paragraph">
<p>When you are using a cluster it is very important to be able to find information
about membership in the cluster including who is the owner of the cluster.</p>
</div>
<div class="paragraph">
<div class="title"><a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/manager/EmbeddedCacheManager.html#getMembers()">getMembers()</a></div>
<p>The getMembers() method returns all of the nodes in the current cluster.</p>
</div>
<div class="paragraph">
<div class="title"><a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/manager/EmbeddedCacheManager.html#getCoordinator()">getCoordinator()</a></div>
<p>The getCoordinator() method will tell you which one of the members is the coordinator
of the cluster.  For most intents you shouldn&#8217;t need to care who the coordinator is.
You can use <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/manager/EmbeddedCacheManager.html#isCoordinator()">isCoordinator()</a>
method directly to see if the local node is the coordinator as well.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cache_api"><a class="anchor" href="#cache_api"></a>3. Cache Interface</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Infinispan provides a <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/Cache.html">Cache</a> interface that exposes simple methods for adding, retrieving and removing entries, including atomic mechanisms exposed by the JDK&#8217;s ConcurrentMap interface.  Based on the cache mode used, invoking these methods will trigger a number of things to happen, potentially even including replicating an entry to a remote node or looking up an entry from a remote node, or potentially a cache store.</p>
</div>
<div class="sect2">
<h3 id="cache_api_2"><a class="anchor" href="#cache_api_2"></a>3.1. Cache API</h3>
<div class="paragraph">
<p>For simple usage, using the Cache API should be no different from using the JDK Map API, and hence migrating from simple in-memory caches based on a Map to Infinispan&#8217;s Cache should be trivial.</p>
</div>
<div class="sect3">
<h4 id="performance_concerns_of_certain_map_methods"><a class="anchor" href="#performance_concerns_of_certain_map_methods"></a>3.1.1. Performance Concerns of Certain Map Methods</h4>
<div class="paragraph">
<p>Certain methods exposed in Map have certain performance consequences when used with Infinispan, such as
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/Cache.html#size()">size()</a> ,
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/Cache.html#values()">values()</a> ,
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/Cache.html#keySet()">keySet()</a> and
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/Cache.html#entrySet()">entrySet()</a> .
Specific methods on the <code>keySet</code>, <code>values</code> and <code>entrySet</code> are fine for use please see their Javadoc for further details.</p>
</div>
<div class="paragraph">
<p>Attempting to perform these operations globally would have large performance impact as well as become a scalability bottleneck.  As such, these methods should only be used for informational or debugging purposes only.</p>
</div>
<div class="paragraph">
<p>It should be noted that using certain flags with the <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/AdvancedCache.html#withFlags(java.util.Collection)">withFlags()</a> method can mitigate some of these concerns, please check each method&#8217;s documentation for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="mortal_and_immortal_data"><a class="anchor" href="#mortal_and_immortal_data"></a>3.1.2. Mortal and Immortal Data</h4>
<div class="paragraph">
<p>Further to simply storing entries, Infinispan&#8217;s cache API allows you to attach mortality information to data.  For example, simply using <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#put-K-V-">put(key, value)</a> would create an <em>immortal</em> entry, i.e., an entry that lives in the cache forever, until it is removed (or evicted from memory to prevent running out of memory).  If, however, you put data in the cache using <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/commons/api/BasicCache.html#put(K,V,long,java.util.concurrent.TimeUnit)">put(key, value, lifespan, timeunit)</a> , this creates a <em>mortal</em> entry, i.e., an entry that has a fixed lifespan and expires after that lifespan.</p>
</div>
<div class="paragraph">
<p>In addition to <em>lifespan</em> , Infinispan also supports <em>maxIdle</em> as an additional metric with which to determine expiration.  Any combination of lifespans or maxIdles can be used.</p>
</div>
</div>
<div class="sect3">
<h4 id="putforexternalread_operation"><a class="anchor" href="#putforexternalread_operation"></a>3.1.3. putForExternalRead operation</h4>
<div class="paragraph">
<p>Infinispan&#8217;s <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/Cache.html">Cache</a> class contains a different 'put' operation called <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/Cache.html#putForExternalRead(K,V)">putForExternalRead</a> . This operation is particularly useful when Infinispan is used as a temporary cache for data that is persisted elsewhere.  Under heavy read scenarios, contention in the cache should not delay the real transactions at hand, since caching should just be an optimization and not something that gets in the way.</p>
</div>
<div class="paragraph">
<p>To achieve this, <code>putForExternalRead()</code> acts as a put call that only operates if the key is not present in the cache, and fails fast and silently if another thread is trying to store the same key at the same time. In this particular scenario, caching data is a way to optimise the system and it&#8217;s not desirable that a failure in caching affects the on-going transaction, hence why failure is handled differently. <code>putForExternalRead()</code> is considered to be a fast operation because regardless of whether it&#8217;s successful or not, it doesn&#8217;t wait for any locks, and so returns to the caller promptly.</p>
</div>
<div class="paragraph">
<p>To understand how to use this operation, let&#8217;s look at basic example. Imagine a cache of Person instances, each keyed by a PersonId , whose data originates in a separate data store. The following code shows the most common pattern of using <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/Cache.html#putForExternalRead(K,V)">putForExternalRead</a> within the context of this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Id of the person to look up, provided by the application
PersonId id = ...;

// Get a reference to the cache where person instances will be stored
Cache&lt;PersonId, Person&gt; cache = ...;

// First, check whether the cache contains the person instance
// associated with with the given id
Person cachedPerson = cache.get(id);

if (cachedPerson == null) {
   // The person is not cached yet, so query the data store with the id
   Person person = dataStore.lookup(id);

   // Cache the person along with the id so that future requests can
   // retrieve it from memory rather than going to the data store
   cache.putForExternalRead(id, person);
} else {
   // The person was found in the cache, so return it to the application
   return cachedPerson;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/Cache.html#putForExternalRead(K,V)">putForExternalRead</a> should never be used as a mechanism to update the cache with a new Person instance originating from application execution (i.e. from a transaction that modifies a Person&#8217;s address). When updating cached values, please use the standard <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#put-K-V-">put</a> operation, otherwise the possibility of caching corrupt data is likely.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="advancedcache_api"><a class="anchor" href="#advancedcache_api"></a>3.2. AdvancedCache API</h3>
<div class="paragraph">
<p>In addition to the simple Cache interface, Infinispan offers an <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/AdvancedCache.html">AdvancedCache</a> interface, geared towards extension authors.  The AdvancedCache offers the ability to access certain internal components and to apply flags to alter the default behavior of certain cache methods.  The following code snippet depicts how an AdvancedCache can be obtained:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">AdvancedCache advancedCache = cache.getAdvancedCache();</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="flags"><a class="anchor" href="#flags"></a>3.2.1. Flags</h4>
<div class="paragraph">
<p>Flags are applied to regular cache methods to alter the behavior of certain methods.  For a list of all available flags, and their effects, see the <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/context/Flag.html">Flag</a> enumeration.  Flags are applied using <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/AdvancedCache.html#withFlags(java.util.Collection)">AdvancedCache.withFlags()</a> .  This builder method can be used to apply any number of flags to a cache invocation, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">advancedCache.withFlags(Flag.CACHE_MODE_LOCAL, Flag.SKIP_LOCKING)
   .withFlags(Flag.FORCE_SYNCHRONOUS)
   .put("hello", "world");</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="listeners_and_notifications"><a class="anchor" href="#listeners_and_notifications"></a>3.3. Listeners and Notifications</h3>
<div class="paragraph">
<p>Infinispan offers a listener API, where clients can register for and get notified when events take place.  This annotation-driven API applies to 2 different levels: cache level events and cache manager level events.</p>
</div>
<div class="paragraph">
<p>Events trigger a notification which is dispatched to listeners.   Listeners are simple <a href="http://en.wikipedia.org/wiki/Plain_Old_Java_Object">POJO</a>s annotated with <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/notifications/Listener.html">@Listener</a> and registered using the methods defined in the <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/notifications/Listenable.html">Listenable</a> interface.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Both Cache and CacheManager implement Listenable, which means you can attach listeners to either a cache or a cache manager, to receive either cache-level or cache manager-level notifications.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For example, the following class defines a listener to print out some information every time a new entry is added to the cache, in a non blocking fashion:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Listener
public class PrintWhenAdded {
  Queue&lt;CacheEntryCreatedEvent&gt; events = new ConcurrentLinkedQueue&lt;&gt;();

  @CacheEntryCreated
  public CompletionStage&lt;Void&gt; print(CacheEntryCreatedEvent event) {
    events.add(event);
    return null;
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For more comprehensive examples, please see the <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/notifications/Listener.html">Javadocs for @Listener</a>.</p>
</div>
<div class="sect3">
<h4 id="cache_level_notifications"><a class="anchor" href="#cache_level_notifications"></a>3.3.1. Cache-level notifications</h4>
<div class="paragraph">
<p>Cache-level events occur on a per-cache basis, and by default are only raised on nodes where the events occur.  Note in a distributed cache these events are only raised on the owners of data being affected.  Examples of cache-level events are entries being added, removed, modified, etc.  These events trigger notifications to listeners registered to a specific cache.</p>
</div>
<div class="paragraph">
<p>Please see the <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/notifications/cachelistener/annotation/package-summary.html">Javadocs on the org.infinispan.notifications.cachelistener.annotation package</a> for a comprehensive list of all cache-level notifications, and their respective method-level annotations.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please refer to the <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/notifications/cachelistener/annotation/package-summary.html">Javadocs on the org.infinispan.notifications.cachelistener.annotation package</a> for the list of cache-level notifications available in Infinispan.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="cluster_listeners"><a class="anchor" href="#cluster_listeners"></a>Cluster Listeners</h5>
<div class="paragraph">
<p>The cluster listeners should be used when it is desirable to listen to the cache events on a single node.</p>
</div>
<div class="paragraph">
<p>To do so all that is required is set to annotate your listener as being clustered.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Listener (clustered = true)
public class MyClusterListener { .... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are some limitations to cluster listeners from a non clustered listener.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A cluster listener can only listen to <code>@CacheEntryModified</code>, <code>@CacheEntryCreated</code>, <code>@CacheEntryRemoved</code> and <code>@CacheEntryExpired</code> events.  Note this means any other type of event will not be listened to for this listener.</p>
</li>
<li>
<p>Only the post event is sent to a cluster listener, the pre event is ignored.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="event_filtering_and_conversion"><a class="anchor" href="#event_filtering_and_conversion"></a>Event filtering and conversion</h5>
<div class="paragraph">
<p>All applicable events on the node where the listener is installed will be raised to the listener.  It is possible to dynamically filter what events are raised by using a <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/filter/KeyFilter.html">KeyFilter</a> (only allows filtering on keys) or <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/notifications/cachelistener/filter/CacheEventFilter.html">CacheEventFilter</a> (used to filter for keys, old value, old metadata, new value, new metadata, whether command was retried, if the event is before the event (ie. isPre) and also the command type).</p>
</div>
<div class="paragraph">
<p>The example here shows a simple <code>KeyFilter</code> that will only allow events to be raised when an event modified the entry for the key <code>Only Me</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class SpecificKeyFilter implements KeyFilter&lt;String&gt; {
    private final String keyToAccept;

    public SpecificKeyFilter(String keyToAccept) {
      if (keyToAccept == null) {
        throw new NullPointerException();
      }
      this.keyToAccept = keyToAccept;
    }

    public boolean accept(String key) {
      return keyToAccept.equals(key);
    }
}

...
cache.addListener(listener, new SpecificKeyFilter("Only Me"));
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>This can be useful when you want to limit what events you receive in a more efficient manner.</p>
</div>
<div class="paragraph">
<p>There is also a <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/notifications/cachelistener/filter/CacheEventConverter.html">CacheEventConverter</a> that can be supplied that allows for converting a value to another before raising the event.  This can be nice to modularize any code that does value conversions.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The mentioned filters and converters are especially beneficial when used in conjunction with a Cluster Listener.  This is because the filtering and conversion is done on the node where the event originated and not on the node where event is listened to.  This can provide benefits of not having to replicate events across the cluster (filter) or even have reduced payloads (converter).
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="initial_state_events"><a class="anchor" href="#initial_state_events"></a>Initial State Events</h5>
<div class="paragraph">
<p>When a listener is installed it will only be notified of events after it is fully installed.</p>
</div>
<div class="paragraph">
<p>It may be desirable to get the current state of the cache contents upon first registration of listener by having an event generated of type <code>@CacheEntryCreated</code> for each element in the cache.  Any additionally generated events during this initial phase will be queued until appropriate events have been raised.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This only works for clustered listeners at this time.  <a href="https://issues.jboss.org/browse/ISPN-4608">ISPN-4608</a> covers adding this for non clustered listeners.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="duplicate_events"><a class="anchor" href="#duplicate_events"></a>Duplicate Events</h5>
<div class="paragraph">
<p>It is possible in a non transactional cache to receive duplicate events.  This is possible when the primary owner of a key goes down while trying to perform a write operation such as a put.</p>
</div>
<div class="paragraph">
<p>Infinispan internally will rectify the put operation by sending it to the new primary owner for the given key automatically, however there are no guarantees in regards to if the write was first replicated to backups.  Thus more than 1 of the following write events (<code>CacheEntryCreatedEvent</code>, <code>CacheEntryModifiedEvent</code> &amp; <code>CacheEntryRemovedEvent</code>) may be sent on a single operation.</p>
</div>
<div class="paragraph">
<p>If more than one event is generated Infinispan will mark the event that it was generated by a retried command to help the user to know when this occurs without having to pay attention to view changes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Listener
public class MyRetryListener {
  @CacheEntryModified
  public void entryModified(CacheEntryModifiedEvent event) {
    if (event.isCommandRetried()) {
      // Do something
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also when using a <code>CacheEventFilter</code> or <code>CacheEventConverter</code> the <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/notifications/cachelistener/filter/EventType.html">EventType</a> contains a method <code>isRetry</code> to tell if the event was generated due to retry.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cache_manager_level_notifications"><a class="anchor" href="#cache_manager_level_notifications"></a>3.3.2. Cache manager-level notifications</h4>
<div class="paragraph">
<p>Cache manager-level events occur on a cache manager.  These too are global and  cluster-wide, but involve events that affect all caches created by a single cache manager.  Examples of cache manager-level events are nodes joining or leaving a cluster, or caches starting or stopping.</p>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/notifications/cachemanagerlistener/annotation/package-summary.html">org.infinispan.notifications.cachemanagerlistener.annotation package</a> for a comprehensive list of all cache manager-level notifications,  and their respective method-level annotations.</p>
</div>
</div>
<div class="sect3">
<h4 id="synchronicity_of_events"><a class="anchor" href="#synchronicity_of_events"></a>3.3.3. Synchronicity of events</h4>
<div class="paragraph">
<p>By default, all async notifications are dispatched in the notification thread pool.
Sync notifications will delay the operation from continuing until the listener method completes or the CompletionStage
completes (the former causing the thread to block). Alternatively, you could annotate your listener as <em>asynchronous</em> in
which case the operation will continue immediately, while the notification is completed asynchronously on the notification thread pool.
To do this, simply annotate your listener such:</p>
</div>
<div class="paragraph">
<p>Asynchronous Listener</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Listener (sync = false)
public class MyAsyncListener {
   @CacheEntryCreated
   void listen(CacheEntryCreatedEvent event) { }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Blocking Synchronous Listener</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Listener
public class MySyncListener {
   @CacheEntryCreated
   void listen(CacheEntryCreatedEvent event) { }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Non-Blocking Listener</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Listener
public class MyNonBlockingListener {
   @CacheEntryCreated
   CompletionStage&lt;Void&gt; listen(CacheEntryCreatedEvent event) { }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="asynchronous_thread_pool"><a class="anchor" href="#asynchronous_thread_pool"></a>Asynchronous thread pool</h5>
<div class="paragraph">
<p>To tune the thread pool used to dispatch such asynchronous notifications, use the <a href="https://docs.jboss.org/infinispan/14.0/configdocs//infinispan-config-14.0.html"><code>&lt;listener-executor /&gt;</code></a> XML element in your configuration file.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cache_asynchronous_api"><a class="anchor" href="#cache_asynchronous_api"></a>3.4. Asynchronous API</h3>
<div class="paragraph">
<p>In addition to synchronous API methods like <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#put-K-V-">Cache.put()</a> , <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#remove-java.lang.Object-">Cache.remove()</a> , etc., Infinispan also has an asynchronous, non-blocking API where you can achieve the same results in a non-blocking fashion.</p>
</div>
<div class="paragraph">
<p>These methods are named in a similar fashion to their blocking counterparts, with "Async" appended.  E.g., <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/commons/api/AsyncCache.html#putAsync(K,V)">Cache.putAsync()</a> , <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/commons/api/AsyncCache.html#removeAsync(java.lang.Object)">Cache.removeAsync()</a> , etc.  These asynchronous counterparts return a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html">CompletableFuture</a> that contains the actual result of the operation.</p>
</div>
<div class="paragraph">
<p>For example, in a cache parameterized as <code>Cache&lt;String, String&gt;</code>, <code>Cache.put(String key, String value)</code> returns <code>String</code> while <code>Cache.putAsync(String key, String value)</code> returns <code>CompletableFuture&lt;String&gt;</code>.</p>
</div>
<div class="sect3">
<h4 id="why_use_such_an_api"><a class="anchor" href="#why_use_such_an_api"></a>3.4.1. Why use such an API?</h4>
<div class="paragraph">
<p>Non-blocking APIs are powerful in that they provide all of the guarantees of synchronous communications - with the ability to handle communication failures and exceptions - with the ease of not having to block until a call completes.  This allows you to better harness parallelism in your system.  For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Set&lt;CompletableFuture&lt;?&gt;&gt; futures = new HashSet&lt;&gt;();
futures.add(cache.putAsync(key1, value1)); // does not block
futures.add(cache.putAsync(key2, value2)); // does not block
futures.add(cache.putAsync(key3, value3)); // does not block

// the remote calls for the 3 puts will effectively be executed
// in parallel, particularly useful if running in distributed mode
// and the 3 keys would typically be pushed to 3 different nodes
// in the cluster

// check that the puts completed successfully
for (CompletableFuture&lt;?&gt; f: futures) f.get();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="which_processes_actually_happen_asynchronously"><a class="anchor" href="#which_processes_actually_happen_asynchronously"></a>3.4.2. Which processes actually happen asynchronously?</h4>
<div class="paragraph">
<p>There are 4 things in Infinispan that can be considered to be on the critical path of a typical write operation.
These are, in order of cost:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>network calls</p>
</li>
<li>
<p>marshalling</p>
</li>
<li>
<p>writing to a cache store (optional)</p>
</li>
<li>
<p>locking</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Using the async methods will take the network calls and marshalling off the critical path.  For various technical reasons, writing to a cache store and acquiring locks, however, still happens in the caller&#8217;s thread.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="clustered_locks"><a class="anchor" href="#clustered_locks"></a>4. Clustered Locks</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Clustered locks are data structures that are distributed and shared across
nodes in a Infinispan cluster. Clustered locks allow you to run code that is
synchronized between nodes.</p>
</div>
<div class="sect2">
<h3 id="lock_api-locking"><a class="anchor" href="#lock_api-locking"></a>4.1. Lock API</h3>
<div class="paragraph">
<p>Infinispan provides a <code>ClusteredLock</code> API that lets you concurrently execute
code on a cluster when using Infinispan in embedded mode.</p>
</div>
<div class="paragraph">
<p>The API consists of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ClusteredLock</code> exposes methods to implement clustered locks.</p>
</li>
<li>
<p><code>ClusteredLockManager</code> exposes methods to define, configure, retrieve, and remove clustered locks.</p>
</li>
<li>
<p><code>EmbeddedClusteredLockManagerFactory</code> initializes <code>ClusteredLockManager</code> implementations.</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">Ownership</div>
<p>Infinispan supports <code>NODE</code> ownership so that all nodes in a cluster can use a
lock.</p>
</div>
<div class="paragraph">
<div class="title">Reentrancy</div>
<p>Infinispan clustered locks are non-reentrant so any node in the cluster can
acquire a lock but only the node that creates the lock can release it.</p>
</div>
<div class="paragraph">
<p>If two consecutive lock calls are sent for the same owner, the first call
acquires the lock if it is available and the second call is blocked.</p>
</div>
<div class="ulist">
<div class="title">Reference</div>
<ul>
<li>
<p><a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/lock/EmbeddedClusteredLockManagerFactory.html">EmbeddedClusteredLockManagerFactory</a></p>
</li>
<li>
<p><a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/lock/api/ClusteredLockManager.html">ClusteredLockManager</a></p>
</li>
<li>
<p><a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/lock/api/ClusteredLock.html">ClusteredLock</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="using_clustered_locks-locking"><a class="anchor" href="#using_clustered_locks-locking"></a>4.2. Using Clustered Locks</h3>
<div class="paragraph">
<p>Learn how to use clustered locks with Infinispan embedded in your application.</p>
</div>
<div class="ulist">
<div class="title">Prerequisites</div>
<ul>
<li>
<p>Add the <code>infinispan-clustered-lock</code> dependency to your <code>pom.xml</code>:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
   &lt;groupId&gt;org.infinispan&lt;/groupId&gt;
   &lt;artifactId&gt;infinispan-clustered-lock&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Initialize the <code>ClusteredLockManager</code> interface from a Cache Manager. This interface is the entry point for defining, retrieving, and removing clustered locks.</p>
</li>
<li>
<p>Give a unique name for each clustered lock.</p>
</li>
<li>
<p>Acquire locks with the <code>lock.tryLock(1, TimeUnit.SECONDS)</code> method.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Set up a clustered Cache Manager.
GlobalConfigurationBuilder global = GlobalConfigurationBuilder.defaultClusteredBuilder();

// Configure the cache mode, in this case it is distributed and synchronous.
ConfigurationBuilder builder = new ConfigurationBuilder();
builder.clustering().cacheMode(CacheMode.DIST_SYNC);

// Initialize a new default Cache Manager.
DefaultCacheManager cm = new DefaultCacheManager(global.build(), builder.build());

// Initialize a Clustered Lock Manager.
ClusteredLockManager clm1 = EmbeddedClusteredLockManagerFactory.from(cm);

// Define a clustered lock named 'lock'.
clm1.defineLock("lock");

// Get a lock from each node in the cluster.
ClusteredLock lock = clm1.get("lock");

AtomicInteger counter = new AtomicInteger(0);

// Acquire the lock as follows.
// Each 'lock.tryLock(1, TimeUnit.SECONDS)' method attempts to acquire the lock.
// If the lock is not available, the method waits for the timeout period to elapse. When the lock is acquired, other calls to acquire the lock are blocked until the lock is released.
CompletableFuture&lt;Boolean&gt; call1 = lock.tryLock(1, TimeUnit.SECONDS).whenComplete((r, ex) -&gt; {
    if (r) {
        System.out.println("lock is acquired by the call 1");
        lock.unlock().whenComplete((nil, ex2) -&gt; {
            System.out.println("lock is released by the call 1");
            counter.incrementAndGet();
        });
    }
});

CompletableFuture&lt;Boolean&gt; call2 = lock.tryLock(1, TimeUnit.SECONDS).whenComplete((r, ex) -&gt; {
    if (r) {
        System.out.println("lock is acquired by the call 2");
        lock.unlock().whenComplete((nil, ex2) -&gt; {
            System.out.println("lock is released by the call 2");
            counter.incrementAndGet();
        });
    }
});

CompletableFuture&lt;Boolean&gt; call3 = lock.tryLock(1, TimeUnit.SECONDS).whenComplete((r, ex) -&gt; {
    if (r) {
        System.out.println("lock is acquired by the call 3");
        lock.unlock().whenComplete((nil, ex2) -&gt; {
            System.out.println("lock is released by the call 3");
            counter.incrementAndGet();
        });
    }
});

CompletableFuture.allOf(call1, call2, call3).whenComplete((r, ex) -&gt; {
    // Print the value of the counter.
    System.out.println("Value of the counter is " + counter.get());

    // Stop the Cache Manager.
    cm.stop();
});</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuring_clustered_locks-locking"><a class="anchor" href="#configuring_clustered_locks-locking"></a>4.3. Configuring Internal Caches for Locks</h3>
<div class="paragraph">
<p>Clustered Lock Managers include an internal cache that stores lock state. You
can configure the internal cache either declaratively or programmatically.</p>
</div>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Define the number of nodes in the cluster that store the state of clustered locks. The default value is <code>-1</code>, which replicates the value to all nodes.</p>
</li>
<li>
<p>Specify one of the following values for the cache reliability, which controls how clustered locks behave when clusters split into partitions or multiple nodes leave:</p>
<div class="ulist">
<ul>
<li>
<p><code>AVAILABLE</code>: Nodes in any partition can concurrently operate on locks.</p>
</li>
<li>
<p><code>CONSISTENT</code>: Only nodes that belong to the majority partition can operate on locks. This is the default value.</p>
</li>
<li>
<p>Programmatic configuration</p>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-java" data-lang="java">import org.infinispan.lock.configuration.ClusteredLockManagerConfiguration;
import org.infinispan.lock.configuration.ClusteredLockManagerConfigurationBuilder;
import org.infinispan.lock.configuration.Reliability;
...

GlobalConfigurationBuilder global = GlobalConfigurationBuilder.defaultClusteredBuilder();

final ClusteredLockManagerConfiguration config = global.addModule(ClusteredLockManagerConfigurationBuilder.class).numOwner(2).reliability(Reliability.AVAILABLE).create();

DefaultCacheManager cm = new DefaultCacheManager(global.build());

ClusteredLockManager clm1 = EmbeddedClusteredLockManagerFactory.from(cm);

clm1.defineLock("lock");</code></pre>
</div>
</div>
</li>
<li>
<p>Declarative configuration</p>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-xml" data-lang="xml">&lt;infinispan
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="urn:infinispan:config:14.0 https://infinispan.org/schemas/infinispan-config-14.0.xsd"
        xmlns="urn:infinispan:config:14.0"&gt;

    &lt;cache-container default-cache="default"&gt;
        &lt;transport/&gt;
        &lt;local-cache name="default"&gt;
            &lt;locking concurrency-level="100" acquire-timeout="1000"/&gt;
        &lt;/local-cache&gt;
        &lt;clustered-locks xmlns="urn:infinispan:config:clustered-locks:14.0"
                         num-owners = "3"
                         reliability="AVAILABLE"&gt;
            &lt;clustered-lock name="lock1" /&gt;
            &lt;clustered-lock name="lock2" /&gt;
        &lt;/clustered-locks&gt;
    &lt;/cache-container&gt;
    &lt;!-- Cache configuration goes here. --&gt;
&lt;/infinispan&gt;</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="ulist">
<div class="title">Reference</div>
<ul>
<li>
<p><a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/lock/configuration/ClusteredLockManagerConfiguration.html">ClusteredLockManagerConfiguration</a></p>
</li>
<li>
<p><a href="https://docs.jboss.org/infinispan/14.0/configdocs/infinispan-clustered-locks-config-infinispan-clustered-locks-config-12.0.html.html">Clustered Locks Configuration Schema</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="clustered_counters"><a class="anchor" href="#clustered_counters"></a>5. Clustered Counters</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>Clustered counters</em> are counters which are distributed and shared among all nodes in the Infinispan cluster.
Counters can have different consistency levels: strong and weak.</p>
</div>
<div class="paragraph">
<p>Although a strong/weak consistent counter has separate interfaces, both support updating its value,
return the current value and they provide events when its value is updated.
Details are provided below in this document to help you choose which one fits best your uses-case.</p>
</div>
<div class="sect2">
<h3 id="installation_and_configuration"><a class="anchor" href="#installation_and_configuration"></a>5.1. Installation and Configuration</h3>
<div class="paragraph">
<p>In order to start using the counters, you needs to add the dependency in your Maven <code>pom.xml</code> file:</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.infinispan&lt;/groupId&gt;
  &lt;artifactId&gt;infinispan-clustered-counter&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The counters can be configured Infinispan configuration file or on-demand via the <code>CounterManager</code> interface detailed
later in this document.
A counters configured in Infinispan configuration file is created at boot time when the <code>EmbeddedCacheManager</code> is starting.
These counters are started eagerly and they are available in all the cluster&#8217;s nodes.</p>
</div>
<div class="listingblock">
<div class="title">configuration.xml</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-xml" data-lang="xml">&lt;infinispan&gt;
    &lt;cache-container ...&gt;
        &lt;!-- To persist counters, you need to configure the global state. --&gt;
        &lt;global-state&gt;
        &lt;!-- Global state configuration goes here. --&gt;
        &lt;/global-state&gt;
        &lt;!-- Cache configuration goes here. --&gt;
         &lt;counters xmlns="urn:infinispan:config:counters:14.0" num-owners="3" reliability="CONSISTENT"&gt;
             &lt;strong-counter name="c1" initial-value="1" storage="PERSISTENT"/&gt;
             &lt;strong-counter name="c2" initial-value="2" storage="VOLATILE" lower-bound="0"/&gt;
             &lt;strong-counter name="c3" initial-value="3" storage="PERSISTENT" upper-bound="5"/&gt;
             &lt;strong-counter name="c4" initial-value="4" storage="VOLATILE" lower-bound="0" upper-bound="10"/&gt;
             &lt;strong-counter name="c5" initial-value="0" upper-bound="100" lifespan="60000"/&gt;
             &lt;weak-counter name="c6" initial-value="5" storage="PERSISTENT" concurrency-level="1"/&gt;
         &lt;/counters&gt;
    &lt;/cache-container&gt;
&lt;/infinispan&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>or programmatically, in the <code>GlobalConfigurationBuilder</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">GlobalConfigurationBuilder globalConfigurationBuilder = ...;
CounterManagerConfigurationBuilder builder = globalConfigurationBuilder.addModule(CounterManagerConfigurationBuilder.class);
builder.numOwner(3).reliability(Reliability.CONSISTENT);
builder.addStrongCounter().name("c1").initialValue(1).storage(Storage.PERSISTENT);
builder.addStrongCounter().name("c2").initialValue(2).lowerBound(0).storage(Storage.VOLATILE);
builder.addStrongCounter().name("c3").initialValue(3).upperBound(5).storage(Storage.PERSISTENT);
builder.addStrongCounter().name("c4").initialValue(4).lowerBound(0).upperBound(10).storage(Storage.VOLATILE);
builder.addStrongCounter().name("c5").initialValue(0).upperBound(100).lifespan(60000);
builder.addWeakCounter().name("c6").initialValue(5).concurrencyLevel(1).storage(Storage.PERSISTENT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>On other hand, the counters can be configured on-demand, at any time after the <code>EmbeddedCacheManager</code> is initialized.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">CounterManager manager = ...;
manager.defineCounter("c1", CounterConfiguration.builder(CounterType.UNBOUNDED_STRONG).initialValue(1).storage(Storage.PERSISTENT).build());
manager.defineCounter("c2", CounterConfiguration.builder(CounterType.BOUNDED_STRONG).initialValue(2).lowerBound(0).storage(Storage.VOLATILE).build());
manager.defineCounter("c3", CounterConfiguration.builder(CounterType.BOUNDED_STRONG).initialValue(3).upperBound(5).storage(Storage.PERSISTENT).build());
manager.defineCounter("c4", CounterConfiguration.builder(CounterType.BOUNDED_STRONG).initialValue(4).lowerBound(0).upperBound(10).storage(Storage.VOLATILE).build());
manager.defineCounter("c4", CounterConfiguration.builder(CounterType.BOUNDED_STRONG).initialValue(0).upperBound(100).lifespan(60000).build());
manager.defineCounter("c6", CounterConfiguration.builder(CounterType.WEAK).initialValue(5).concurrencyLevel(1).storage(Storage.PERSISTENT).build());</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>CounterConfiguration</code> is immutable and can be reused.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The method <code>defineCounter()</code> will return <code>true</code> if the counter is successful configured or <code>false</code> otherwise.
However, if the configuration is invalid, the method will throw a <code>CounterConfigurationException</code>.
To find out if a counter is already defined, use the method <code>isDefined()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">CounterManager manager = ...
if (!manager.isDefined("someCounter")) {
    manager.define("someCounter", ...);
}</code></pre>
</div>
</div>
<div class="ulist _additional-resources">
<div class="title">Additional resources</div>
<ul>
<li>
<p><a href="https://docs.jboss.org/infinispan/14.0/configdocs//infinispan-counters-config-14.0.html">Infinispan configuration schema reference</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="list_counter_names"><a class="anchor" href="#list_counter_names"></a>5.1.1. List counter names</h4>
<div class="paragraph">
<p>To list all the counters defined, the method <code>CounterManager.getCounterNames()</code> returns a collection of all counter
names created cluster-wide.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="countermanager_interface"><a class="anchor" href="#countermanager_interface"></a>5.2. <code>CounterManager</code> interface</h3>
<div class="paragraph">
<p>The <code>CounterManager</code> interface is the entry point to define, retrieve and remove counters.</p>
</div>
<div class="paragraph">
<div class="title">Embedded deployments</div>
<p><code>CounterManager</code> automatically listen to the creation of <code>EmbeddedCacheManager</code> and proceeds with the registration  of an
instance of it per <code>EmbeddedCacheManager</code>.
It starts the caches needed to store the counter state and configures the default counters.</p>
</div>
<div class="paragraph">
<p>Retrieving the <code>CounterManager</code> is as simple as invoke the
<code>EmbeddedCounterManagerFactory.asCounterManager(EmbeddedCacheManager)</code>
as shown in the example below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// create or obtain your EmbeddedCacheManager
EmbeddedCacheManager manager = ...;

// retrieve the CounterManager
CounterManager counterManager = EmbeddedCounterManagerFactory.asCounterManager(manager);</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">Server deployments</div>
<p>For Hot Rod clients, the <code>CounterManager</code> is registered in the RemoteCacheManager and can be retrieved as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// create or obtain your RemoteCacheManager
RemoteCacheManager manager = ...;

// retrieve the CounterManager
CounterManager counterManager = RemoteCounterManagerFactory.asCounterManager(manager);</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="remove_a_counter_via_countermanager"><a class="anchor" href="#remove_a_counter_via_countermanager"></a>5.2.1. Remove a counter via CounterManager</h4>
<div class="paragraph">
<p>There is a difference between remove a counter via the <code>Strong/WeakCounter</code> interfaces and the <code>CounterManager</code>.
The <code>CounterManager.remove(String)</code> removes the counter value from the cluster and removes all the listeners registered
in the counter in the local counter instance.
In addition, the counter instance is no longer reusable and it may return an invalid results.</p>
</div>
<div class="paragraph">
<p>On the other side, the <code>Strong/WeakCounter</code> removal only removes the counter value.
The instance can still be reused and the listeners still works.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The counter is re-created if it is accessed after a removal.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="the_counter"><a class="anchor" href="#the_counter"></a>5.3. The Counter</h3>
<div class="paragraph">
<p>A counter can be strong (<code>StrongCounter</code>) or weakly consistent (<code>WeakCounter</code>) and both is identified by a name.
They have a specific interface but they share some logic, namely, both of them are asynchronous
( a <code>CompletableFuture</code> is returned by each operation), provide an update event and can be reset to its initial value.</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t want to use the async API, it is possible to return a synchronous counter via <code>sync()</code> method.
The API is the same but without the <code>CompletableFuture</code> return value.</p>
</div>
<div class="paragraph">
<p>The following methods are common to both interfaces:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String getName();
CompletableFuture&lt;Long&gt; getValue();
CompletableFuture&lt;Void&gt; reset();
&lt;T extends CounterListener&gt; Handle&lt;T&gt; addListener(T listener);
CounterConfiguration getConfiguration();
CompletableFuture&lt;Void&gt; remove();
SyncStrongCounter sync(); //SyncWeakCounter for WeakCounter</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getName()</code> returns the counter name (identifier).</p>
</li>
<li>
<p><code>getValue()</code> returns the current counter&#8217;s value.</p>
</li>
<li>
<p><code>reset()</code> allows to reset the counter&#8217;s value to its initial value.</p>
</li>
<li>
<p><code>addListener()</code> register a listener to receive update events.
More details about it in the <a href="#clustered_counters_notify_events">Notification and Events</a> section.</p>
</li>
<li>
<p><code>getConfiguration()</code> returns the configuration used by the counter.</p>
</li>
<li>
<p><code>remove()</code> removes the counter value from the cluster. The instance can still be used and the listeners are kept.</p>
</li>
<li>
<p><code>sync()</code> creates a synchronous counter.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The counter is re-created if it is accessed after a removal.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="the_strongcounter_interface_when_the_consistency_or_bounds_matters"><a class="anchor" href="#the_strongcounter_interface_when_the_consistency_or_bounds_matters"></a>5.3.1. The <code>StrongCounter</code> interface: when the consistency or bounds matters.</h4>
<div class="paragraph">
<p>The strong counter provides uses a single key stored in Infinispan cache to provide the consistency needed.
All the updates are performed under the key lock to updates its values.
On other hand, the reads don&#8217;t acquire any locks and reads the current value.
Also, with this scheme, it allows to bound the counter value and provide atomic operations like compare-and-set/swap.</p>
</div>
<div class="paragraph">
<p>A <code>StrongCounter</code> can be retrieved from the <code>CounterManager</code> by using the <code>getStrongCounter()</code> method.
As an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">CounterManager counterManager = ...
StrongCounter aCounter = counterManager.getStrongCounter("my-counter");</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Since every operation will hit a single key, the <code>StrongCounter</code> has a higher contention rate.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>StrongCounter</code> interface adds the following method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">default CompletableFuture&lt;Long&gt; incrementAndGet() {
   return addAndGet(1L);
}

default CompletableFuture&lt;Long&gt; decrementAndGet() {
   return addAndGet(-1L);
}

CompletableFuture&lt;Long&gt; addAndGet(long delta);

CompletableFuture&lt;Boolean&gt; compareAndSet(long expect, long update);

CompletableFuture&lt;Long&gt; compareAndSwap(long expect, long update);</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>incrementAndGet()</code> increments the counter by one and returns the new value.</p>
</li>
<li>
<p><code>decrementAndGet()</code> decrements the counter by one and returns the new value.</p>
</li>
<li>
<p><code>addAndGet()</code> adds a delta to the counter&#8217;s value and returns the new value.</p>
</li>
<li>
<p><code>compareAndSet()</code> and <code>compareAndSwap()</code> atomically set the counter&#8217;s value if the current value is the expected.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A operation is considered completed when the <code>CompletableFuture</code> is completed.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The difference between compare-and-set and compare-and-swap is that the former returns true if the operation succeeds
while the later returns the previous value.
The compare-and-swap is successful if the return value is the same as the expected.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="bounded_strongcounter"><a class="anchor" href="#bounded_strongcounter"></a>Bounded <code>StrongCounter</code></h5>
<div class="paragraph">
<p>When bounded, all the update method above will throw a <code>CounterOutOfBoundsException</code> when they reached the
lower or upper bound.
The exception has the following methods to check which side bound has been reached:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public boolean isUpperBoundReached();
public boolean isLowerBoundReached();</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="uses_cases"><a class="anchor" href="#uses_cases"></a>Uses cases</h5>
<div class="paragraph">
<p>The strong counter fits better in the following uses cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When counter&#8217;s value is needed after each update (example, cluster-wise ids generator or sequences)</p>
</li>
<li>
<p>When a bounded counter is needed (example, rate limiter)</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="usage_examples"><a class="anchor" href="#usage_examples"></a>Usage Examples</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StrongCounter counter = counterManager.getStrongCounter("unbounded_counter");

// incrementing the counter
System.out.println("new value is " + counter.incrementAndGet().get());

// decrement the counter's value by 100 using the functional API
counter.addAndGet(-100).thenApply(v -&gt; {
   System.out.println("new value is " + v);
   return null;
}).get();

// alternative, you can do some work while the counter is updated
CompletableFuture&lt;Long&gt; f = counter.addAndGet(10);
// ... do some work ...
System.out.println("new value is " + f.get());

// and then, check the current value
System.out.println("current value is " + counter.getValue().get());

// finally, reset to initial value
counter.reset().get();
System.out.println("current value is " + counter.getValue().get());

// or set to a new value if zero
System.out.println("compare and set succeeded? " + counter.compareAndSet(0, 1));</code></pre>
</div>
</div>
<div class="paragraph">
<p>And below, there is another example using a bounded counter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StrongCounter counter = counterManager.getStrongCounter("bounded_counter");

// incrementing the counter
try {
    System.out.println("new value is " + counter.addAndGet(100).get());
} catch (ExecutionException e) {
    Throwable cause = e.getCause();
    if (cause instanceof CounterOutOfBoundsException) {
       if (((CounterOutOfBoundsException) cause).isUpperBoundReached()) {
          System.out.println("ops, upper bound reached.");
       } else if (((CounterOutOfBoundsException) cause).isLowerBoundReached()) {
          System.out.println("ops, lower bound reached.");
       }
    }
}

// now using the functional API
counter.addAndGet(-100).handle((v, throwable) -&gt; {
   if (throwable != null) {
      Throwable cause = throwable.getCause();
      if (cause instanceof CounterOutOfBoundsException) {
         if (((CounterOutOfBoundsException) cause).isUpperBoundReached()) {
            System.out.println("ops, upper bound reached.");
         } else if (((CounterOutOfBoundsException) cause).isLowerBoundReached()) {
            System.out.println("ops, lower bound reached.");
         }
      }
      return null;
   }
   System.out.println("new value is " + v);
   return null;
}).get();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Compare-and-set vs Compare-and-swap examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StrongCounter counter = counterManager.getStrongCounter("my-counter");
long oldValue, newValue;
do {
   oldValue = counter.getValue().get();
   newValue = someLogic(oldValue);
} while (!counter.compareAndSet(oldValue, newValue).get());</code></pre>
</div>
</div>
<div class="paragraph">
<p>With compare-and-swap, it saves one invocation counter invocation (<code>counter.getValue()</code>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StrongCounter counter = counterManager.getStrongCounter("my-counter");
long oldValue = counter.getValue().get();
long currentValue, newValue;
do {
   currentValue = oldValue;
   newValue = someLogic(oldValue);
} while ((oldValue = counter.compareAndSwap(oldValue, newValue).get()) != currentValue);</code></pre>
</div>
</div>
<div class="paragraph">
<p>To use a strong counter as a rate limiter, configure <code>upper-bound</code> and <code>lifespan</code> parameters as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// 5 request per minute
CounterConfiguration configuration = CounterConfiguration.builder(CounterType.BOUNDED_STRONG)
      .upperBound(5)
      .lifespan(60000)
      .build();
counterManager.defineCounter("rate_limiter", configuration);
StrongCounter counter = counterManager.getStrongCounter("rate_limiter");

// on each operation, invoke
try {
   counter.incrementAndGet().get();
   // continue with operation
} catch (InterruptedException e) {
   Thread.currentThread().interrupt();
} catch (ExecutionException e) {
   if (e.getCause() instanceof CounterOutOfBoundsException) {
      // maximum rate. discard operation
      return;
   } else {
      // unexpected error, handling property
   }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>lifespan</code> parameter is an experimental capability and may be removed in a future version.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="the_weakcounter_interface_when_speed_is_needed"><a class="anchor" href="#the_weakcounter_interface_when_speed_is_needed"></a>5.3.2. The <code>WeakCounter</code> interface: when speed is needed</h4>
<div class="paragraph">
<p>The <code>WeakCounter</code> stores the counter&#8217;s value in multiple keys in Infinispan cache.
The number of keys created is configured by the <code>concurrency-level</code> attribute.
Each key stores a partial state of the counter&#8217;s value and it can be updated concurrently.
It main advantage over the <code>StrongCounter</code> is the lower contention in the cache.
On other hand, the read of its value is more expensive and bounds are not allowed.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The reset operation should be handled with caution.
It is <strong>not</strong> atomic and it produces intermediates values.
These value may be seen by a read operation and by any listener registered.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A <code>WeakCounter</code> can be retrieved from the <code>CounterManager</code> by using the <code>getWeakCounter()</code> method.
As an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">CounterManager counterManager = ...
StrongCounter aCounter = counterManager.getWeakCounter("my-counter);</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="weak_counter_interface"><a class="anchor" href="#weak_counter_interface"></a>Weak Counter Interface</h5>
<div class="paragraph">
<p>The <code>WeakCounter</code> adds the following methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">default CompletableFuture&lt;Void&gt; increment() {
   return add(1L);
}

default CompletableFuture&lt;Void&gt; decrement() {
   return add(-1L);
}

CompletableFuture&lt;Void&gt; add(long delta);</code></pre>
</div>
</div>
<div class="paragraph">
<p>They are similar to the `StrongCounter&#8217;s methods but they don&#8217;t return the new value.</p>
</div>
</div>
<div class="sect4">
<h5 id="uses_cases_2"><a class="anchor" href="#uses_cases_2"></a>Uses cases</h5>
<div class="paragraph">
<p>The weak counter fits best in uses cases where the result of the update operation is not needed or the counter&#8217;s value
is not required too often.
Collecting statistics is a good example of such an use case.</p>
</div>
</div>
<div class="sect4">
<h5 id="examples"><a class="anchor" href="#examples"></a>Examples</h5>
<div class="paragraph">
<p>Below, there is an example of the weak counter usage.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">WeakCounter counter = counterManager.getWeakCounter("my_counter");

// increment the counter and check its result
counter.increment().get();
System.out.println("current value is " + counter.getValue());

CompletableFuture&lt;Void&gt; f = counter.add(-100);
//do some work
f.get(); //wait until finished
System.out.println("current value is " + counter.getValue().get());

//using the functional API
counter.reset().whenComplete((aVoid, throwable) -&gt; System.out.println("Reset done " + (throwable == null ? "successfully" : "unsuccessfully"))).get();
System.out.println("current value is " + counter.getValue().get());</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="clustered_counters_notify_events"><a class="anchor" href="#clustered_counters_notify_events"></a>5.4. Notifications and Events</h3>
<div class="paragraph">
<p>Both strong and weak counter supports a listener to receive its updates events.
The listener must implement <code>CounterListener</code> and it can be registered by the following method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">&lt;T extends CounterListener&gt; Handle&lt;T&gt; addListener(T listener);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>CounterListener</code> has the following interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface CounterListener {
   void onUpdate(CounterEvent entry);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handle</code> object returned has the main goal to remove the <code>CounterListener</code> when it is not longer needed.
Also, it allows to have access to the <code>CounterListener</code> instance that is it handling.
It has the following interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface Handle&lt;T extends CounterListener&gt; {
   T getCounterListener();
   void remove();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, the <code>CounterEvent</code> has the previous and current value and state.
It has the following interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface CounterEvent {
   long getOldValue();
   State getOldState();
   long getNewValue();
   State getNewState();
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The state is always <code>State.VALID</code> for unbounded strong counter and weak counter.
<code>State.LOWER_BOUND_REACHED</code> and <code>State.UPPER_BOUND_REACHED</code> are only valid for bounded strong counters.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The weak counter <code>reset()</code> operation will trigger multiple notification with intermediate values.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cdi_support"><a class="anchor" href="#cdi_support"></a>6. Using the CDI Extension</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Infinispan provides an extension that integrates with the CDI (Contexts and
Dependency Injection) programming model and allows you to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Configure and inject caches into CDI Beans and Java EE components.</p>
</li>
<li>
<p>Configure cache managers.</p>
</li>
<li>
<p>Receive cache and cache manager level events.</p>
</li>
<li>
<p>Control data storage and retrieval using JCache annotations.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="cdi_dependencies"><a class="anchor" href="#cdi_dependencies"></a>6.1. CDI Dependencies</h3>
<div class="paragraph">
<p>Update your <code>pom.xml</code> with one of the following dependencies to include the
Infinispan CDI extension in your project:</p>
</div>
<div class="listingblock">
<div class="title">Embedded (Library) Mode</div>
<div class="content">
<pre>&lt;dependency&gt;
  &lt;groupId&gt;org.infinispan&lt;/groupId&gt;
  &lt;artifactId&gt;infinispan-cdi-embedded&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="listingblock">
<div class="title">Server Mode</div>
<div class="content">
<pre>&lt;dependency&gt;
  &lt;groupId&gt;org.infinispan&lt;/groupId&gt;
  &lt;artifactId&gt;infinispan-cdi-remote&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cdi_inject_embed"><a class="anchor" href="#cdi_inject_embed"></a>6.2. Injecting Embedded Caches</h3>
<div class="paragraph">
<p>Set up CDI beans to inject embedded caches.</p>
</div>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Create a cache qualifier annotation.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">...
import javax.inject.Qualifier;

@Qualifier
@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface GreetingCache { <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Creates a <code>@GreetingCache</code> qualifier.</td>
</tr>
</table>
</div>
</li>
<li>
<p>Add a producer method that defines the cache configuration.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">...
import org.infinispan.configuration.cache.Configuration;
import org.infinispan.configuration.cache.ConfigurationBuilder;
import org.infinispan.cdi.ConfigureCache;
import javax.enterprise.inject.Produces;

public class Config {

    @ConfigureCache("mygreetingcache") <i class="conum" data-value="1"></i><b>(1)</b>
    @GreetingCache <i class="conum" data-value="2"></i><b>(2)</b>
    @Produces
    public Configuration greetingCacheConfiguration() {
        return new ConfigurationBuilder()
                    .memory()
                        .size(1000)
                    .build();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Names the cache to inject.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Adds the cache qualifier.</td>
</tr>
</table>
</div>
</li>
<li>
<p>Add a producer method that creates a clustered cache manager, if required</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">...
package org.infinispan.configuration.global.GlobalConfigurationBuilder;

public class Config {

    @GreetingCache <i class="conum" data-value="1"></i><b>(1)</b>
    @Produces
    @ApplicationScoped <i class="conum" data-value="2"></i><b>(2)</b>
    public EmbeddedCacheManager defaultClusteredCacheManager() { <i class="conum" data-value="3"></i><b>(3)</b>
      return new DefaultCacheManager(
        new GlobalConfigurationBuilder().transport().defaultTransport().build();
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Adds the cache qualifier.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Creates the bean once for the application. Producers that create cache managers should always include the <code>@ApplicationScoped</code> annotation to avoid creating multiple cache managers.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Creates a new <code>DefaultCacheManager</code> instance that is bound to the <code>@GreetingCache</code> qualifier.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Cache managers are heavy weight objects. Having more than one cache manager
running in your application can degrade performance. When injecting multiple
caches, either add the qualifier of each cache to the cache manager producer
method or do not add any qualifier.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Add the <code>@GreetingCache</code> qualifier to your cache injection point.</p>
<div class="listingblock">
<div class="content">
<pre>...
import javax.inject.Inject;

public class GreetingService {

    @Inject @GreetingCache
    private Cache&lt;String, String&gt; cache;

    public String greet(String user) {
        String cachedValue = cache.get(user);
        if (cachedValue == null) {
            cachedValue = "Hello " + user;
            cache.put(user, cachedValue);
        }
        return cachedValue;
    }
}</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="cdi_inject_remote"><a class="anchor" href="#cdi_inject_remote"></a>6.3. Injecting Remote Caches</h3>
<div class="paragraph">
<p>Set up CDI beans to inject remote caches.</p>
</div>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Create a cache qualifier annotation.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Remote("mygreetingcache") <i class="conum" data-value="1"></i><b>(1)</b>
@Qualifier
@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface RemoteGreetingCache { <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>names the cache to inject.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>creates a <code>@RemoteGreetingCache</code> qualifier.</td>
</tr>
</table>
</div>
</li>
<li>
<p>Add the <code>@RemoteGreetingCache</code> qualifier to your cache injection point.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class GreetingService {

    @Inject @RemoteGreetingCache
    private RemoteCache&lt;String, String&gt; cache;

    public String greet(String user) {
        String cachedValue = cache.get(user);
        if (cachedValue == null) {
            cachedValue = "Hello " + user;
            cache.put(user, cachedValue);
        }
        return cachedValue;
    }
}</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="ulist">
<div class="title">Tips for injecting remote caches</div>
<ul>
<li>
<p>You can inject remote caches without using qualifiers.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">   ...
   @Inject
   @Remote("greetingCache")
   private RemoteCache&lt;String, String&gt; cache;</code></pre>
</div>
</div>
</li>
<li>
<p>If you have more than one Infinispan cluster, you can create separate remote cache manager producers for each cluster.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">...
import javax.enterprise.context.ApplicationScoped;

public class Config {

    @RemoteGreetingCache
    @Produces
    @ApplicationScoped <i class="conum" data-value="1"></i><b>(1)</b>
    public ConfigurationBuilder builder = new ConfigurationBuilder(); <i class="conum" data-value="2"></i><b>(2)</b>
        builder.addServer().host("localhost").port(11222);
        return new RemoteCacheManager(builder.build());
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>creates the bean once for the application. Producers that create cache managers should always include the <code>@ApplicationScoped</code> annotation to avoid creating multiple cache managers, which are heavy weight objects.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>creates a new <code>RemoteCacheManager</code> instance that is bound to the <code>@RemoteGreetingCache</code> qualifier.</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="jcache_annotations"><a class="anchor" href="#jcache_annotations"></a>6.4. JCache Caching Annotations</h3>
<div class="paragraph">
<p>You can use the following JCache caching annotations with CDI managed beans when JCache artifacts are on the classpath:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>@CacheResult</code></dt>
<dd>
<p>caches the results of method calls.</p>
</dd>
<dt class="hdlist1"><code>@CachePut</code></dt>
<dd>
<p>caches method parameters.</p>
</dd>
<dt class="hdlist1"><code>@CacheRemoveEntry</code></dt>
<dd>
<p>removes entries from a cache.</p>
</dd>
<dt class="hdlist1"><code>@CacheRemoveAll</code></dt>
<dd>
<p>removes all entries from a cache.</p>
</dd>
</dl>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong>Target type:</strong> You can use these JCache caching annotations on methods only.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To use JCache caching annotations, declare interceptors in the <code>beans.xml</code>
file for your application.</p>
</div>
<div class="listingblock">
<div class="title">Managed Environments (Application Server)</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://xmlns.jcp.org/xml/ns/javaee"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/beans_1_1.xsd"
   version="1.2" bean-discovery-mode="annotated"&gt;

  &lt;interceptors&gt;
    &lt;class&gt;org.infinispan.jcache.annotation.InjectedCacheResultInterceptor&lt;/class&gt;
    &lt;class&gt;org.infinispan.jcache.annotation.InjectedCachePutInterceptor&lt;/class&gt;
    &lt;class&gt;org.infinispan.jcache.annotation.InjectedCacheRemoveEntryInterceptor&lt;/class&gt;
    &lt;class&gt;org.infinispan.jcache.annotation.InjectedCacheRemoveAllInterceptor&lt;/class&gt;
  &lt;/interceptors&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Non-managed Environments (Standalone)</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://xmlns.jcp.org/xml/ns/javaee"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/beans_1_1.xsd"
   version="1.2" bean-discovery-mode="annotated"&gt;

  &lt;interceptors&gt;
    &lt;class&gt;org.infinispan.jcache.annotation.CacheResultInterceptor&lt;/class&gt;
    &lt;class&gt;org.infinispan.jcache.annotation.CachePutInterceptor&lt;/class&gt;
    &lt;class&gt;org.infinispan.jcache.annotation.CacheRemoveEntryInterceptor&lt;/class&gt;
    &lt;class&gt;org.infinispan.jcache.annotation.CacheRemoveAllInterceptor&lt;/class&gt;
  &lt;/interceptors&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">JCache Caching Annotation Examples</div>
<p>The following example shows how the <code>@CacheResult</code> annotation caches the results of the <code>GreetingService.greet()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import javax.cache.interceptor.CacheResult;

public class GreetingService {

    @CacheResult
    public String greet(String user) {
        return "Hello" + user;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With JCache annotations, the default cache uses the fully qualified name of the
annotated method with its parameter types, for example:<br>
<code>org.infinispan.example.GreetingService.greet(java.lang.String)</code></p>
</div>
<div class="paragraph">
<p>To use caches other than the default, use the <code>cacheName</code> attribute to specify
the cache name as in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@CacheResult(cacheName = "greeting-cache")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cache_events"><a class="anchor" href="#cache_events"></a>6.5. Receiving Cache and Cache Manager Events</h3>
<div class="paragraph">
<p>You can use CDI Events to receive Cache and cache manager level events.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use the <code>@Observes</code> annotation as in the following example:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import javax.enterprise.event.Observes;
import org.infinispan.notifications.cachemanagerlistener.event.CacheStartedEvent;
import org.infinispan.notifications.cachelistener.event.*;

public class GreetingService {

    // Cache level events
    private void entryRemovedFromCache(@Observes CacheEntryCreatedEvent event) {
        ...
    }

    // Cache manager level events
    private void cacheStarted(@Observes CacheStartedEvent event) {
        ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="locking_concurrency"><a class="anchor" href="#locking_concurrency"></a>7. Locking and Concurrency</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Infinispan makes use of multi-versioned concurrency control (<a href="http://en.wikipedia.org/wiki/Multiversion_concurrency_control">MVCC</a>) - a concurrency scheme popular with relational databases and other data stores.
MVCC offers many advantages over coarse-grained Java synchronization and even JDK Locks for access to shared data, including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>allowing concurrent readers and writers</p>
</li>
<li>
<p>readers and writers do not block one another</p>
</li>
<li>
<p>write skews can be detected and handled</p>
</li>
<li>
<p>internal locks can be striped</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="locking_implementation_details"><a class="anchor" href="#locking_implementation_details"></a>7.1. Locking implementation details</h3>
<div class="paragraph">
<p>Infinispan&#8217;s MVCC implementation makes use of minimal locks and synchronizations, leaning heavily towards lock-free techniques such as <a href="http://en.wikipedia.org/wiki/Compare-and-swap">compare-and-swap</a> and lock-free data structures wherever possible, which helps optimize for multi-CPU and multi-core environments.</p>
</div>
<div class="paragraph">
<p>In particular, Infinispan&#8217;s MVCC implementation is heavily optimized for readers.
Reader threads do not acquire explicit locks for entries, and instead directly read the entry in question.</p>
</div>
<div class="paragraph">
<p>Writers, on the other hand, need to acquire a write lock.
This ensures only one concurrent writer per entry, causing concurrent writers to queue up to change an entry.</p>
</div>
<div class="paragraph">
<p>To allow concurrent reads, writers make a copy of the entry they intend to modify, by wrapping the entry in an <code>MVCCEntry</code>.
This copy isolates concurrent readers from seeing partially modified state.
Once a write has completed, <code>MVCCEntry.commit()</code> will flush changes to the data container and subsequent readers will see the changes written.</p>
</div>
<div class="sect3">
<h4 id="clustered_caches_and_locks"><a class="anchor" href="#clustered_caches_and_locks"></a>7.1.1. Clustered caches and locks</h4>
<div class="paragraph">
<p>In Infinispan clusters, primary owner nodes are responsible for locking keys.</p>
</div>
<div class="paragraph">
<p>For non-transactional caches, Infinispan forwards the write operation to the primary owner of the key so it can attempt to lock it.
Infinispan either then forwards the write operation to the other owners or throws an exception if it cannot lock the key.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If the operation is conditional and fails on the primary owner, Infinispan does not forward it to the other owners.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For transactional caches, primary owners can lock keys with optimistic and pessimistic locking modes.
Infinispan also supports different isolation levels to control concurrent reads between transactions.</p>
</div>
</div>
<div class="sect3">
<h4 id="the_lockmanager"><a class="anchor" href="#the_lockmanager"></a>7.1.2. The LockManager</h4>
<div class="paragraph">
<p>The <code>LockManager</code> is a component that is responsible for locking an entry for writing.
The <code>LockManager</code> makes use of a <code>LockContainer</code> to locate/hold/create locks.
<code>LockContainers</code> come in two broad flavours, with support for lock striping and with support for one lock per entry.</p>
</div>
</div>
<div class="sect3">
<h4 id="lock_striping"><a class="anchor" href="#lock_striping"></a>7.1.3. Lock striping</h4>
<div class="paragraph">
<p>Lock striping entails the use of a fixed-size, shared collection of locks for the entire cache, with locks being allocated to entries based on the entry&#8217;s key&#8217;s hash code.
Similar to the way the JDK&#8217;s <code>ConcurrentHashMap</code> allocates locks, this allows for a highly scalable, fixed-overhead locking mechanism in exchange for potentially unrelated entries being blocked by the same lock.</p>
</div>
<div class="paragraph">
<p>The alternative is to disable lock striping - which would mean a <em>new</em> lock is created per entry.
This approach <em>may</em> give you greater concurrent throughput, but it will be at the cost of additional memory usage, garbage collection churn, etc.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">Default lock striping settings</div>
lock striping is disabled by default, due to potential deadlocks that can happen if locks for different keys end up in the same lock stripe.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The size of the shared lock collection used by lock striping can be tuned using the <code>concurrencyLevel</code> attribute of the <code>&lt;locking /&gt;</code> configuration element.</p>
</div>
<div class="paragraph">
<p><strong>Configuration example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-xml" data-lang="xml">&lt;locking striping="false|true"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">new ConfigurationBuilder().locking().useLockStriping(false|true);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="concurrency_levels"><a class="anchor" href="#concurrency_levels"></a>7.1.4. Concurrency levels</h4>
<div class="paragraph">
<p>In addition to determining the size of the striped lock container, this concurrency level is also used to tune any JDK <code>ConcurrentHashMap</code> based collections where related, such as internal to <code>DataContainer</code>s.
Please refer to the JDK <code>ConcurrentHashMap</code> Javadocs for a detailed discussion of concurrency levels, as this parameter is used in exactly the same way in Infinispan.</p>
</div>
<div class="paragraph">
<p><strong>Configuration example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-xml" data-lang="xml">&lt;locking concurrency-level="32"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">new ConfigurationBuilder().locking().concurrencyLevel(32);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="lock_timeout"><a class="anchor" href="#lock_timeout"></a>7.1.5. Lock timeout</h4>
<div class="paragraph">
<p>The lock timeout specifies the amount of time, in milliseconds, to wait for a contented lock.</p>
</div>
<div class="paragraph">
<p><strong>Configuration example:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-xml" data-lang="xml">&lt;locking acquire-timeout="10000"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">new ConfigurationBuilder().locking().lockAcquisitionTimeout(10000);
//alternatively
new ConfigurationBuilder().locking().lockAcquisitionTimeout(10, TimeUnit.SECONDS);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="consistency"><a class="anchor" href="#consistency"></a>7.1.6. Consistency</h4>
<div class="paragraph">
<p>The fact that a single owner is locked (as opposed to all owners being locked) does not break the following consistency guarantee:
if key <code>K</code> is hashed to nodes <code>{A, B}</code> and transaction <code>TX1</code> acquires a lock for <code>K</code>, let&#8217;s say on <code>A</code>.
If another transaction, <code>TX2</code>, is started on <code>B</code> (or any other node) and <code>TX2</code> tries to lock <code>K</code> then it will fail with a timeout as the lock is already held by <code>TX1</code>.
The reason for this is the that the lock for a key <code>K</code> is always, deterministically, acquired on the same node of the cluster, regardless of where the transaction originates.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="data_versioning"><a class="anchor" href="#data_versioning"></a>7.2. Data Versioning</h3>
<div class="paragraph">
<p>Infinispan supports two forms of data versioning: simple and external.
The simple versioning is used in transactional caches for write skew check.</p>
</div>
<div class="paragraph">
<p>The external versioning is used to encapsulate an external source of data versioning within Infinispan, such as when using Infinispan with Hibernate which in turn gets its data version information directly from a database.</p>
</div>
<div class="paragraph">
<p>In this scheme, a mechanism to pass in the version becomes necessary, and overloaded versions of <code>put()</code> and <code>putForExternalRead()</code> will be provided in <code>AdvancedCache</code> to take in an external data version.
This is then stored on the <code>InvocationContext</code> and applied to the entry at commit time.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Write skew checks cannot and will not be performed in the case of external data versioning.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="transaction_manager"><a class="anchor" href="#transaction_manager"></a>8. Transactions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Infinispan can be configured to use and to participate in JTA compliant transactions.</p>
</div>
<div class="paragraph">
<p>Alternatively, if transaction support is disabled, it is equivalent to using autocommit in JDBC calls, where modifications are potentially replicated after every change (if replication is enabled).</p>
</div>
<div class="paragraph">
<p>On every cache operation Infinispan does the following:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Retrieves the current <a href="https://docs.oracle.com/javaee/7/api/javax/transaction/Transaction.html">Transaction</a> associated with the thread</p>
</li>
<li>
<p>If not already done, registers <a href="https://docs.oracle.com/javaee/7/api/javax/transaction/xa/XAResource.html">XAResource</a> with the transaction manager to be notified when a transaction commits or is rolled back.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In order to do this, the cache has to be provided with a reference to the environment&#8217;s <a href="https://docs.oracle.com/javaee/7/api/javax/transaction/TransactionManager.html">TransactionManager</a>.
This is usually done by configuring the cache with the class name of an implementation of the <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/transaction/lookup/TransactionManagerLookup.html">TransactionManagerLookup</a> interface.
When the cache starts, it will create an instance of this class and invoke its <code>getTransactionManager()</code> method, which returns a reference to the <code>TransactionManager</code>.</p>
</div>
<div class="paragraph">
<p>Infinispan ships with several transaction manager lookup classes:</p>
</div>
<div class="ulist">
<div class="title">Transaction manager lookup implementations</div>
<ul>
<li>
<p><a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/transaction/lookup/EmbeddedTransactionManagerLookup.html">EmbeddedTransactionManagerLookup</a>:
This provides with a basic transaction manager which should only be used for embedded mode when no other implementation is available.
This implementation has some severe limitations to do with concurrent transactions and recovery.</p>
</li>
<li>
<p><a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/transaction/lookup/JBossStandaloneJTAManagerLookup.html">JBossStandaloneJTAManagerLookup</a>:
If you&#8217;re running Infinispan in a standalone environment, or in JBoss AS 7 and earlier, and WildFly 8, 9, and 10, this should be your default choice for transaction manager.
It&#8217;s a fully fledged transaction manager based on <a href="http://narayana.io/">JBoss Transactions</a> which overcomes all the deficiencies of the <code>EmbeddedTransactionManager</code>.</p>
</li>
<li>
<p><a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/transaction/lookup/WildflyTransactionManagerLookup.html">WildflyTransactionManagerLookup</a>:
If you&#8217;re running Infinispan in WildFly 11 or later, this should be your default choice for transaction manager.</p>
</li>
<li>
<p><a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/transaction/lookup/GenericTransactionManagerLookup.html">GenericTransactionManagerLookup</a>:
This is a lookup class that locate transaction managers in the most popular Java EE application servers.
If no transaction manager can be found, it defaults on the <code>EmbeddedTransactionManager</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>WARN: <code>DummyTransactionManagerLookup</code> has been deprecated in 9.0 and it will be removed in the future.
Use <code>EmbeddedTransactionManagerLookup</code> instead.</p>
</div>
<div class="paragraph">
<p>Once initialized, the <code>TransactionManager</code> can also be obtained from the <code>Cache</code> itself:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">//the cache must have a transactionManagerLookupClass defined
Cache cache = cacheManager.getCache();

//equivalent with calling TransactionManagerLookup.getTransactionManager();
TransactionManager tm = cache.getAdvancedCache().getTransactionManager();</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="tx_configuration"><a class="anchor" href="#tx_configuration"></a>8.1. Configuring transactions</h3>
<div class="paragraph">
<p>Transactions are configured at cache level.
Below is the configuration that affects a transaction behaviour and a small description of each configuration attribute.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-xml" data-lang="xml">&lt;locking
   isolation="READ_COMMITTED"/&gt;
&lt;transaction
   locking="OPTIMISTIC"
   auto-commit="true"
   complete-timeout="60000"
   mode="NONE"
   notifications="true"
   reaper-interval="30000"
   recovery-cache="__recoveryInfoCacheName__"
   stop-timeout="30000"
   transaction-manager-lookup="org.infinispan.transaction.lookup.GenericTransactionManagerLookup"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>or programmatically:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ConfigurationBuilder builder = new ConfigurationBuilder();
builder.locking()
    .isolationLevel(IsolationLevel.READ_COMMITTED);
builder.transaction()
    .lockingMode(LockingMode.OPTIMISTIC)
    .autoCommit(true)
    .completedTxTimeout(60000)
    .transactionMode(TransactionMode.NON_TRANSACTIONAL)
    .useSynchronization(false)
    .notifications(true)
    .reaperWakeUpInterval(30000)
    .cacheStopTimeout(30000)
    .transactionManagerLookup(new GenericTransactionManagerLookup())
    .recovery()
    .enabled(false)
    .recoveryInfoCacheName("__recoveryInfoCacheName__");</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>isolation</code> - configures the isolation level. Check section <a href="#tx_isolation_levels">Isolation Levels</a> for more details.
Default is <code>REPEATABLE_READ</code>.</p>
</li>
<li>
<p><code>locking</code> - configures whether the cache uses optimistic or pessimistic locking. Check section <a href="#tx_locking">Transaction Locking</a> for more details.
Default is <code>OPTIMISTIC</code>.</p>
</li>
<li>
<p><code>auto-commit</code> - if enable, the user does not need to start a transaction manually for a single operation. The transaction is automatically started and committed.
Default is <code>true</code>.</p>
</li>
<li>
<p><code>complete-timeout</code> - the duration in milliseconds to keep information about completed transactions. Default is <code>60000</code>.</p>
</li>
<li>
<p><code>mode</code> - configures whether the cache is transactional or not. Default is <code>NONE</code>. The available options are:</p>
<div class="ulist">
<ul>
<li>
<p><code>NONE</code> - non transactional cache</p>
</li>
<li>
<p><code>FULL_XA</code> - XA transactional cache with recovery enabled. Check section <a href="#tx_recovery">Transaction recovery</a> for more details about recovery.</p>
</li>
<li>
<p><code>NON_DURABLE_XA</code> - XA transactional cache with recovery disabled.</p>
</li>
<li>
<p><code>NON_XA</code> - transactional cache with integration via <a href="https://docs.oracle.com/javaee/7/api/javax/transaction/Synchronization.html">Synchronization</a> instead of XA.
Check section <a href="#tx_sync_enlist">Enlisting Synchronizations</a> for details.</p>
</li>
<li>
<p><code>BATCH</code>-  transactional cache using batch to group operations. Check section <a href="#tx_batching">Batching</a> for details.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>notifications</code> - enables/disables triggering transactional events in cache listeners. Default is <code>true</code>.</p>
</li>
<li>
<p><code>reaper-interval</code> - the time interval in millisecond at which the thread that cleans up transaction completion information kicks in.
Defaults is <code>30000</code>.</p>
</li>
<li>
<p><code>recovery-cache</code> - configures the cache name to store the recovery information. Check section <a href="#tx_recovery">Transaction recovery</a> for more details about recovery.
Default is <code><em>recoveryInfoCacheName</em></code>.</p>
</li>
<li>
<p><code>stop-timeout</code> - the time in millisecond to wait for ongoing transaction when the cache is stopping. Default is  <code>30000</code>.</p>
</li>
<li>
<p><code>transaction-manager-lookup</code> - configures the fully qualified class name of a class that looks up a reference to a <code>javax.transaction.TransactionManager</code>.
Default is <code>org.infinispan.transaction.lookup.GenericTransactionManagerLookup</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For more details on how Two-Phase-Commit (2PC) is implemented in Infinispan and how locks are being acquired see the section below.
More details about the configuration settings are available in <a href="https://docs.jboss.org/infinispan/14.0/configdocs/">Configuration reference</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="tx_isolation_levels"><a class="anchor" href="#tx_isolation_levels"></a>8.2. Isolation levels</h3>
<div class="paragraph">
<p>Infinispan offers two isolation levels - <a href="https://en.wikipedia.org/wiki/Isolation_(database_systems)#Read_committed">READ_COMMITTED</a> and <a href="https://en.wikipedia.org/wiki/Isolation_(database_systems)#Repeatable_reads">REPEATABLE_READ</a>.</p>
</div>
<div class="paragraph">
<p>These isolation levels determine when readers see a concurrent write, and are internally implemented using different subclasses of <code>MVCCEntry</code>, which have different behaviour in how state is committed back to the data container.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s a more detailed example that should help understand the difference between <code>READ_COMMITTED</code> and <code>REPEATABLE_READ</code> in the context of Infinispan.
With <code>READ_COMMITTED</code>, if between two consecutive read calls on the same key, the key has been updated by another transaction, the second read may return the new updated value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Thread1: tx1.begin()
Thread1: cache.get(k) // returns v
Thread2:                                       tx2.begin()
Thread2:                                       cache.get(k) // returns v
Thread2:                                       cache.put(k, v2)
Thread2:                                       tx2.commit()
Thread1: cache.get(k) // returns v2!
Thread1: tx1.commit()</code></pre>
</div>
</div>
<div class="paragraph">
<p>With <code>REPEATABLE_READ</code>, the final get will still return <code>v</code>.
So, if you&#8217;re going to retrieve the same key multiple times within a transaction, you should use <code>REPEATABLE_READ</code>.</p>
</div>
<div class="paragraph">
<p>However, as read-locks are not acquired even for <code>REPEATABLE_READ</code>, this phenomena can occur:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">cache.get("A") // returns 1
cache.get("B") // returns 1

Thread1: tx1.begin()
Thread1: cache.put("A", 2)
Thread1: cache.put("B", 2)
Thread2:                                       tx2.begin()
Thread2:                                       cache.get("A") // returns 1
Thread1: tx1.commit()
Thread2:                                       cache.get("B") // returns 2
Thread2:                                       tx2.commit()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tx_locking"><a class="anchor" href="#tx_locking"></a>8.3. Transaction locking</h3>
<div class="sect3">
<h4 id="pessimistic_transactional_cache"><a class="anchor" href="#pessimistic_transactional_cache"></a>8.3.1. Pessimistic transactional cache</h4>
<div class="paragraph">
<p>From a lock acquisition perspective, pessimistic transactions obtain locks on keys at the time the key is written.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A lock request is sent to the primary owner (can be an explicit lock request or an operation)</p>
</li>
<li>
<p>The primary owner tries to acquire the lock:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>If it succeed, it sends back a positive reply;</p>
</li>
<li>
<p>Otherwise, a negative reply is sent and the transaction is rollback.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>As an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">transactionManager.begin();
cache.put(k1,v1); //k1 is locked.
cache.remove(k2); //k2 is locked when this returns
transactionManager.commit();</code></pre>
</div>
</div>
<div class="paragraph">
<p>When <code>cache.put(k1,v1)</code> returns, <code>k1</code> is locked and no other transaction running anywhere in the cluster can write to it.
Reading <code>k1</code> is still possible.
The lock on <code>k1</code> is released when the transaction completes (commits or rollbacks).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For conditional operations, the validation is performed in the originator.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="optimistic_transactional_cache"><a class="anchor" href="#optimistic_transactional_cache"></a>8.3.2. Optimistic transactional cache</h4>
<div class="paragraph">
<p>With optimistic transactions locks are being acquired at transaction prepare time and are only being held up to the point the transaction commits (or rollbacks).
This is different from the 5.0 default locking model where local locks are being acquire on writes and cluster locks are being acquired during prepare time.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The prepare is sent to all the owners.</p>
</li>
<li>
<p>The primary owners try to acquire the locks needed:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>If locking succeeds, it performs the write skew check.</p>
</li>
<li>
<p>If the write skew check succeeds (or is disabled), send a positive reply.</p>
</li>
<li>
<p>Otherwise, a negative reply is sent and the transaction is rolled back.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>As an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">transactionManager.begin();
cache.put(k1,v1);
cache.remove(k2);
transactionManager.commit(); //at prepare time, K1 and K2 is locked until committed/rolled back.</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For conditional commands, the validation still happens on the originator.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="what_do_i_need_pessimistic_or_optimistic_transactions"><a class="anchor" href="#what_do_i_need_pessimistic_or_optimistic_transactions"></a>8.3.3. What do I need - pessimistic or optimistic transactions?</h4>
<div class="paragraph">
<p>From a use case perspective, optimistic transactions should be used when there is <em>not</em> a lot of contention between multiple transactions running at the same time.
That is because the optimistic transactions rollback if data has changed between the time it was read and the time it was committed (with write skew check enabled).</p>
</div>
<div class="paragraph">
<p>On the other hand, pessimistic transactions might be a better fit when there is high contention on the keys and transaction rollbacks are less desirable.
Pessimistic transactions are more costly by their nature: each write operation potentially involves a RPC for lock acquisition.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tx_write_skew"><a class="anchor" href="#tx_write_skew"></a>8.4. Write Skews</h3>
<div class="paragraph">
<p>Write skews occur when two transactions independently and simultaneously read and write to the same key. The result of a write skew is that both transactions successfully commit updates to the same key but with different values.</p>
</div>
<div class="paragraph">
<p>Infinispan automatically performs write skew checks to ensure data consistency for <code>REPEATABLE_READ</code> isolation levels in optimistic transactions. This allows Infinispan to detect and roll back one of the transactions.</p>
</div>
<div class="paragraph">
<p>When operating in <code>LOCAL</code> mode, write skew checks rely on Java object
references to compare differences, which provides a reliable technique for
checking for write skews.</p>
</div>
<div class="sect3">
<h4 id="forcing_write_locks_on_keys_in_pessimitic_transactions"><a class="anchor" href="#forcing_write_locks_on_keys_in_pessimitic_transactions"></a>8.4.1. Forcing write locks on keys in pessimitic transactions</h4>
<div class="paragraph">
<p>To avoid write skews with pessimistic transactions, lock keys at read-time with <code>Flag.FORCE_WRITE_LOCK</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p>In non-transactional caches, <code>Flag.FORCE_WRITE_LOCK</code> does not work. The <code>get()</code> call reads the key value but does not acquire locks remotely.</p>
</li>
<li>
<p>You should use <code>Flag.FORCE_WRITE_LOCK</code> with transactions in which the entity is updated later in the same transaction.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Compare the following code snippets for an example of <code>Flag.FORCE_WRITE_LOCK</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// begin the transaction
if (!cache.getAdvancedCache().lock(key)) {
   // abort the transaction because the key was not locked
} else {
   cache.get(key);
   cache.put(key, value);
   // commit the transaction
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// begin the transaction
try {
   // throws an exception if the key is not locked.
   cache.getAdvancedCache().withFlags(Flag.FORCE_WRITE_LOCK).get(key);
   cache.put(key, value);
} catch (CacheException e) {
   // mark the transaction rollback-only
}
// commit or rollback the transaction</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dealing_with_exceptions"><a class="anchor" href="#dealing_with_exceptions"></a>8.5. Dealing with exceptions</h3>
<div class="paragraph">
<p>If a <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/commons/CacheException.html">CacheException</a> (or a subclass of it) is thrown by a cache method within the scope of a JTA transaction, then the transaction is automatically marked for rollback.</p>
</div>
</div>
<div class="sect2">
<h3 id="tx_sync_enlist"><a class="anchor" href="#tx_sync_enlist"></a>8.6. Enlisting Synchronizations</h3>
<div class="paragraph">
<p>By default Infinispan registers itself as a first class participant in distributed transactions through <a href="https://docs.oracle.com/javaee/7/api/javax/transaction/xa/XAResource.html">XAResource</a>.
There are situations where Infinispan is not required to be a participant in the transaction, but only to be notified by its lifecycle (prepare, complete): e.g. in the case Infinispan is used as a 2nd level cache in Hibernate.</p>
</div>
<div class="paragraph">
<p>Infinispan allows transaction enlistment through <a href="https://docs.oracle.com/javaee/7/api/javax/transaction/Synchronization.html">Synchronization</a>.
To enable it just use <code>NON_XA</code> transaction mode.</p>
</div>
<div class="paragraph">
<p><code>Synchronization</code>s have the advantage that they allow <code>TransactionManager</code> to optimize 2PC with a 1PC where only one other resource is enlisted with that transaction (<a href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.0/html/development_guide/java_transaction_api_jta#about_the_lrco_optimization_for_single_phase_commit_1pc">last resource commit optimization</a>).
E.g. Hibernate second level cache: if Infinispan registers itself with the <code>TransactionManager</code> as a <code>XAResource</code> than at commit time, the <code>TransactionManager</code> sees two <code>XAResource</code> (cache and database) and does not make this optimization.
Having to coordinate between two resources it needs to write the tx log to disk.
On the other hand, registering Infinispan as a <code>Synchronization</code> makes the <code>TransactionManager</code> skip writing the log to the disk (performance improvement).</p>
</div>
</div>
<div class="sect2">
<h3 id="tx_batching"><a class="anchor" href="#tx_batching"></a>8.7. Batching</h3>
<div class="paragraph">
<p>Batching allows atomicity and some characteristics of a transaction, but not full-blown JTA or XA capabilities.
Batching is often a lot lighter and cheaper than a full-blown transaction.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Generally speaking, one should use batching API whenever the only participant in the transaction is an Infinispan cluster.
On the other hand, JTA transactions (involving <code>TransactionManager</code>) should be used whenever the transactions involves multiple systems.
E.g. considering the "Hello world!" of transactions: transferring money from one bank account to the other.
If both accounts are stored within Infinispan, then batching can be used.
If one account is in a database and the other is Infinispan, then distributed transactions are required.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You <em>do not</em> have to have a transaction manager defined to use batching.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="api"><a class="anchor" href="#api"></a>8.7.1. API</h4>
<div class="paragraph">
<p>Once you have configured your cache to use batching, you use it by calling <code>startBatch()</code> and <code>endBatch()</code> on <code>Cache</code>. E.g.,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Cache cache = cacheManager.getCache();
// not using a batch
cache.put("key", "value"); // will replicate immediately

// using a batch
cache.startBatch();
cache.put("k1", "value");
cache.put("k2", "value");
cache.put("k2", "value");
cache.endBatch(true); // This will now replicate the modifications since the batch was started.

// a new batch
cache.startBatch();
cache.put("k1", "value");
cache.put("k2", "value");
cache.put("k3", "value");
cache.endBatch(false); // This will "discard" changes made in the batch</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="batching_and_jta"><a class="anchor" href="#batching_and_jta"></a>8.7.2. Batching and JTA</h4>
<div class="paragraph">
<p>Behind the scenes, the batching functionality starts a JTA transaction, and all the invocations in that scope are associated with it.
For this it uses a very simple (e.g. no recovery) internal <code>TransactionManager</code> implementation.
With batching, you get:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Locks you acquire during an invocation are held until the batch completes</p>
</li>
<li>
<p>Changes are all replicated around the cluster in a batch as part of the batch completion process. Reduces replication chatter for each update in the batch.</p>
</li>
<li>
<p>If synchronous replication or invalidation are used, a failure in replication/invalidation will cause the batch to roll back.</p>
</li>
<li>
<p>All the transaction related configurations apply for batching as well.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tx_recovery"><a class="anchor" href="#tx_recovery"></a>8.8. Transaction recovery</h3>
<div class="paragraph">
<p>Recovery is a feature of XA transactions, which deal with the eventuality of a resource or possibly even the transaction manager failing, and recovering accordingly from such a situation.</p>
</div>
<div class="sect3">
<h4 id="when_to_use_recovery"><a class="anchor" href="#when_to_use_recovery"></a>8.8.1. When to use recovery</h4>
<div class="paragraph">
<p>Consider a distributed transaction in which money is transferred from an account stored in an external database to an account stored in Infinispan.
When <code>TransactionManager.commit()</code> is invoked, both resources prepare successfully (1st phase). During the commit (2nd) phase, the database successfully applies the changes whilst Infinispan fails before receiving the commit request from the transaction manager.
At this point the system is in an inconsistent state: money is taken from the account in the external database but not visible yet in Infinispan (since locks are only released during 2nd phase of a two-phase commit protocol).
Recovery deals with this situation to make sure data in both the database and Infinispan ends up in a consistent state.</p>
</div>
</div>
<div class="sect3">
<h4 id="how_does_it_work"><a class="anchor" href="#how_does_it_work"></a>8.8.2. How does it work</h4>
<div class="paragraph">
<p>Recovery is coordinated by the transaction manager.
The transaction manager works with Infinispan to determine the list of in-doubt transactions that require manual intervention and informs the system administrator (via email, log alerts, etc).
This process is transaction manager specific, but generally requires some configuration on the transaction manager.  </p>
</div>
<div class="paragraph">
<p>Knowing the in-doubt transaction ids, the system administrator can now connect to the Infinispan cluster and replay the commit of transactions or force the rollback.
Infinispan provides JMX tooling for this - this is explained extensively in the <a href="#tx_recovery_reconciliation">Transaction recovery and reconciliation</a> section.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuring_recovery"><a class="anchor" href="#configuring_recovery"></a>8.8.3. Configuring recovery   </h4>
<div class="paragraph">
<p>Recovery is <em>not</em> enabled by default in Infinispan.
If disabled, the <code>TransactionManager</code> won&#8217;t be able to work with Infinispan to determine the in-doubt transactions.
The <a href="#tx_configuration">Transaction configuration</a> section shows how to enable it.</p>
</div>
<div class="paragraph">
<p>NOTE: <code>recovery-cache</code> attribute is not mandatory and it is configured per-cache.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For recovery to work, <code>mode</code> must be set to <code>FULL_XA</code>, since full-blown XA transactions are needed.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="enable_jmx_support"><a class="anchor" href="#enable_jmx_support"></a>Enable JMX support</h5>
<div class="paragraph">
<p>In order to be able to use JMX for managing recovery JMX support must be explicitly enabled.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="recovery_cache"><a class="anchor" href="#recovery_cache"></a>8.8.4. Recovery cache</h4>
<div class="paragraph">
<p>In order to track in-doubt transactions and be able to reply them, Infinispan caches all transaction state for future use.
This state is held only for in-doubt transaction, being removed for successfully completed transactions after when the commit/rollback phase completed.</p>
</div>
<div class="paragraph">
<p>This in-doubt transaction data is held within a local cache: this allows one to configure swapping this info to disk through cache loader in the case it gets too big.
This cache can be specified through the <code>recovery-cache</code> configuration attribute.
If not specified Infinispan will configure a local cache for you.</p>
</div>
<div class="paragraph">
<p>It is possible (though not mandated) to share same recovery cache between all the Infinispan caches that have recovery enabled.
If the default recovery cache is overridden, then the specified recovery cache must use a <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/transaction/lookup/TransactionManagerLookup.html">TransactionManagerLookup</a> that returns a different transaction manager than the one used by the cache itself.</p>
</div>
</div>
<div class="sect3">
<h4 id="integration_with_the_transaction_manager"><a class="anchor" href="#integration_with_the_transaction_manager"></a>8.8.5. Integration with the transaction manager</h4>
<div class="paragraph">
<p>Even though this is transaction manager specific, generally a transaction manager would need a reference to a <code>XAResource</code> implementation in order to invoke <code>XAResource.recover()</code> on it.
In order to obtain a reference to an Infinispan <code>XAResource</code> following API can be used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">XAResource xar = cache.getAdvancedCache().getXAResource();</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is a common practice to run the recovery in a different process from the one running the transaction.</p>
</div>
</div>
<div class="sect3">
<h4 id="tx_recovery_reconciliation"><a class="anchor" href="#tx_recovery_reconciliation"></a>8.8.6. Reconciliation</h4>
<div class="paragraph">
<p>The transaction manager informs the system administrator on in-doubt transaction in a proprietary way.
At this stage it is assumed that the system administrator knows transaction&#8217;s XID (a byte array).</p>
</div>
<div class="paragraph">
<p>A normal recovery flow is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>STEP 1</strong>: The system administrator connects to an Infinispan server through JMX, and lists the in doubt transactions.
The image below demonstrates JConsole connecting to an Infinispan node that has an in doubt transaction.</p>
</li>
</ul>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../../topics/images/showInDoubtTx.png" alt="showInDoubtTx">
</div>
<div class="title">Figure 1. Show in-doubt transactions</div>
</div>
<div class="paragraph">
<p>The status of each in-doubt transaction is displayed(in this example " <em>PREPARED</em> ").
There might be multiple elements in the status field, e.g. "PREPARED" and "COMMITTED" in the case the transaction committed on certain nodes but not on all of them.  </p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>STEP 2</strong>: The system administrator visually maps the XID received from the transaction manager to an Infinispan internal id, represented as a number.
This step is needed because the XID, a byte array, cannot conveniently be passed to the JMX tool (e.g. JConsole) and then re-assembled on Infinispan&#8217;s side.</p>
</li>
<li>
<p><strong>STEP 3</strong>: The system administrator forces the transaction&#8217;s commit/rollback through the corresponding jmx operation, based on the internal id.
The image below is obtained by forcing the commit of the transaction based on its internal id.</p>
</li>
</ul>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../../topics/images/forceCommit.png" alt="forceCommit">
</div>
<div class="title">Figure 2. Force commit</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
All JMX operations described above can be executed on any node, regardless of where the transaction originated.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="force_commitrollback_based_on_xid"><a class="anchor" href="#force_commitrollback_based_on_xid"></a>Force commit/rollback based on XID</h5>
<div class="paragraph">
<p>XID-based JMX operations for forcing in-doubt transactions' commit/rollback are available as well: these methods receive byte[] arrays describing the XID instead of the number associated with the transactions (as previously described at step 2).
These can be useful e.g. if one wants to set up an automatic completion job for certain in-doubt transactions.
This process is plugged into transaction manager&#8217;s recovery and has access to the transaction manager&#8217;s XID objects.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="functional_map_api"><a class="anchor" href="#functional_map_api"></a>9. Functional Map API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Infinispan provides an experimental API for interacting with your
data which takes advantage of the functional programming additions and
improved asynchronous programming capabilities available in Java 8.</p>
</div>
<div class="paragraph">
<p>Infinispan&#8217;s <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/FunctionalMap.html">Functional Map API</a>
is a distilled map-like asynchronous API which uses functions to interact with data.</p>
</div>
<div class="sect2">
<h3 id="asynchronous_and_lazy"><a class="anchor" href="#asynchronous_and_lazy"></a>9.1. Asynchronous and Lazy</h3>
<div class="paragraph">
<p>Being an asynchronous API, all methods that return a single result,
return a CompletableFuture which wraps the result, so you can use the
resources of your system more efficiently by having the possibility to
receive callbacks when the
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html"><code>CompletableFuture</code></a>
has completed, or you can chain or compose them with other CompletableFuture.</p>
</div>
<div class="paragraph">
<p>For those operations that return multiple results, the API returns instances of a <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/Traversable.html">Traversable</a> interface which offers a lazy pull-style API for working with multiple results.</p>
</div>
<div class="paragraph">
<p><code>Traversable</code>, being a lazy pull-style API, can still be asynchronous underneath since the user can decide to work on the traversable at a later stage, and the <code>Traversable</code> implementation itself can decide when to compute those results.</p>
</div>
</div>
<div class="sect2">
<h3 id="function_transparency"><a class="anchor" href="#function_transparency"></a>9.2. Function transparency</h3>
<div class="paragraph">
<p>Since the content of the functions is transparent to Infinispan, the API
has been split into 3 interfaces for read-only (
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/FunctionalMap.ReadOnlyMap.html"><code>ReadOnlyMap</code></a>
), read-write (
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/FunctionalMap.ReadWriteMap.html"><code>ReadWriteMap</code></a>
) and write-only (
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/FunctionalMap.WriteOnlyMap.html"><code>WriteOnlyMap</code></a>
) operations respectively, in order to provide hints to the Infinispan
internals on the type of work needed to support functions.</p>
</div>
</div>
<div class="sect2">
<h3 id="constructing_functional_maps"><a class="anchor" href="#constructing_functional_maps"></a>9.3. Constructing Functional Maps</h3>
<div class="paragraph">
<p>To construct any of the read-only, write-only or read-write map
instances, an Infinispan
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/AdvancedCache.html"><code>AdvancedCache</code></a>
is required, which is retrieved from the Cache Manager, and using the
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/AdvancedCache.html"><code>AdvancedCache</code></a>
, static method
factory methods are used to create
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/FunctionalMap.ReadOnlyMap.html"><code>ReadOnlyMap</code></a>
,
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/FunctionalMap.ReadWriteMap.html"><code>ReadWriteMap</code></a>
or
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/FunctionalMap.WriteOnlyMap.html"><code>WriteOnlyMap</code></a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.infinispan.functional.FunctionalMap.*;
import org.infinispan.functional.impl.*;
import org.infinispan.AdvancedCache;

AdvancedCache&lt;String, String&gt; cache = ...

FunctionalMapImpl&lt;String, String&gt; functionalMap = FunctionalMapImpl.create(cache);
ReadOnlyMap&lt;String, String&gt; readOnlyMap = ReadOnlyMapImpl.create(functionalMap);
WriteOnlyMap&lt;String, String&gt; writeOnlyMap = WriteOnlyMapImpl.create(functionalMap);
ReadWriteMap&lt;String, String&gt; readWriteMap = ReadWriteMapImpl.create(functionalMap);</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
At this stage, the Functional Map API is experimental and hence the
way FunctionalMap, ReadOnlyMap, WriteOnlyMap and ReadWriteMap are constructed
is temporary.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="read_only_map_api"><a class="anchor" href="#read_only_map_api"></a>9.4. Read-Only Map API</h3>
<div class="paragraph">
<p>Read-only operations have the advantage that no locks are acquired
for the duration of the operation. Here&#8217;s an example on how to the
equivalent operation for
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#get-java.lang.Object-">Map.get(K)</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.infinispan.functional.EntryView.ReadEntryView;
import org.infinispan.functional.FunctionalMap.ReadOnlyMap;

ReadOnlyMap&lt;String, String&gt; readOnlyMap = ...
CompletableFuture&lt;Optional&lt;String&gt;&gt; readFuture = readOnlyMap.eval("key1", ReadEntryView::find);
readFuture.thenAccept(System.out::println);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Read-only map also exposes operations to retrieve multiple keys in one go:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.infinispan.functional.EntryView.*;
import org.infinispan.functional.FunctionalMap.*;
import org.infinispan.functional.Traversable;

ReadOnlyMap&lt;String, String&gt; readOnlyMap = ...

Set&lt;String&gt; keys = new HashSet&lt;&gt;(Arrays.asList("key1", "key2"));
Traversable&lt;String&gt; values = readOnlyMap.evalMany(keys, ReadEntryView::get);
values.forEach(System.out::println);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, read-only map also exposes methods to read all existing keys as well
as entries, which include both key and value information.</p>
</div>
<div class="sect3">
<h4 id="read_only_entry_view"><a class="anchor" href="#read_only_entry_view"></a>9.4.1. Read-Only Entry View</h4>
<div class="paragraph">
<p>The function parameters for read-only maps provide the user with a
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/EntryView.ReadEntryView.html">read-only entry view</a>
to interact with the data in the cache, which include these operations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/EntryView.ReadEntryView.html#key()"><code>key()</code></a>
method returns the key for which this function is being executed.</p>
</li>
<li>
<p><a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/EntryView.ReadEntryView.html#find()"><code>find()</code></a>
returns a Java 8 <code>Optional</code> wrapping the value if present,
otherwise it returns an empty optional. Unless the value is guaranteed to
be associated with the key, it&#8217;s recommended to use <code>find()</code> to verify
whether there&#8217;s a value associated with the key.</p>
</li>
<li>
<p><a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/EntryView.ReadEntryView.html#get()"><code>get()</code></a>
returns the value associated with the key. If the key has no value
associated with it, calling <code>get()</code> throws a <code>NoSuchElementException</code>.
<code>get()</code> can be considered as a shortcut of <code>ReadEntryView.find().get()</code>
which should be used only when the caller has guarantees that there&#8217;s
definitely a value associated with the key.</p>
</li>
<li>
<p><a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/MetaParam.Lookup.html#findMetaParam(java.lang.Class)"><code>findMetaParam(Class&lt;T&gt; type)</code></a>
allows metadata parameter information
associated with the cache entry to be looked up, for example: entry
lifespan, last  accessed time&#8230;&#8203;etc.
See <a href="#meta_parameter">Metadata Parameter Handling</a> to find out more.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="write_only_map_api"><a class="anchor" href="#write_only_map_api"></a>9.5. Write-Only Map API</h3>
<div class="paragraph">
<p>Write-only operations include operations that insert or update data in the
cache and also removals. Crucially, a write-only operation does not attempt
to read any previous value associated with the key. This is an important
optimization since that means neither the cluster nor any persistence stores
will be looked up to retrieve previous values. In the main Infinispan Cache,
this kind of optimization was achieved using a local-only per-invocation
flag, but the use case is so common that in this new functional API, this
optimization is provided as a first-class citizen.</p>
</div>
<div class="paragraph">
<p>Using
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/FunctionalMap.WriteOnlyMap.html">write-only map API</a>
, an operation equivalent to
<a href="https://github.com/jsr107/jsr107spec/blob/v1.0.0/src/main/java/javax/cache/Cache.java"><code>javax.cache.Cache</code> (<code>JCache</code>)</a>
's void returning
<a href="https://github.com/jsr107/jsr107spec/blob/v1.0.0/src/main/java/javax/cache/Cache.java#L194"><code>put</code></a>
can be achieved this way, followed by an attempt to read the stored
value using the read-only map API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.infinispan.functional.EntryView.*;
import org.infinispan.functional.FunctionalMap.*;

WriteOnlyMap&lt;String, String&gt; writeOnlyMap = ...
ReadOnlyMap&lt;String, String&gt; readOnlyMap = ...

CompletableFuture&lt;Void&gt; writeFuture = writeOnlyMap.eval("key1", "value1",
   (v, view) -&gt; view.set(v));
CompletableFuture&lt;String&gt; readFuture = writeFuture.thenCompose(r -&gt;
   readOnlyMap.eval("key1", ReadEntryView::get));
readFuture.thenAccept(System.out::println);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Multiple key/value pairs can be stored in one go using
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/FunctionalMap.WriteOnlyMap.html#evalMany(java.util.Map,java.util.function.BiConsumer)"><code>evalMany</code></a>
API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">WriteOnlyMap&lt;String, String&gt; writeOnlyMap = ...

Map&lt;K, String&gt; data = new HashMap&lt;&gt;();
data.put("key1", "value1");
data.put("key2", "value2");
CompletableFuture&lt;Void&gt; writerAllFuture = writeOnlyMap.evalMany(data, (v, view) -&gt; view.set(v));
writerAllFuture.thenAccept(x -&gt; "Write completed");</code></pre>
</div>
</div>
<div class="paragraph">
<p>To remove all contents of the cache, there are two possibilities with
different semantics. If using
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/FunctionalMap.WriteOnlyMap.html#evalAll(java.util.function.Consumer)"><code>evalAll</code></a>
each cached entry is iterated over and the function is called
with that entry&#8217;s information. Using this method also results in listeners being invoked.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">WriteOnlyMap&lt;String, String&gt; writeOnlyMap = ...

CompletableFuture&lt;Void&gt; removeAllFuture = writeOnlyMap.evalAll(WriteEntryView::remove);
removeAllFuture.thenAccept(x -&gt; "All entries removed");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The alternative way to remove all entries is to call
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/FunctionalMap.WriteOnlyMap.html#truncate()"><code>truncate</code></a>
operation which clears the entire cache contents in one go without
invoking any listeners and is best-effort:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">WriteOnlyMap&lt;String, String&gt; writeOnlyMap = ...

CompletableFuture&lt;Void&gt; truncateFuture = writeOnlyMap.truncate();
truncateFuture.thenAccept(x -&gt; "Cache contents cleared");</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="write_only_entry_view"><a class="anchor" href="#write_only_entry_view"></a>9.5.1. Write-Only Entry View</h4>
<div class="paragraph">
<p>The function parameters for write-only maps provide the user with a
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/EntryView.WriteEntryView.html">write-only entry view</a>
to modify the data in the cache, which include these
operations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/EntryView.WriteEntryView.html#set(V,org.infinispan.functional.MetaParam.Writable&#8230;&#8203;)"><code>set(V, MetaParam.Writable&#8230;&#8203;)</code></a>
method allows for a new value to be
associated with the cache entry for which this function is executed, and it
optionally takes zero or more metadata parameters to be stored along with
the value. See <a href="#meta_parameter">Metadata Parameter Handling</a> for more information.</p>
</li>
<li>
<p><a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/EntryView.WriteEntryView.html#remove()"><code>remove()</code></a>
method removes the cache entry, including both value and metadata
parameters associated with this key.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="read_write_map_api"><a class="anchor" href="#read_write_map_api"></a>9.6. Read-Write Map API</h3>
<div class="paragraph">
<p>The final type of operations we have are read­write operations, and within
this category CAS-like (Compare­And­Swap) operations can be found.
This type of operations require previous value associated with the key
to be read and for locks to be acquired before executing the function.
The vast majority of operations within
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html"><code>ConcurrentMap</code></a>
and
<a href="https://github.com/jsr107/jsr107spec/blob/v1.0.0/src/main/java/javax/cache/Cache.java"><code>JCache</code></a>
APIs fall within this category, and they can easily be implemented using the
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/FunctionalMap.ReadWriteMap.html">read-write map API</a>
. Moreover, with
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/FunctionalMap.ReadWriteMap.html">read-write map API</a>
, you can make CAS­like comparisons not only based on value equality
but based on metadata parameter equality such as version information,
and you can send back previous value or boolean instances to signal
whether the CAS­like comparison succeeded.</p>
</div>
<div class="paragraph">
<p>Implementing a write operation that returns the previous value associated
with the cache entry is easy to achieve with the read-write map API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.infinispan.functional.EntryView.*;
import org.infinispan.functional.FunctionalMap.*;

ReadWriteMap&lt;String, String&gt; readWriteMap = ...

CompletableFuture&lt;Optional&lt;String&gt;&gt; readWriteFuture = readWriteMap.eval("key1", "value1",
   (v, view) -&gt; {
      Optional&lt;V&gt; prev = rw.find();
      view.set(v);
      return prev;
   });
readWriteFuture.thenAccept(System.out::println);</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html#replace-K-V-V-"><code>ConcurrentMap.replace(K, V, V)</code></a>
is a replace function that compares the
value present in the map and if it&#8217;s equals to the value passed in as
first parameter, the second value is stored, returning a boolean
indicating whether the replace was successfully completed. This operation
can easily be implemented using the read-write map API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ReadWriteMap&lt;String, String&gt; readWriteMap = ...

String oldValue = "old-value";
CompletableFuture&lt;Boolean&gt; replaceFuture = readWriteMap.eval("key1", "value1", (v, view) -&gt; {
   return view.find().map(prev -&gt; {
      if (prev.equals(oldValue)) {
         rw.set(v);
         return true; // previous value present and equals to the expected one
      }
      return false; // previous value associated with key does not match
   }).orElse(false); // no value associated with this key
});
replaceFuture.thenAccept(replaced -&gt; System.out.printf("Value was replaced? %s%n", replaced));</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The function in the example above captures <code>oldValue</code> which is an
external value to the function which is valid use case.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Read-write map API contains <code>evalMany</code> and <code>evalAll</code> operations which behave
similar to the write-only map offerings, except that they enable previous
value and metadata parameters to be read.</p>
</div>
<div class="sect3">
<h4 id="read_write_entry_view"><a class="anchor" href="#read_write_entry_view"></a>9.6.1. Read-Write Entry View</h4>
<div class="paragraph">
<p>The function parameters for read-write maps provide the user with the
possibility to query the information associated with the key, including
value and metadata parameters, and the user can also use this
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/EntryView.ReadWriteEntryView.html">read-write entry view</a>
to modify the data in the cache.</p>
</div>
<div class="paragraph">
<p>The operations are exposed by read-write entry views are a union of
the operations exposed by <a href="#read_only_entry_view">read-only entry views</a>
and <a href="#write_only_entry_view">write-only entry views</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="meta_parameter"><a class="anchor" href="#meta_parameter"></a>9.7. Metadata Parameter Handling</h3>
<div class="paragraph">
<p><a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/MetaParam.html">Metadata parameters</a>
provide extra information about the cache entry, such
as version information, lifespan, last accessed/used time&#8230;&#8203;etc. Some of
these can be provided by the user, e.g. version, lifespan&#8230;&#8203;etc, but some
others are computed internally and can only be queried, e.g. last
accessed/used time.</p>
</div>
<div class="paragraph">
<p>The functional map API provides a flexible way to store metadata parameters
along with an cache entry. To be able to store a metadata parameter, it must
extend
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/MetaParam.Lookup.html"><code>MetaParam.Writable</code></a>
interface, and implement the methods to allow the
internal logic to extra the data. Storing is done via the
<code>set(V, MetaParam.Writable&#8230;&#8203;)</code> method in the <a href="#write_only_entry_view">write-only entry view</a> or <a href="#read_write_entry_view">read-write entry view</a> function parameters.</p>
</div>
<div class="paragraph">
<p>Querying metadata parameters is available via the
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/MetaParam.Lookup.html#findMetaParam(java.lang.Class)"><code>findMetaParam(Class)</code></a>
method
available via <a href="#read_write_entry_view">read-write entry view</a> or
<a href="#read_only_entry_view">read-only entry views</a> or function parameters.</p>
</div>
<div class="paragraph">
<p>Here is an example showing how to store metadata parameters and how to query
them:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.time.Duration;
import org.infinispan.functional.EntryView.*;
import org.infinispan.functional.FunctionalMap.*;
import org.infinispan.functional.MetaParam.*;

WriteOnlyMap&lt;String, String&gt; writeOnlyMap = ...
ReadOnlyMap&lt;String, String&gt; readOnlyMap = ...

CompletableFuture&lt;Void&gt; writeFuture = writeOnlyMap.eval("key1", "value1",
   (v, view) -&gt; view.set(v, new MetaLifespan(Duration.ofHours(1).toMillis())));
CompletableFuture&lt;MetaLifespan&gt; readFuture = writeFuture.thenCompose(r -&gt;
   readOnlyMap.eval("key1", view -&gt; view.findMetaParam(MetaLifespan.class).get()));
readFuture.thenAccept(System.out::println);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the metadata parameter is generic, for example
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/MetaParam.MetaEntryVersion.html"><code>MetaEntryVersion&lt;T&gt;</code></a>
, retrieving the metadata parameter along with a specific type can be tricky
if using <code>.class</code> static helper in a class because it does not return a
<code>Class&lt;T&gt;</code> but only <code>Class</code>, and hence any generic information in the class is
lost:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ReadOnlyMap&lt;String, String&gt; readOnlyMap = ...

CompletableFuture&lt;String&gt; readFuture = readOnlyMap.eval("key1", view -&gt; {
   // If caller depends on the typed information, this is not an ideal way to retrieve it
   // If the caller does not depend on the specific type, this works just fine.
   Optional&lt;MetaEntryVersion&gt; version = view.findMetaParam(MetaEntryVersion.class);
   return view.get();
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>When generic information is important the user can define a static helper
method that coerces the static class retrieval to the type requested,
and then use that helper method in the call to <code>findMetaParam</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class MetaEntryVersion&lt;T&gt; implements MetaParam.Writable&lt;EntryVersion&lt;T&gt;&gt; {
   ...
   public static &lt;T&gt; T type() { return (T) MetaEntryVersion.class; }
   ...
}

ReadOnlyMap&lt;String, String&gt; readOnlyMap = ...

CompletableFuture&lt;String&gt; readFuture = readOnlyMap.eval("key1", view -&gt; {
   // The caller wants guarantees that the metadata parameter for version is numeric
   // e.g. to query the actual version information
   Optional&lt;MetaEntryVersion&lt;Long&gt;&gt; version = view.findMetaParam(MetaEntryVersion.type());
   return view.get();
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, users are free to create new instances of metadata parameters to
suit their needs. They are stored and retrieved in the very same way as done
for the metadata parameters already provided by the functional map API.</p>
</div>
</div>
<div class="sect2">
<h3 id="_invocation_parameter"><a class="anchor" href="#_invocation_parameter"></a>9.8. Invocation Parameter</h3>
<div class="paragraph">
<p><a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/Param.html">Per-invocation parameters</a>
are applied to regular functional map API calls to
alter the behaviour of certain aspects. Adding per invocation parameters is
done using the
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/FunctionalMap.html#withParams(org.infinispan.functional.Param&#8230;&#8203;)"><code>withParams(Param&lt;?&gt;&#8230;&#8203;)</code></a>
method.</p>
</div>
<div class="paragraph">
<p><a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/Param.FutureMode.html"><code>Param.FutureMode</code></a>
tweaks whether a method returning a
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html"><code>CompletableFuture</code></a>
will span a thread to invoke the method, or instead will use the caller
thread. By default, whenever a call is made to a method returning a
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html"><code>CompletableFuture</code></a>
, a separate thread will be span to execute the method asynchronously.
However, if the caller will immediately block waiting for the
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html"><code>CompletableFuture</code></a>
to complete, spanning a different thread is wasteful, and hence
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/Param.FutureMode.html#COMPLETED"><code>Param.FutureMode.COMPLETED</code></a>
can be passed as per-invocation parameter to avoid creating that extra thread. Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.infinispan.functional.EntryView.*;
import org.infinispan.functional.FunctionalMap.*;
import org.infinispan.functional.Param.*;

ReadOnlyMap&lt;String, String&gt; readOnlyMap = ...
ReadOnlyMap&lt;String, String&gt; readOnlyMapCompleted = readOnlyMap.withParams(FutureMode.COMPLETED);
Optional&lt;String&gt; readFuture = readOnlyMapCompleted.eval("key1", ReadEntryView::find).get();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Param.PersistenceMode controls whether a write operation will be propagated
to a persistence store. The default behaviour is for all write-operations
to be propagated to the persistence store if the cache is configured with
a persistence store. By passing PersistenceMode.SKIP as parameter,
the write operation skips the persistence store and its effects are only
seen in the in-memory contents of the cache. PersistenceMode.SKIP can
be used to implement an
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/Cache.html#evict-K-"><code>Cache.evict()</code></a>
method which removes data from memory but leaves the persistence store
untouched:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.infinispan.functional.EntryView.*;
import org.infinispan.functional.FunctionalMap.*;
import org.infinispan.functional.Param.*;

WriteOnlyMap&lt;String, String&gt; writeOnlyMap = ...
WriteOnlyMap&lt;String, String&gt; skiPersistMap = writeOnlyMap.withParams(PersistenceMode.SKIP);
CompletableFuture&lt;Void&gt; removeFuture = skiPersistMap.eval("key1", WriteEntryView::remove);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that there&#8217;s no need for another PersistenceMode option to skip
reading from the persistence store, because a write operation can skip
reading previous value from the store by calling a write-only operation
via the WriteOnlyMap.</p>
</div>
<div class="paragraph">
<p>Finally, new Param implementations are normally provided by the functional
map API since they tweak how the internal logic works. So, for the most part
of users, they should limit themselves to using the Param instances exposed
by the API. The exception to this rule would be advanced users who decide
to add new interceptors to the internal stack. These users have the ability
to query these parameters within the interceptors.</p>
</div>
</div>
<div class="sect2">
<h3 id="functional_listeners"><a class="anchor" href="#functional_listeners"></a>9.9. Functional Listeners</h3>
<div class="paragraph">
<p>The functional map offers a listener API, where clients can register for and
get notified when events take place. These notifications are post-event, so
that means the events are received after the event has happened.</p>
</div>
<div class="paragraph">
<p>The listeners that can be registered are split into two categories:
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/Listeners.WriteListeners.html">write listeners</a>
and
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/Listeners.ReadWriteListeners.html">read-write listeners</a>.</p>
</div>
<div class="sect3">
<h4 id="write_listeners"><a class="anchor" href="#write_listeners"></a>9.9.1. Write Listeners</h4>
<div class="paragraph">
<p><a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/Listeners.WriteListeners.html">Write listeners</a>
enable user to register listeners for any cache entry write events
that happen in either a read-write or write-only functional map.</p>
</div>
<div class="paragraph">
<p>Listeners for write events cannot distinguish between cache entry
created and cache entry modify/update events because they don&#8217;t have
access to the previous value. All they know is that a new non-null
entry has been written.</p>
</div>
<div class="paragraph">
<p>However, write event listeners can distinguish between entry removals
and cache entry create/modify-update events because they can query
what the new entry&#8217;s value via
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/EntryView.ReadEntryView.html#find()"><code>ReadEntryView.find()</code></a>
method.</p>
</div>
<div class="paragraph">
<p>Adding a write listener is done via the WriteListeners interface
which is accessible via both
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/FunctionalMap.ReadWriteMap.html#listeners()"><code>ReadWriteMap.listeners()</code></a>
and
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/FunctionalMap.WriteOnlyMap.html#listeners()"><code>WriteOnlyMap.listeners()</code></a>
 method.</p>
</div>
<div class="paragraph">
<p>A write listener implementation can be defined either passing a function
to
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/Listeners.WriteListeners.html#onWrite(java.util.function.Consumer)"><code>onWrite(Consumer&lt;ReadEntryView&lt;K, V&gt;&gt;)</code></a>
method, or passing a
WriteListener implementation to
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/Listeners.WriteListeners.html#add(org.infinispan.functional.Listeners.WriteListeners.WriteListener)"><code>add(WriteListener&lt;K, V&gt;)</code></a>
method.
Either way, all these methods return an
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html">AutoCloseable</a>
instance that can be used to de-register the function listener:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.infinispan.functional.EntryView.*;
import org.infinispan.functional.FunctionalMap.*;
import org.infinispan.functional.Listeners.WriteListeners.WriteListener;

WriteOnlyMap&lt;String, String&gt; woMap = ...

AutoCloseable writeFunctionCloseHandler = woMap.listeners().onWrite(written -&gt; {
   // `written` is a ReadEntryView of the written entry
   System.out.printf("Written: %s%n", written.get());
});
AutoCloseable writeCloseHanlder = woMap.listeners().add(new WriteListener&lt;String, String&gt;() {
   @Override
   public void onWrite(ReadEntryView&lt;K, V&gt; written) {
      System.out.printf("Written: %s%n", written.get());
   }
});

// Either wrap handler in a try section to have it auto close...
try(writeFunctionCloseHandler) {
   // Write entries using read-write or write-only functional map API
   ...
}
// Or close manually
writeCloseHanlder.close();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="read_write_listeners"><a class="anchor" href="#read_write_listeners"></a>9.9.2. Read-Write Listeners</h4>
<div class="paragraph">
<p><a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/Listeners.ReadWriteListeners.html">Read-write listeners</a>
enable users to register listeners for cache entry created, modified
and removed events, and also register listeners for any cache entry
write events.</p>
</div>
<div class="paragraph">
<p>Entry created, modified and removed events can only be fired when these
originate on a read-write functional map, since this is the only one
that guarantees that the previous value has been read, and hence the
differentiation between create, modified and removed can be fully
guaranteed.</p>
</div>
<div class="paragraph">
<p>Adding a read-write listener is done via the
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/Listeners.ReadWriteListeners.html"><code>ReadWriteListeners</code></a>
interface which is accessible via
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/FunctionalMap.ReadWriteMap.html#listeners()"><code>ReadWriteMap.listeners()</code></a>
method.</p>
</div>
<div class="paragraph">
<p>If interested in only one of the event types, the simplest way to add a
listener is to pass a function to either
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/Listeners.ReadWriteListeners.ReadWriteListener.html#onCreate(java.util.function.Consumer)"><code>onCreate</code></a>
,
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/Listeners.ReadWriteListeners.ReadWriteListener.html#onModify(java.util.function.BiConsumer)"><code>onModify</code></a>
or
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/Listeners.ReadWriteListeners.ReadWriteListener.html#onRemove(java.util.function.Consumer)"><code>onRemove</code></a>
methods. All these methods return an AutoCloseable instance that can be
used to de-register the function listener:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.infinispan.functional.EntryView.*;
import org.infinispan.functional.FunctionalMap.*;

ReadWriteMap&lt;String, String&gt; rwMap = ...
AutoCloseable createClose = rwMap.listeners().onCreate(created -&gt; {
   // `created` is a ReadEntryView of the created entry
   System.out.printf("Created: %s%n", created.get());
});
AutoCloseable modifyClose = rwMap.listeners().onModify((before, after) -&gt; {
   // `before` is a ReadEntryView of the entry before update
   // `after` is a ReadEntryView of the entry after update
   System.out.printf("Before: %s%n", before.get());
   System.out.printf("After: %s%n", after.get());
});
AutoCloseable removeClose = rwMap.listeners().onRemove(removed -&gt; {
   // `removed` is a ReadEntryView of the removed entry
   System.out.printf("Removed: %s%n", removed.get());
});
AutoCloseable writeClose = woMap.listeners().onWrite(written -&gt; {
   // `written` is a ReadEntryView of the written entry
   System.out.printf("Written: %s%n", written.get());
});
...
// Either wrap handler in a try section to have it auto close...
try(createClose) {
   // Create entries using read-write functional map API
   ...
}
// Or close manually
modifyClose.close();</code></pre>
</div>
</div>
<div class="paragraph">
<p>If listening for two or more event types, it&#8217;s better to pass in an
implementation of
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/Listeners.WriteListeners.WriteListener.html"><code>ReadWriteListener</code></a>
interface via the
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/functional/Listeners.ReadWriteListeners.html#add(org.infinispan.functional.Listeners.ReadWriteListeners.ReadWriteListener)"><code>ReadWriteListeners.add()</code></a>
method. <code>ReadWriteListener</code> offers the same <code>onCreate</code>/<code>onModify</code>/<code>onRemove</code>
callbacks with default method implementations that are empty:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.infinispan.functional.EntryView.*;
import org.infinispan.functional.FunctionalMap.*;
import org.infinispan.functional.Listeners.ReadWriteListeners.ReadWriteListener;

ReadWriteMap&lt;String, String&gt; rwMap = ...
AutoCloseable readWriteClose = rwMap.listeners.add(new ReadWriteListener&lt;String, String&gt;() {
   @Override
   public void onCreate(ReadEntryView&lt;String, String&gt; created) {
      System.out.printf("Created: %s%n", created.get());
   }

   @Override
   public void onModify(ReadEntryView&lt;String, String&gt; before, ReadEntryView&lt;String, String&gt; after) {
      System.out.printf("Before: %s%n", before.get());
      System.out.printf("After: %s%n", after.get());
   }

   @Override
   public void onRemove(ReadEntryView&lt;String, String&gt; removed) {
      System.out.printf("Removed: %s%n", removed.get());
   }
);
AutoCloseable writeClose = rwMap.listeners.add(new WriteListener&lt;String, String&gt;() {
   @Override
   public void onWrite(ReadEntryView&lt;K, V&gt; written) {
      System.out.printf("Written: %s%n", written.get());
   }
);

// Either wrap handler in a try section to have it auto close...
try(readWriteClose) {
   // Create/update/remove entries using read-write functional map API
   ...
}
// Or close manually
writeClose.close();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="marshalling_of_functions"><a class="anchor" href="#marshalling_of_functions"></a>9.10. Marshalling of Functions</h3>
<div class="paragraph">
<p>Running functional map in a cluster of nodes involves marshalling and
replication of the operation parameters under certain circumstances.</p>
</div>
<div class="paragraph">
<p>To be more precise, when write operations are executed in a cluster,
regardless of read-write or write-only operations, all the parameters
to the method and the functions are replicated to other nodes.</p>
</div>
<div class="paragraph">
<p>There are multiple ways in which a function can be marshalled. The simplest
way, which is also the most costly option in terms of payload size, is
to mark the function as
<a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html"><code>Serializable</code></a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.infinispan.functional.EntryView.*;
import org.infinispan.functional.FunctionalMap.*;

WriteOnlyMap&lt;String, String&gt; writeOnlyMap = ...

// Force a function to be Serializable
Consumer&lt;WriteEntryView&lt;String&gt;&gt; function =
   (Consumer&lt;WriteEntryView&lt;String&gt;&gt; &amp; Serializable) wv -&gt; wv.set("one");

CompletableFuture&lt;Void&gt; writeFuture = writeOnlyMap.eval("key1", function);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Infinispan provides overloads for all functional methods that make lambdas
passed directly to the API serializable by default; the compiler automatically selects
this overload if that&#8217;s possible. Therefore you can call</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">WriteOnlyMap&lt;String, String&gt; writeOnlyMap = ...
CompletableFuture&lt;Void&gt; writeFuture = writeOnlyMap.eval("key1", wv -&gt; wv.set("one"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>without doing the cast described above.</p>
</div>
<div class="paragraph">
<p>A more economical way to marshall a function is to provide an Infinispan
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/commons/marshall/Externalizer.html"><code>Externalizer</code></a> for it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.infinispan.functional.EntryView.*;
import org.infinispan.functional.FunctionalMap.*;
import org.infinispan.commons.marshall.Externalizer;
import org.infinispan.commons.marshall.SerializeFunctionWith;

WriteOnlyMap&lt;String, String&gt; writeOnlyMap = ...

// Force a function to be Serializable
Consumer&lt;WriteEntryView&lt;String&gt;&gt; function = new SetStringConstant&lt;&gt;();
CompletableFuture&lt;Void&gt; writeFuture = writeOnlyMap.eval("key1", function);

@SerializeFunctionWith(value = SetStringConstant.Externalizer0.class)
class SetStringConstant implements Consumer&lt;WriteEntryView&lt;String&gt;&gt; {
   @Override
   public void accept(WriteEntryView&lt;String&gt; view) {
      view.set("value1");
   }

   public static final class Externalizer0 implements Externalizer&lt;Object&gt; {
      public void writeObject(ObjectOutput oo, Object o) {
         // No-op
      }
      public Object readObject(ObjectInput input) {
         return new SetStringConstant&lt;&gt;();
      }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To help users take advantage of the tiny payloads generated by
<code>Externalizer</code>-based functions, the functional API comes with a helper
class called
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/commons/marshall/MarshallableFunctions.html"><code>org.infinispan.commons.marshall.MarshallableFunctions</code></a>
which provides marshallable functions for some of the most commonly user
functions.</p>
</div>
<div class="paragraph">
<p>In fact, all the functions required to implement
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html"><code>ConcurrentMap</code></a>
and
<a href="https://github.com/jsr107/jsr107spec/blob/v1.0.0/src/main/java/javax/cache/Cache.java"><code>JCache</code></a>
using the functional map API have been defined in
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/commons/marshall/MarshallableFunctions.html"><code>MarshallableFunctions</code></a>.
For example, here is an implementation of JCache&#8217;s
<a href="https://github.com/jsr107/jsr107spec/blob/v1.0.0/src/main/java/javax/cache/Cache.java#L283"><code>boolean putIfAbsent(K, V)</code></a>
using functional map API which can be run in a cluster:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.infinispan.functional.EntryView.*;
import org.infinispan.functional.FunctionalMap.*;
import org.infinispan.commons.marshall.MarshallableFunctions;

ReadWriteMap&lt;String, String&gt; readWriteMap = ...

CompletableFuture&lt;Boolean&gt; future = readWriteMap.eval("key1,
   MarshallableFunctions.setValueIfAbsentReturnBoolean());
future.thenAccept(stored -&gt; System.out.printf("Value was put? %s%n", stored));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="use_cases_for_functional_api"><a class="anchor" href="#use_cases_for_functional_api"></a>9.11. Use Cases for Functional API</h3>
<div class="paragraph">
<p>This new API is meant to complement existing Key/Value Infinispan API
offerings, so you&#8217;ll still be able to use
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html"><code>ConcurrentMap</code></a>
or
<a href="https://github.com/jsr107/jsr107spec/blob/v1.0.0/src/main/java/javax/cache/Cache.java"><code>JCache</code></a>
standard APIs if that&#8217;s what suits your use case best.</p>
</div>
<div class="paragraph">
<p>The target audience for this new API is either:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Distributed or persistent caching/in­memory­data­grid users that want
to benefit from CompletableFuture and/or Traversable for async/lazy data
grid or caching data manipulation. The clear advantage here is that threads
do not need to be idle waiting for remote operations to complete, but
instead these can be notified when remote operations complete and then
chain them with other subsequent operations.</p>
</li>
<li>
<p>Users who want to go beyond the standard operations exposed by
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html"><code>ConcurrentMap</code></a>
and
<a href="https://github.com/jsr107/jsr107spec/blob/v1.0.0/src/main/java/javax/cache/Cache.java"><code>JCache</code></a>, for example, if you want to do a replace
operation using metadata parameter equality instead of value equality, or
if you want to retrieve metadata information from values and so on.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="execute_code_grid"><a class="anchor" href="#execute_code_grid"></a>10. Executing Code in the Grid</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The main benefit of a Cache is the ability to very quickly lookup a value
by its key, even across machines. In fact this use alone is probably the reason
many users use Infinispan. However Infinispan can provide many more benefits
that aren&#8217;t immediately apparent. Since Infinispan is usually used in
a cluster of machines we also have features available that can help utilize
the entire cluster for performing the user&#8217;s desired workload.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This section covers only executing code in the grid using an embedded cache,
if you are using a remote cache you should review details about executing code in the remote grid.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="cluster_executor"><a class="anchor" href="#cluster_executor"></a>10.1. Cluster Executor</h3>
<div class="paragraph">
<p>Since you have a group of machines, it makes sense to leverage their combined
computing power for executing code on all of them them.
The cache manager comes with a nice utility that allows you to
execute arbitrary code in the cluster. Note this feature requires no Cache to be used.  This
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/manager/ClusterExecutor.html">Cluster Executor</a>
can be retrieved by calling executor() on the <code>EmbeddedCacheManager</code>. This executor is retrievable
in both clustered and non clustered configurations.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The ClusterExecutor is specifically designed for executing code where the code is not reliant
upon the data in a cache and is used instead as a way to help users to execute code easily
in the cluster.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This manager was built specifically using Java 8 and such has functional APIs in mind, thus all methods take a functional
interface as an argument. Also since these arguments will be sent to other nodes they need to be serializable.  We even
used a nice trick to ensure our lambdas are immediately Serializable.  That is by having the arguments implement both
Serializable and the real argument type (ie. Runnable or Function).  The JRE will pick the most specific class when
determining which method to invoke, so in that case your lambdas will always be serializable.
It is also possible to use an Externalizer to possibly reduce message size further.</p>
</div>
<div class="paragraph">
<p>The manager by default will submit a given command to all nodes in the cluster including the node
where it was submitted from. You can control on which nodes the task is executed on
by using the <code>filterTargets</code> methods as is explained in the section.</p>
</div>
<div class="sect3">
<h4 id="filtering_execution_nodes"><a class="anchor" href="#filtering_execution_nodes"></a>10.1.1. Filtering execution nodes</h4>
<div class="paragraph">
<p>It is possible to limit on which nodes the command will be ran. For example you may
want to only run a computation on machines in the same rack. Or you may want to perform an operation
once in the local site and again on a different site. A cluster executor can limit what nodes it sends
requests to at the scope of same or different machine, rack or site level.</p>
</div>
<div class="listingblock">
<div class="title">SameRack.java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">EmbeddedCacheManager manager = ...;
manager.executor().filterTargets(ClusterExecutionPolicy.SAME_RACK).submit(...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>To use this topology base filtering you must enable topology aware consistent hashing through Server Hinting.</p>
</div>
<div class="paragraph">
<p>You can also filter using a predicate based on the <code>Address</code> of the node. This can also
be optionally combined with topology based filtering in the previous code snippet.</p>
</div>
<div class="paragraph">
<p>We also allow the target node to be chosen by any means using a <code>Predicate</code> that
will filter out which nodes can be considered for execution. Note this can also be combined
with Topology filtering at the same time to allow even more fine control of where you code
is executed within the cluster.</p>
</div>
<div class="listingblock">
<div class="title">Predicate.java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">EmbeddedCacheManager manager = ...;
// Just filter
manager.executor().filterTargets(a -&gt; a.equals(..)).submit(...)
// Filter only those in the desired topology
manager.executor().filterTargets(ClusterExecutionPolicy.SAME_SITE, a -&gt; a.equals(..)).submit(...)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="timeout"><a class="anchor" href="#timeout"></a>10.1.2. Timeout</h4>
<div class="paragraph">
<p>Cluster Executor allows for a timeout to be set per invocation. This defaults to the distributed sync timeout
as configured on the Transport Configuration. This timeout works in both a clustered and non clustered
cache manager. The executor may or may not interrupt the threads executing a task when the timeout expires. However
when the timeout occurs any <code>Consumer</code> or <code>Future</code> will be completed passing back a <code>TimeoutException</code>.
This value can be overridden by ivoking the
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/manager/ClusterExecutor.html#timeout-long-java.util.concurrent.TimeUnit-">timeout</a>
method and supplying the desired duration.</p>
</div>
</div>
<div class="sect3">
<h4 id="single_node_submission"><a class="anchor" href="#single_node_submission"></a>10.1.3. Single Node Submission</h4>
<div class="paragraph">
<p>Cluster Executor can also run in single node submission mode instead of submitting the command
to all nodes it will instead pick one of the nodes that would have normally received the command
and instead submit it it to only one. Each submission will possibly use a different node to
execute the task on. This can be very useful to use the ClusterExecutor as a
<code>java.util.concurrent.Executor</code> which you may have noticed that ClusterExecutor implements.</p>
</div>
<div class="listingblock">
<div class="title">SingleNode.java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">EmbeddedCacheManager manager = ...;
manager.executor().singleNodeSubmission().submit(...)</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="failover"><a class="anchor" href="#failover"></a>Failover</h5>
<div class="paragraph">
<p>When running in single node submission it may be desirable to also allow the Cluster Executor
handle cases where an exception occurred during the processing of a given command by retrying
the command again.
When this occurs the Cluster Executor will choose a single node again to resubmit the command to
up to the desired number of failover attempts. Note the chosen node could be any node that passes
the topology or predicate check. Failover is enabled by invoking the overridden
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/manager/ClusterExecutor.html#singleNodeSubmission-int-">singleNodeSubmission</a>
method. The given command will be resubmitted again to a single node until either
the command completes without exception or the total submission amount is equal to the provided
failover count.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example_pi_approximation"><a class="anchor" href="#example_pi_approximation"></a>10.1.4. Example: PI Approximation</h4>
<div class="paragraph">
<p>This example shows how you can use the ClusterExecutor to estimate the value of PI.</p>
</div>
<div class="paragraph">
<p>Pi approximation can greatly benefit from parallel distributed execution via
Cluster Executor. Recall that area of the square is Sa = 4r2 and area of the
circle is Ca=pi*r2. Substituting r2 from the second equation into the first
one it turns out that pi = 4 * Ca/Sa. Now, image that we can shoot very large
number of darts into a square; if we take ratio of darts that land inside a
circle over a total number of darts shot we will approximate Ca/Sa value. Since
we know that pi = 4 * Ca/Sa we can easily derive approximate value of pi. The
more darts we shoot the better approximation we get. In the example below we
shoot 1 billion darts but instead of "shooting" them serially we parallelize
work of dart shooting across the entire Infinispan cluster. Note this will
work in a cluster of 1 was well, but will be slower.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class PiAppx {

   public static void main (String [] arg){
      EmbeddedCacheManager cacheManager = ..
      boolean isCluster = ..

      int numPoints = 1_000_000_000;
      int numServers = isCluster ? cacheManager.getMembers().size() : 1;
      int numberPerWorker = numPoints / numServers;

      ClusterExecutor clusterExecutor = cacheManager.executor();
      long start = System.currentTimeMillis();
      // We receive results concurrently - need to handle that
      AtomicLong countCircle = new AtomicLong();
      CompletableFuture&lt;Void&gt; fut = clusterExecutor.submitConsumer(m -&gt; {
         int insideCircleCount = 0;
         for (int i = 0; i &lt; numberPerWorker; i++) {
            double x = Math.random();
            double y = Math.random();
            if (insideCircle(x, y))
               insideCircleCount++;
         }
         return insideCircleCount;
      }, (address, count, throwable) -&gt; {
         if (throwable != null) {
            throwable.printStackTrace();
            System.out.println("Address: " + address + " encountered an error: " + throwable);
         } else {
            countCircle.getAndAdd(count);
         }
      });
      fut.whenComplete((v, t) -&gt; {
         // This is invoked after all nodes have responded with a value or exception
         if (t != null) {
            t.printStackTrace();
            System.out.println("Exception encountered while waiting:" + t);
         } else {
            double appxPi = 4.0 * countCircle.get() / numPoints;

            System.out.println("Distributed PI appx is " + appxPi +
                  " using " + numServers + " node(s), completed in " + (System.currentTimeMillis() - start) + " ms");
         }
      });

      // May have to sleep here to keep alive if no user threads left
   }

   private static boolean insideCircle(double x, double y) {
      return (Math.pow(x - 0.5, 2) + Math.pow(y - 0.5, 2))
            &lt;= Math.pow(0.5, 2);
   }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="streams"><a class="anchor" href="#streams"></a>11. Streams</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You may want to process a subset or all data in the cache to produce a result.
This may bring thoughts of Map Reduce. Infinispan allows the user to do something
very similar but utilizes the standard JRE APIs to do so.
Java 8 introduced the concept of a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Stream</a>
which allows functional-style operations on collections rather than having to procedurally
iterate over the data yourself. Stream operations can be implemented in a fashion very
similar to MapReduce.  Streams, just like MapReduce allow you to perform processing
upon the entirety of your cache, possibly a very large data set, but in an efficient way.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Streams are the preferred method when dealing with data that exists in the cache because streams automatically adjust to cluster topology changes.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Also since we can control how the entries are iterated upon we can more efficiently perform the operations in a cache that is distributed if you want it to perform all of the operations across the cluster concurrently.</p>
</div>
<div class="paragraph">
<p>A stream is retrieved from the <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/Cache.html#entrySet--">entrySet</a>,
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/Cache.html#keySet--">keySet</a> or
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/Cache.html#values--">values</a> collections returned from the
Cache by invoking the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#stream--">stream</a> or
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#parallelStream--">parallelStream</a> methods.</p>
</div>
<div class="sect2">
<h3 id="common_stream_operations"><a class="anchor" href="#common_stream_operations"></a>11.1. Common stream operations</h3>
<div class="paragraph">
<p>This section highlights various options that are present irrespective of what type of underlying cache
you are using.</p>
</div>
</div>
<div class="sect2">
<h3 id="key_filtering"><a class="anchor" href="#key_filtering"></a>11.2. Key filtering</h3>
<div class="paragraph">
<p>It is possible to filter the stream so that it only operates upon a given subset of keys.  This can be done
by invoking the
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/CacheStream.html#filterKeys-java.util.Set-">filterKeys</a>
method on the <code>CacheStream</code>.  This should always be used over a Predicate
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html?is-external=true#filter-java.util.function.Predicate-">filter</a>
and will be faster if the predicate was holding all keys.</p>
</div>
<div class="paragraph">
<p>If you are familiar with the <code>AdvancedCache</code> interface you may be wondering why you even use
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/AdvancedCache.html#getAll-java.util.Set-">getAll</a>
over this keyFilter.  There are some small benefits (mostly smaller payloads) to using getAll
if you need the entries as is and need them all in memory in the local node.  However if you
need to do processing on these elements a stream is recommended since you will get both
distributed and threaded parallelism for free.</p>
</div>
</div>
<div class="sect2">
<h3 id="segment_based_filtering"><a class="anchor" href="#segment_based_filtering"></a>11.3. Segment based filtering</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is an advanced feature and should only be used with deep knowledge of Infinispan segment and hashing techniques.
These segments based filtering can be useful if you need to segment data into separate invocations.
This can be useful when integrating with other tools such as
<a href="http://spark.apache.org/">Apache Spark</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This option is only supported for replicated and distributed caches.  This allows the user to operate upon
a subset of data at a time as determined by the
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/distribution/ch/KeyPartitioner.html">KeyPartitioner</a>.
The segments can be filtered by invoking
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/CacheStream.html#filterKeySegments-java.util.Set-">filterKeySegments</a>
method on the <code>CacheStream</code>.  This is applied after the key filter but before any intermediate operations are performed.</p>
</div>
</div>
<div class="sect2">
<h3 id="localinvalidation"><a class="anchor" href="#localinvalidation"></a>11.4. Local/Invalidation</h3>
<div class="paragraph">
<p>A stream used with a local or invalidation cache can be used just the same way you would use a stream on a
regular collection. Infinispan handles all of the translations if necessary behind the scenes and works with all
of the more interesting options (ie. storeAsBinary and a cache loader).  Only data local to
the node where the stream operation is performed will be used, for example invalidation only uses local entries.</p>
</div>
</div>
<div class="sect2">
<h3 id="example"><a class="anchor" href="#example"></a>11.5. Example</h3>
<div class="paragraph">
<p>The code below takes a cache and returns a map with all the cache entries whose values contain the string "JBoss"</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Map&lt;Object, String&gt; jbossValues =
cache.entrySet().stream()
     .filter(e -&gt; e.getValue().contains("JBoss"))
     .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="distributionreplicationscattered"><a class="anchor" href="#distributionreplicationscattered"></a>11.6. Distribution/Replication/Scattered</h3>
<div class="paragraph">
<p>This is where streams come into their stride.  When a stream operation is performed it will
send the various intermediate and terminal operations to each node that has pertinent data.
This allows processing the intermediate values on the nodes owning the data, and only sending
the final results back to the originating nodes, improving performance.</p>
</div>
<div class="sect3">
<h4 id="rehash_aware"><a class="anchor" href="#rehash_aware"></a>11.6.1. Rehash Aware</h4>
<div class="paragraph">
<p>Internally the data is segmented and each node only performs the operations upon the data it owns as a primary owner.
This allows for data to be processed evenly, assuming segments are granular enough to provide for equal amounts of
data on each node.</p>
</div>
<div class="paragraph">
<p>When you are utilizing a distributed cache, the data can be reshuffled between nodes when a
new node joins or leaves. Distributed Streams handle this reshuffling of data automatically so you don&#8217;t
have to worry about monitoring when nodes leave or join the cluster.
Reshuffled entries may be processed a second time, and we keep track of the processed entries at the
key level or at the segment level (depending on the terminal operation) to limit the amount of
duplicate processing.</p>
</div>
<div class="paragraph">
<p>It is possible but highly discouraged to disable rehash awareness on the stream.  This should only be considered if
your request can handle only seeing a subset of data if a rehash occurs.  This can be done by invoking
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/CacheStream.html#disableRehashAware--">CacheStream.disableRehashAware()</a>
The performance gain for most operations when a rehash doesn&#8217;t occur is completely negligible.
The only exceptions are for iterator and forEach, which will use less memory, since they do not have
to keep track of processed keys.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Please rethink disabling rehash awareness unless you really know what you are doing.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="serialization"><a class="anchor" href="#serialization"></a>11.6.2. Serialization</h4>
<div class="paragraph">
<p>Since the operations are sent across to other nodes they must be serializable by Infinispan marshalling.  This allows the
operations to be sent to the other nodes.</p>
</div>
<div class="paragraph">
<p>The simplest way is to use a CacheStream instance and use a lambda just as you would normally.
Infinispan overrides all of the various Stream intermediate and terminal methods to take
Serializable versions of the arguments (ie. SerializableFunction, SerializablePredicate&#8230;&#8203;)
You can find these methods at
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/stream/CacheStream.html">CacheStream</a>.
This relies on the spec to pick the most specific method as defined <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2.5">here</a>.</p>
</div>
<div class="paragraph">
<p>In our previous example we used a <code>Collector</code> to collect all the results into a <code>Map</code>.
Unfortunately the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html">Collectors</a>
class doesn&#8217;t produce Serializable instances.  Thus if you need to use these, there are two ways to do so:</p>
</div>
<div class="paragraph">
<p>One option would be to use the
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/stream/CacheCollectors.html">CacheCollectors</a>
class which allows for a <code>Supplier&lt;Collector&gt;</code> to be provided.  This instance could then use the
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html">Collectors</a>
to supply a <code>Collector</code> which is not serialized.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Map&lt;Object, String&gt; jbossValues = cache.entrySet().stream()
              .filter(e -&gt; e.getValue().contains("Jboss"))
              .collect(CacheCollectors.serializableCollector(() -&gt; Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can avoid the use of
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/stream/CacheCollectors.html">CacheCollectors</a>
and instead use the overloaded <code>collect</code> methods that take <code>Supplier&lt;Collector&gt;</code>.
These overloaded <code>collect</code> methods are only available via <code>CacheStream</code> interface.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Map&lt;Object, String&gt; jbossValues = cache.entrySet().stream()
              .filter(e -&gt; e.getValue().contains("Jboss"))
              .collect(() -&gt; Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));</code></pre>
</div>
</div>
<div class="paragraph">
<p>If however you are not able to use the <code>Cache</code> and <code>CacheStream</code> interfaces you cannot utilize <code>Serializable</code>
arguments and you must instead cast the lambdas to be <code>Serializable</code> manually by casting the lambda to multiple
interfaces.  It is not a pretty sight but it gets the job done.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Map&lt;Object, String&gt; jbossValues = map.entrySet().stream()
              .filter((Serializable &amp; Predicate&lt;Map.Entry&lt;Object, String&gt;&gt;) e -&gt; e.getValue().contains("Jboss"))
              .collect(CacheCollectors.serializableCollector(() -&gt; Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The recommended and most performant way is to use an
<code>AdvancedExternalizer</code> as this provides the smallest payload.  Unfortunately
this means you cannot use lamdbas as advanced externalizers require defining
the class before hand.</p>
</div>
<div class="paragraph">
<p>You can use an advanced externalizer as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">   Map&lt;Object, String&gt; jbossValues = cache.entrySet().stream()
              .filter(new ContainsFilter("Jboss"))
              .collect(() -&gt; Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));

   class ContainsFilter implements Predicate&lt;Map.Entry&lt;Object, String&gt;&gt; {
      private final String target;

      ContainsFilter(String target) {
         this.target = target;
      }

      @Override
      public boolean test(Map.Entry&lt;Object, String&gt; e) {
         return e.getValue().contains(target);
      }
   }

   class JbossFilterExternalizer implements AdvancedExternalizer&lt;ContainsFilter&gt; {

      @Override
      public Set&lt;Class&lt;? extends ContainsFilter&gt;&gt; getTypeClasses() {
         return Util.asSet(ContainsFilter.class);
      }

      @Override
      public Integer getId() {
         return CUSTOM_ID;
      }

      @Override
      public void writeObject(ObjectOutput output, ContainsFilter object) throws IOException {
         output.writeUTF(object.target);
      }

      @Override
      public ContainsFilter readObject(ObjectInput input) throws IOException, ClassNotFoundException {
         return new ContainsFilter(input.readUTF());
      }
   }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You could also use an advanced externalizer for the collector supplier to reduce the
payload size even further.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Map&lt;Object, String&gt; map = (Map&lt;Object, String&gt;) cache.entrySet().stream()
              .filter(new ContainsFilter("Jboss"))
              .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));

 class ToMapCollectorSupplier&lt;K, U&gt; implements Supplier&lt;Collector&lt;Map.Entry&lt;K, U&gt;, ?, Map&lt;K, U&gt;&gt;&gt; {
      static final ToMapCollectorSupplier INSTANCE = new ToMapCollectorSupplier();

      private ToMapCollectorSupplier() { }

      @Override
      public Collector&lt;Map.Entry&lt;K, U&gt;, ?, Map&lt;K, U&gt;&gt; get() {
         return Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue);
      }
   }

   class ToMapCollectorSupplierExternalizer implements AdvancedExternalizer&lt;ToMapCollectorSupplier&gt; {

      @Override
      public Set&lt;Class&lt;? extends ToMapCollectorSupplier&gt;&gt; getTypeClasses() {
         return Util.asSet(ToMapCollectorSupplier.class);
      }

      @Override
      public Integer getId() {
         return CUSTOM_ID;
      }

      @Override
      public void writeObject(ObjectOutput output, ToMapCollectorSupplier object) throws IOException {
      }

      @Override
      public ToMapCollectorSupplier readObject(ObjectInput input) throws IOException, ClassNotFoundException {
         return ToMapCollectorSupplier.INSTANCE;
      }
   }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="parallel_computation"><a class="anchor" href="#parallel_computation"></a>11.7. Parallel Computation</h3>
<div class="paragraph">
<p>Distributed streams by default try to parallelize as much as possible.  It is possible for the end user to control this and
actually they always have to control one of the options.  There are 2 ways these streams are parallelized.</p>
</div>
<div class="paragraph">
<p><strong>Local to each node</strong>
When a stream is created from the cache collection the end user can choose between invoking
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#stream--">stream</a> or
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#parallelStream--">parallelStream</a>
method.  Depending on if the parallel stream was picked will enable multiple threading for
each node locally.  Note that some operations like a rehash aware iterator and forEach operations
will always use a sequential stream locally.  This could be enhanced at some point to allow for
parallel streams locally.</p>
</div>
<div class="paragraph">
<p>Users should be careful when using local parallelism as it requires having a large number of entries or operations
that are computationally expensive to be faster. Also it should be noted that if a user uses a parallel
stream with <code>forEach</code> that the action should not block as this would be executed on the common pool, which
is normally reserved for computation operations.</p>
</div>
<div class="paragraph">
<p><strong>Remote requests</strong>
When there are multiple nodes it may be desirable to control whether the remote requests are all processed
at the same time concurrently or one at a time.  By default all terminal operations except the iterator
perform concurrent requests.  The iterator, method to reduce overall memory pressure on the local node,
only performs sequential requests which actually performs slightly better.</p>
</div>
<div class="paragraph">
<p>If a user wishes to change this default however they can do so by invoking the
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/CacheStream.html#sequentialDistribution--">sequentialDistribution</a>
or <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/CacheStream.html#parallelDistribution--">parallelDistribution</a>
methods on the <code>CacheStream</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="task_timeout"><a class="anchor" href="#task_timeout"></a>11.8. Task timeout</h3>
<div class="paragraph">
<p>It is possible to set a timeout value for the operation requests. This timeout is used only for remote requests timing out and
it is on a per request basis. The former means the local execution will not timeout and the latter means if you have a failover
scenario as described above the subsequent requests each have a new timeout.  If no timeout is specified it uses the
replication timeout as a default timeout. You can set the timeout in your task by doing the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">CacheStream&lt;Map.Entry&lt;Object, String&gt;&gt; stream = cache.entrySet().stream();
stream.timeout(1, TimeUnit.MINUTES);</code></pre>
</div>
</div>
<div class="paragraph">
<p>For more information about this, please check the java doc in
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/CacheStream.html#timeout-long-java.util.concurrent.TimeUnit-">timeout</a>
javadoc.</p>
</div>
</div>
<div class="sect2">
<h3 id="injection"><a class="anchor" href="#injection"></a>11.9. Injection</h3>
<div class="paragraph">
<p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Stream</a>
has a terminal operation called
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#forEach-java.util.function.Consumer-">forEach</a>
which allows for running some sort of side effect operation on the data.  In this case it may be desirable to get a reference to
the <code>Cache</code> that is backing this Stream.  If your <code>Consumer</code> implements the
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/stream/CacheAware.html">CacheAware</a>
interface the <code>injectCache</code> method be invoked before the accept method from the <code>Consumer</code> interface.</p>
</div>
</div>
<div class="sect2">
<h3 id="distributed_stream_execution"><a class="anchor" href="#distributed_stream_execution"></a>11.10. Distributed Stream execution</h3>
<div class="paragraph">
<p>Distributed streams execution works in a fashion very similar to map reduce.  Except in this case we are sending zero to many intermediate operations
(map, filter etc.) and a single terminal operation to the various nodes.  The operation basically comes down to the following:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The desired segments are grouped by which node is the primary owner of the given segment</p>
</li>
<li>
<p>A request is generated to send to each remote node that contains the intermediate and terminal operations including which segments it should process</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>The terminal operation will be performed locally if necessary</p>
</li>
<li>
<p>Each remote node will receive this request and run the operations and subsequently send the response back</p>
</li>
</ol>
</div>
</li>
<li>
<p>The local node will then gather the local response and remote responses together performing any kind of reduction required by the operations themselves.</p>
</li>
<li>
<p>Final reduced response is then returned to the user</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In most cases all operations are fully distributed, as in the operations are all fully applied on each remote node and usually only the last operation or something related may be
reapplied to reduce the results from multiple nodes.  One important note is that intermediate values do not actually have to be serializable, it is the last value
sent back that is the part desired (exceptions for various operations will be highlighted below).</p>
</div>
<div class="paragraph">
<p><strong>Terminal operator distributed result reductions</strong>
The following paragraphs describe how the distributed reductions work for the various terminal operators.  Some of these are special in that an intermediate value may
be required to be serializable instead of the final result.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">allMatch noneMatch anyMatch</dt>
<dd>
<p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#allMatch-java.util.function.Predicate-">allMatch</a>
operation is ran on each node and then all the results are logically anded together locally
to get the appropriate value.  The
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#noneMatch-java.util.function.Predicate-">noneMatch</a>
and
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#anyMatch-java.util.function.Predicate-">anyMatch</a>
operations use a logical or instead. These methods also have early termination support,
stopping remote and local operations once the final result is known.</p>
</dd>
<dt class="hdlist1">collect</dt>
<dd>
<p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#collect-java.util.stream.Collector-">collect</a>
method is interesting in that it can do a few extra steps.  The remote node performs
everything as normal except it doesn&#8217;t perform the final
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.html#finisher--">finisher</a>
upon the result and instead sends back the fully combined results.  The local thread
then <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.html#combiner--">combines</a>
the remote and local result into a value which is then finally finished.  The key
here to remember is that the final value doesn&#8217;t have to be serializable but rather
the values produced from the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.html#supplier--">supplier</a>
and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.html#combiner--">combiner</a>
methods.</p>
</dd>
<dt class="hdlist1">count</dt>
<dd>
<p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#count--">count</a>
method just adds the numbers together from each node.</p>
</dd>
<dt class="hdlist1">findAny findFirst</dt>
<dd>
<p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#findAny--">findAny</a>
operation returns just the first value they find, whether it was from a remote node
or locally.  Note this supports early termination in that once a value is found it
will not process others.  Note the findFirst method is special since it requires a sorted
intermediate operation, which is detailed in the
<a href="user_guide.html#intermediate_operation_exceptions">exceptions</a> section.</p>
</dd>
<dt class="hdlist1">max min</dt>
<dd>
<p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#max-java.util.Comparator-">max</a> and
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#min-java.util.Comparator-">min</a> methods find the respective min or max value on each node then a final
reduction is performed locally to ensure only the min or max across all nodes is returned.</p>
</dd>
<dt class="hdlist1">reduce</dt>
<dd>
<p>The various reduce methods <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#reduce-java.util.function.BinaryOperator-">1</a> ,
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#reduce-T-java.util.function.BinaryOperator-">2</a> ,
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#reduce-U-java.util.function.BiFunction-java.util.function.BinaryOperator-">3</a> will end up serializing
the result as much as the accumulator can do.  Then it will accumulate the local and remote results together locally, before combining if you have provided that.  Note this means
a value coming from the combiner doesn&#8217;t have to be Serializable.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="key_based_rehash_aware_operators"><a class="anchor" href="#key_based_rehash_aware_operators"></a>11.11. Key based rehash aware operators</h3>
<div class="paragraph">
<p>The <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/CacheStream.html#iterator--">iterator</a>,
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/CacheStream.html#spliterator--">spliterator</a>
and <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/CacheStream.html#forEach-java.util.function.Consumer-">forEach</a>
are unlike the other terminal operators in that the rehash awareness has to keep
track of what keys per segment have been processed instead of just segments.  This is
to guarantee an exactly once (iterator &amp; spliterator) or at least once behavior (forEach)
even under cluster membership changes.</p>
</div>
<div class="paragraph">
<p>The <code>iterator</code> and <code>spliterator</code> operators when invoked on a remote node will return back batches
of entries, where the next batch is only sent back after the last has been fully consumed.  This
batching is done to limit how many entries are in memory at a given time.  The user node will hold
onto which keys it has processed and when a given segment is completed it will release those keys from
memory.  This is why sequential processing is preferred for the iterator method, so only a subset of segment
keys are held in memory at once, instead of from all nodes.</p>
</div>
<div class="paragraph">
<p>The <code>forEach()</code> method also returns batches, but it returns a batch of keys after it has finished processing
at least a batch worth of keys.  This way the originating node can know what keys have been processed
already to reduce chances of processing the same entry again.  Unfortunately this means it is possible
to have an at least once behavior when a node goes down unexpectedly.  In this case that node could have
been processing a batch and not yet completed one and those entries that were processed but not
in a completed batch will be ran again when the rehash failure operation occurs.  Note that adding a
node will not cause this issue as the rehash failover doesn&#8217;t occur until all responses are received.</p>
</div>
<div class="paragraph">
<p>These operations batch sizes are both controlled by the same value which can be configured by invoking
<a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/CacheStream.html#distributedBatchSize-int-">distributedBatchSize</a>
method on the <code>CacheStream</code>.  This value will default to the <code>chunkSize</code> configured in state transfer.
Unfortunately this value is a tradeoff with memory usage vs performance vs at least once and your
mileage may vary.</p>
</div>
<div class="paragraph">
<p><strong>Using <code>iterator</code> with replicated and distributed caches</strong></p>
</div>
<div class="paragraph">
<p>When a node is the primary or backup owner of all requested segments for a distributed stream, Infinispan performs the <code>iterator</code> or <code>spliterator</code> terminal operations locally, which optimizes performance as remote iterations are more resource intensive.</p>
</div>
<div class="paragraph">
<p>This optimization applies to both replicated and distributed caches. However, Infinispan performs iterations remotely when using cache stores that are both <code>shared</code> and have <code>write-behind</code> enabled. In this case performing the iterations remotely ensures consistency.</p>
</div>
</div>
<div class="sect2">
<h3 id="intermediate_operation_exceptions"><a class="anchor" href="#intermediate_operation_exceptions"></a>11.12. Intermediate operation exceptions</h3>
<div class="paragraph">
<p>There are some intermediate operations that have special exceptions, these are
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#skip-long-">skip</a>,
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#peek-java.util.function.Consumer-">peek</a>,
sorted <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#sorted-java.util.Comparator-">1</a>
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#sorted--">2</a>.
&amp; <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#distinct--">distinct</a>.
All of these methods have some sort of artificial iterator implanted in the stream
processing to guarantee correctness, they are documented as below.  Note this means
these operations may cause possibly severe performance degradation.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Skip</dt>
<dd>
<p>An artificial iterator is implanted up to the intermediate skip operation.
Then results are brought locally so it can skip the appropriate amount of elements.</p>
</dd>
<dt class="hdlist1">Sorted</dt>
<dd>
<p>WARNING: This operation requires having all entries in memory on the local node.
An artificial iterator is implanted up to the intermediate sorted operation.
All results are sorted locally.  There are possible plans to have a distributed sort which
returns batches of elements, but this is not yet implemented.</p>
</dd>
<dt class="hdlist1">Distinct</dt>
<dd>
<p>WARNING: This operation requires having all or nearly all entries in memory on the local node.
Distinct is performed on each remote node and then an artificial iterator returns those distinct values.
Then finally all of those results have a distinct operation performed upon them.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The rest of the intermediate operations are fully distributed as one would expect.</p>
</div>
</div>
<div class="sect2">
<h3 id="examples_2"><a class="anchor" href="#examples_2"></a>11.13. Examples</h3>
<div class="paragraph">
<p><strong>Word Count</strong></p>
</div>
<div class="paragraph">
<p>Word count is a classic, if overused, example
of map/reduce paradigm. Assume we have a mapping of key &#8594; sentence stored on
Infinispan nodes. Key is a String, each sentence is also a String, and we have
to count occurrence of all words in all sentences available. The implementation
of such a distributed task could be defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class WordCountExample {

   /**
    * In this example replace c1 and c2 with
    * real Cache references
    *
    * @param args
    */
   public static void main(String[] args) {
      Cache&lt;String, String&gt; c1 = ...;
      Cache&lt;String, String&gt; c2 = ...;

      c1.put("1", "Hello world here I am");
      c2.put("2", "Infinispan rules the world");
      c1.put("3", "JUDCon is in Boston");
      c2.put("4", "JBoss World is in Boston as well");
      c1.put("12","JBoss Application Server");
      c2.put("15", "Hello world");
      c1.put("14", "Infinispan community");
      c2.put("15", "Hello world");

      c1.put("111", "Infinispan open source");
      c2.put("112", "Boston is close to Toronto");
      c1.put("113", "Toronto is a capital of Ontario");
      c2.put("114", "JUDCon is cool");
      c1.put("211", "JBoss World is awesome");
      c2.put("212", "JBoss rules");
      c1.put("213", "JBoss division of RedHat ");
      c2.put("214", "RedHat community");

      Map&lt;String, Long&gt; wordCountMap = c1.entrySet().parallelStream()
         .map(e -&gt; e.getValue().split("\\s"))
         .flatMap(Arrays::stream)
         .collect(() -&gt; Collectors.groupingBy(Function.identity(), Collectors.counting()));
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case it is pretty simple to do the word count from the previous example.</p>
</div>
<div class="paragraph">
<p>However what if we want to find the most frequent word in the example?  If you take a second
to think about this case you will realize you need to have all words counted  and available
locally first. Thus we actually have a few options.</p>
</div>
<div class="paragraph">
<p>We could use a finisher on the collector, which is invoked on the user thread
after all the results have been collected.
Some redundant lines have been removed from the previous example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class WordCountExample {
   public static void main(String[] args) {
      // Lines removed

      String mostFrequentWord = c1.entrySet().parallelStream()
         .map(e -&gt; e.getValue().split("\\s"))
         .flatMap(Arrays::stream)
         .collect(() -&gt; Collectors.collectingAndThen(
            Collectors.groupingBy(Function.identity(), Collectors.counting()),
               wordCountMap -&gt; {
                  String mostFrequent = null;
                  long maxCount = 0;
                     for (Map.Entry&lt;String, Long&gt; e : wordCountMap.entrySet()) {
                        int count = e.getValue().intValue();
                        if (count &gt; maxCount) {
                           maxCount = count;
                           mostFrequent = e.getKey();
                        }
                     }
                     return mostFrequent;
               }));

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unfortunately the last step is only going to be ran in a single thread, which if we have a lot of
words could be quite slow.  Maybe there is another way to parallelize this with Streams.</p>
</div>
<div class="paragraph">
<p>We mentioned before we are in the local node after processing, so we could actually use
a stream on the map results.  We can therefore use a parallel stream on the results.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class WordFrequencyExample {
   public static void main(String[] args) {
      // Lines removed

      Map&lt;String, Long&gt; wordCount = c1.entrySet().parallelStream()
              .map(e -&gt; e.getValue().split("\\s"))
              .flatMap(Arrays::stream)
              .collect(() -&gt; Collectors.groupingBy(Function.identity(), Collectors.counting()));
      Optional&lt;Map.Entry&lt;String, Long&gt;&gt; mostFrequent = wordCount.entrySet().parallelStream().reduce(
              (e1, e2) -&gt; e1.getValue() &gt; e2.getValue() ? e1 : e2);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This way you can still utilize all of the cores locally when calculating the most frequent element.</p>
</div>
<div class="paragraph">
<p><strong>Remove specific entries</strong></p>
</div>
<div class="paragraph">
<p>Distributed streams can also be used as a way to modify data where it lives.
For example you may want to remove all entries in your cache that contain
a specific word.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class RemoveBadWords {
   public static void main(String[] args) {
      // Lines removed
      String word = ..

      c1.entrySet().parallelStream()
         .filter(e -&gt; e.getValue().contains(word))
         .forEach((c, e) -&gt; c.remove(e.getKey()));</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we carefully note what is serialized and what is not, we notice that only the word along
with the operations are serialized across to other nods as it is captured by the lambda.
However the real saving piece is that the cache operation is performed on the primary
owner thus reducing the amount of network traffic required to remove these values from the
cache. The cache is not captured by the lambda as we provide a special BiConsumer method
override that when invoked on each node passes the cache to the BiConsumer</p>
</div>
<div class="paragraph">
<p>One thing to keep in mind using the <code>forEach</code> command in this manner is that the underlying
stream obtains no locks. The cache remove operation will still obtain locks naturally, but
the value could have changed from what the stream saw. That means that the entry could
have been changed after the stream read it but the remove actually removed it.</p>
</div>
<div class="paragraph">
<p>We have specifically added a new variant which is called <code>LockedStream</code>.</p>
</div>
<div class="paragraph">
<p><strong>Plenty of other examples</strong></p>
</div>
<div class="paragraph">
<p>The <code>Streams</code> API is a JRE tool and there are lots of examples for using it.
Just remember that your operations need to be Serializable in some way.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jcache_jsr_107"><a class="anchor" href="#jcache_jsr_107"></a>12. JCache (JSR-107) API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Infinispan provides an implementation of
JCache 1.0 API ( <a href="http://www.jcp.org/en/jsr/detail?id=107">JSR-107</a> ).
JCache specifies a standard Java API for caching temporary Java objects in
memory. Caching java objects can help get around bottlenecks arising from
using data that is expensive to retrieve (i.e. DB or web service), or data
that is hard to calculate. Caching these type of objects in memory can help
speed up application performance by retrieving the data directly from memory
instead of doing an expensive roundtrip or recalculation. This document
specifies how to use JCache with the Infinispan implementation of the
specification, and explains key aspects of the API.</p>
</div>
<div class="sect2">
<h3 id="creating_embedded_caches"><a class="anchor" href="#creating_embedded_caches"></a>12.1. Creating embedded caches</h3>
<div class="olist arabic">
<div class="title">Prerequisites</div>
<ol class="arabic">
<li>
<p>Ensure that <code>cache-api</code> is on your classpath.</p>
</li>
<li>
<p>Add the following dependency to your <code>pom.xml</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.infinispan&lt;/groupId&gt;
  &lt;artifactId&gt;infinispan-jcache&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="ulist">
<div class="title">Procedure</div>
<ul>
<li>
<p>Create embedded caches that use the default JCache API configuration as follows:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import javax.cache.*;
import javax.cache.configuration.*;

// Retrieve the system wide cache manager
CacheManager cacheManager = Caching.getCachingProvider().getCacheManager();
// Define a named cache with default JCache configuration
Cache&lt;String, String&gt; cache = cacheManager.createCache("namedCache",
      new MutableConfiguration&lt;String, String&gt;());</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="configuring_embedded_caches"><a class="anchor" href="#configuring_embedded_caches"></a>12.1.1. Configuring embedded caches</h4>
<div class="ulist">
<ul>
<li>
<p>Pass the URI for custom Infinispan configuration to the <code>CachingProvider.getCacheManager(URI)</code> call as follows:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.net.URI;
import javax.cache.*;
import javax.cache.configuration.*;

// Load configuration from an absolute filesystem path
URI uri = URI.create("file:///path/to/infinispan.xml");
// Load configuration from a classpath resource
// URI uri = this.getClass().getClassLoader().getResource("infinispan.xml").toURI();

// Create a cache manager using the above configuration
CacheManager cacheManager = Caching.getCachingProvider().getCacheManager(uri, this.getClass().getClassLoader(), null);</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
By default, the JCache API specifies that data should be stored as
<code>storeByValue</code>, so that object state mutations outside of operations to the
cache, won&#8217;t have an impact in the objects stored in the cache. Infinispan
has so far implemented this using serialization/marshalling to make copies to
store in the cache, and that way adhere to the spec. Hence, if using default
JCache configuration with Infinispan, data stored must be marshallable.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Alternatively, JCache can be configured to store data by reference
(just like Infinispan or JDK Collections work). To do that, simply call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Cache&lt;String, String&gt; cache = cacheManager.createCache("namedCache",
      new MutableConfiguration&lt;String, String&gt;().setStoreByValue(false));</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="creating_remote_caches"><a class="anchor" href="#creating_remote_caches"></a>12.2. Creating remote caches</h3>
<div class="olist arabic">
<div class="title">Prerequisites</div>
<ol class="arabic">
<li>
<p>Ensure that <code>cache-api</code> is on your classpath.</p>
</li>
<li>
<p>Add the following dependency to your <code>pom.xml</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.infinispan&lt;/groupId&gt;
  &lt;artifactId&gt;infinispan-jcache-remote&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="ulist">
<div class="title">Procedure</div>
<ul>
<li>
<p>Create caches on remote Infinispan servers and use the default JCache API configuration as follows:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import javax.cache.*;
import javax.cache.configuration.*;

// Retrieve the system wide cache manager via org.infinispan.jcache.remote.JCachingProvider
CacheManager cacheManager = Caching.getCachingProvider("org.infinispan.jcache.remote.JCachingProvider").getCacheManager();
// Define a named cache with default JCache configuration
Cache&lt;String, String&gt; cache = cacheManager.createCache("remoteNamedCache",
      new MutableConfiguration&lt;String, String&gt;());</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="configuring_remote_caches"><a class="anchor" href="#configuring_remote_caches"></a>12.2.1. Configuring remote caches</h4>
<div class="paragraph">
<p>Hot Rod configuration files include <code>infinispan.client.hotrod.cache.*</code>
properties that you can use to customize remote caches.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Pass the URI for your <code>hotrod-client.properties</code> file to the <code>CachingProvider.getCacheManager(URI)</code> call as follows:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import javax.cache.*;
import javax.cache.configuration.*;

// Load configuration from an absolute filesystem path
URI uri = URI.create("file:///path/to/hotrod-client.properties");
// Load configuration from a classpath resource
// URI uri = this.getClass().getClassLoader().getResource("hotrod-client.properties").toURI();

// Retrieve the system wide cache manager via org.infinispan.jcache.remote.JCachingProvider
CacheManager cacheManager = Caching.getCachingProvider("org.infinispan.jcache.remote.JCachingProvider")
      .getCacheManager(uri, this.getClass().getClassLoader(), null);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="store_and_retrieve_data"><a class="anchor" href="#store_and_retrieve_data"></a>12.3. Store and retrieve data</h3>
<div class="paragraph">
<p>Even though JCache API does not extend neither
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">java.util.Map</a>
not <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html">java.util.concurrent.ConcurrentMap</a>,
it providers a key/value API to store and retrieve data:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import javax.cache.*;
import javax.cache.configuration.*;

CacheManager cacheManager = Caching.getCachingProvider().getCacheManager();
Cache&lt;String, String&gt; cache = cacheManager.createCache("namedCache",
      new MutableConfiguration&lt;String, String&gt;());
cache.put("hello", "world"); // Notice that javax.cache.Cache.put(K) returns void!
String value = cache.get("hello"); // Returns "world"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Contrary to standard <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">java.util.Map</a>,
<a href="https://github.com/jsr107/jsr107spec/blob/v1.0.0-RC1/src/main/java/javax/cache/Cache.java">javax.cache.Cache</a>
comes with two basic put methods called put and getAndPut. The former returns
<code>void</code> whereas the latter returns the previous value associated with the key.
So, the equivalent of <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#put-K-V-">java.util.Map.put(K)</a>
in JCache is <a href="https://github.com/jsr107/jsr107spec/blob/v1.0.0-RC1/src/main/java/javax/cache/Cache.java#L230">javax.cache.Cache.getAndPut(K)</a>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Even though JCache API only covers standalone caching, it can be plugged
with a persistence store, and has been designed with clustering or
distribution in mind. The reason why javax.cache.Cache offers two put methods
is because standard java.util.Map put call forces implementors to calculate
the previous value. When a persistent store is in use, or the cache is
distributed, returning the previous value could be an expensive operation, and
often users call standard <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#put-K-V-">java.util.Map.put(K)</a>
without using the return value. Hence, JCache users need to think about
whether the return value is relevant to them, in which case they need to call
<a href="https://github.com/jsr107/jsr107spec/blob/v1.0.0-RC1/src/main/java/javax/cache/Cache.java#L230">javax.cache.Cache.getAndPut(K)</a> ,
otherwise they can call <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#put-K-V-">java.util.Map.put(K, V)</a>
which avoids returning the potentially expensive operation of returning the
previous value.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="comparing_java_util_concurrent_concurrentmap_and_javax_cache_cache_apis"><a class="anchor" href="#comparing_java_util_concurrent_concurrentmap_and_javax_cache_cache_apis"></a>12.4. Comparing java.util.concurrent.ConcurrentMap and javax.cache.Cache APIs</h3>
<div class="paragraph">
<p>Here&#8217;s a brief comparison of the data manipulation APIs provided by
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html">java.util.concurrent.ConcurrentMap</a>
and <a href="https://github.com/jsr107/jsr107spec/blob/v1.0.0-RC1/src/main/java/javax/cache/Cache.java">javax.cache.Cache</a> APIs.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Operation</th>
<th class="tableblock halign-left valign-top">java.util.concurrent.ConcurrentMap&lt;K, V&gt;</th>
<th class="tableblock halign-left valign-top">javax.cache.Cache&lt;K, V&gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">store and no return</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A </p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void put(K key)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">store and return previous value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>V put(K key)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>V getAndPut(K key)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">store if not present</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>V putIfAbsent(K key, V value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean putIfAbsent(K key, V value)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">retrieve</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>V get(Object key)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>V get(K key)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">delete if present</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>V remove(Object key)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean remove(K key)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">delete and return previous value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>V remove(Object key)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>V getAndRemove(K key)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">delete conditional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean remove(Object key, Object value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean remove(K key, V oldValue)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">replace if present</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>V replace(K key, V value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean replace(K key, V value)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">replace and return previous value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>V replace(K key, V value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>V getAndReplace(K key, V value)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">replace conditional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean replace(K key, V oldValue, V newValue)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean replace(K key, V oldValue, V newValue)</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Comparing the two APIs, it&#8217;s obvious to see that, where possible, JCache
avoids returning the previous value to avoid operations doing expensive
network or IO operations. This is an overriding principle in the design of
JCache API. In fact, there&#8217;s a set of operations that are present in
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html">java.util.concurrent.ConcurrentMap</a> ,
but are not present in the <a href="https://github.com/jsr107/jsr107spec/blob/v1.0.0-RC1/src/main/java/javax/cache/Cache.java">javax.cache.Cache</a>
because they could be expensive to compute in a distributed cache.
The only exception is iterating over the contents of the cache:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Operation</th>
<th class="tableblock halign-left valign-top">java.util.concurrent.ConcurrentMap&lt;K, V&gt;</th>
<th class="tableblock halign-left valign-top">javax.cache.Cache&lt;K, V&gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">calculate size of cache</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int size()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"> N/A</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">return all keys in the cache</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Set&lt;K&gt; keySet()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"> N/A</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">return all values in the cache</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Collection&lt;V&gt; values()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"> N/A</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">return all entries in the cache</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"> N/A</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">iterate over the cache</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">use <code>iterator()</code> method on keySet, values or entrySet</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Iterator&lt;Cache.Entry&lt;K, V&gt;&gt; iterator()</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="clustering_jcache_instances"><a class="anchor" href="#clustering_jcache_instances"></a>12.5. Clustering JCache instances</h3>
<div class="paragraph">
<p>Infinispan JCache implementation goes beyond the specification in order to
provide the possibility to cluster caches using the standard API. Given a
Infinispan configuration file configured to replicate caches like this:</p>
</div>
<div class="listingblock">
<div class="title">infinispan.xml</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-xml" data-lang="xml">&lt;infinispan&gt;
   &lt;cache-container default-cache="namedCache"&gt;
      &lt;transport cluster="jcache-cluster" /&gt;
      &lt;replicated-cache name="namedCache" /&gt;
   &lt;/cache-container&gt;
&lt;/infinispan&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can create a cluster of caches using this code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import javax.cache.*;
import java.net.URI;

// For multiple cache managers to be constructed with the standard JCache API
// and live in the same JVM, either their names, or their classloaders, must
// be different.
// This example shows how to force their classloaders to be different.
// An alternative method would have been to duplicate the XML file and give
// it a different name, but this results in unnecessary file duplication.
ClassLoader tccl = Thread.currentThread().getContextClassLoader();
CacheManager cacheManager1 = Caching.getCachingProvider().getCacheManager(
      URI.create("infinispan-jcache-cluster.xml"), new TestClassLoader(tccl));
CacheManager cacheManager2 = Caching.getCachingProvider().getCacheManager(
      URI.create("infinispan-jcache-cluster.xml"), new TestClassLoader(tccl));

Cache&lt;String, String&gt; cache1 = cacheManager1.getCache("namedCache");
Cache&lt;String, String&gt; cache2 = cacheManager2.getCache("namedCache");

cache1.put("hello", "world");
String value = cache2.get("hello"); // Returns "world" if clustering is working

// --

public static class TestClassLoader extends ClassLoader {
  public TestClassLoader(ClassLoader parent) {
     super(parent);
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="multimap_cache"><a class="anchor" href="#multimap_cache"></a>13. Multimap Cache</h2>
<div class="sectionbody">
<div class="paragraph">
<p>MutimapCache is a type of Infinispan Cache that maps keys to values in which each key can contain multiple values.</p>
</div>
<div class="sect2">
<h3 id="installation_and_configuration_2"><a class="anchor" href="#installation_and_configuration_2"></a>13.1. Installation and configuration</h3>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.infinispan&lt;/groupId&gt;
  &lt;artifactId&gt;infinispan-multimap&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="multimapcache_api"><a class="anchor" href="#multimapcache_api"></a>13.2. MultimapCache API</h3>
<div class="paragraph">
<p>MultimapCache API exposes several methods to interact with the Multimap Cache.
These methods are non-blocking in most cases; see
<a href="#multimap_limitations">limitations</a> for more information.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface MultimapCache&lt;K, V&gt; {

   CompletableFuture&lt;Optional&lt;CacheEntry&lt;K, Collection&lt;V&gt;&gt;&gt;&gt; getEntry(K key);

   CompletableFuture&lt;Void&gt; remove(SerializablePredicate&lt;? super V&gt; p);

   CompletableFuture&lt;Void&gt; put(K key, V value);

   CompletableFuture&lt;Collection&lt;V&gt;&gt; get(K key);

   CompletableFuture&lt;Boolean&gt; remove(K key);

   CompletableFuture&lt;Boolean&gt; remove(K key, V value);

   CompletableFuture&lt;Void&gt; remove(Predicate&lt;? super V&gt; p);

   CompletableFuture&lt;Boolean&gt; containsKey(K key);

   CompletableFuture&lt;Boolean&gt; containsValue(V value);

   CompletableFuture&lt;Boolean&gt; containsEntry(K key, V value);

   CompletableFuture&lt;Long&gt; size();

   boolean supportsDuplicates();

}</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">CompletableFuture&lt;Void&gt; put(K key, V value)</div>
<p>Puts a key-value pair in the multimap cache.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">MultimapCache&lt;String, String&gt; multimapCache = ...;

multimapCache.put("girlNames", "marie")
             .thenCompose(r1 -&gt; multimapCache.put("girlNames", "oihana"))
             .thenCompose(r3 -&gt; multimapCache.get("girlNames"))
             .thenAccept(names -&gt; {
                          if(names.contains("marie"))
                              System.out.println("Marie is a girl name");

                           if(names.contains("oihana"))
                              System.out.println("Oihana is a girl name");
                        });</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output of this code is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Marie is a girl name
Oihana is a girl name</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">CompletableFuture&lt;Collection&lt;V&gt;&gt; get(K key)</div>
<p>Asynchronous that returns a view collection of the values associated with key in this multimap cache, if any. Any changes to the retrieved collection won&#8217;t change the values in this multimap cache.
When this method returns an empty collection, it means the key was not found.</p>
</div>
<div class="paragraph">
<div class="title">CompletableFuture&lt;Boolean&gt; remove(K key)</div>
<p>Asynchronous that removes the entry associated with the key from the multimap cache, if such exists.</p>
</div>
<div class="paragraph">
<div class="title">CompletableFuture&lt;Boolean&gt; remove(K key, V value)</div>
<p>Asynchronous that removes a key-value pair from the multimap cache, if such exists.</p>
</div>
<div class="paragraph">
<div class="title">CompletableFuture&lt;Void&gt; remove(Predicate&lt;? super V&gt; p)</div>
<p>Asynchronous method. Removes every value that match the given predicate.</p>
</div>
<div class="paragraph">
<div class="title">CompletableFuture&lt;Boolean&gt; containsKey(K key)</div>
<p>Asynchronous that returns true if this multimap contains the key.</p>
</div>
<div class="paragraph">
<div class="title">CompletableFuture&lt;Boolean&gt; containsValue(V value)</div>
<p>Asynchronous that returns true if this multimap contains the value in at least one key.</p>
</div>
<div class="paragraph">
<div class="title">CompletableFuture&lt;Boolean&gt; containsEntry(K key, V value)</div>
<p>Asynchronous that returns true if this multimap contains at least one key-value pair with the value.</p>
</div>
<div class="paragraph">
<div class="title">CompletableFuture&lt;Long&gt; size()</div>
<p>Asynchronous that returns the number of key-value pairs in the multimap cache. It doesn&#8217;t return the distinct number of keys.</p>
</div>
<div class="paragraph">
<div class="title">boolean supportsDuplicates()</div>
<p>Asynchronous that returns true if the multimap cache supports duplicates. This means that the content of the multimap can be
'a' &#8594; ['1', '1', '2']. For now this method will always return false, as duplicates are not yet supported.
The existence of a given value is determined by 'equals' and `hashcode' method&#8217;s contract.</p>
</div>
</div>
<div class="sect2">
<h3 id="creating_a_multimap_cache"><a class="anchor" href="#creating_a_multimap_cache"></a>13.3. Creating a Multimap Cache</h3>
<div class="paragraph">
<p>Currently the MultimapCache is configured as a regular cache. This can be done either by code or XML configuration.
See how to configure a regular Cache in the section link to [configure a cache].</p>
</div>
<div class="sect3">
<h4 id="embedded_mode"><a class="anchor" href="#embedded_mode"></a>13.3.1. Embedded mode</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// create or obtain your EmbeddedCacheManager
EmbeddedCacheManager cm = ... ;

// create or obtain a MultimapCacheManager passing the EmbeddedCacheManager
MultimapCacheManager multimapCacheManager = EmbeddedMultimapCacheManagerFactory.from(cm);

// define the configuration for the multimap cache
multimapCacheManager.defineConfiguration(multimapCacheName, c.build());

// get the multimap cache
multimapCache = multimapCacheManager.get(multimapCacheName);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="multimap_limitations"><a class="anchor" href="#multimap_limitations"></a>13.4. Limitations</h3>
<div class="paragraph">
<p>In almost every case the Multimap Cache will behave as a regular Cache, but some limitations exist in the current version, as follows:</p>
</div>
<div class="sect3">
<h4 id="support_for_duplicates"><a class="anchor" href="#support_for_duplicates"></a>13.4.1. Support for duplicates</h4>
<div class="paragraph">
<p>Duplicates are not supported yet. This means that the multimap won&#8217;t contain any duplicate key-value pair.
Whenever put method is called, if the key-value pair already exist, this key-value par won&#8217;t be added.
Methods used to check if a key-value pair is already present in the Multimap are the <code>equals</code> and <code>hashcode</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="eviction"><a class="anchor" href="#eviction"></a>13.4.2. Eviction</h4>
<div class="paragraph">
<p>For now, the eviction works per key, and not per key-value pair.
This means that whenever a key is evicted, all the values associated with the key will be evicted too.</p>
</div>
</div>
<div class="sect3">
<h4 id="transactions"><a class="anchor" href="#transactions"></a>13.4.3. Transactions</h4>
<div class="paragraph">
<p>Implicit transactions are supported through the auto-commit and all the methods are non blocking.
Explicit transactions work without blocking in most of the cases.
Methods that will block are <code>size</code>, <code>containsEntry</code> and <code>remove(Predicate&lt;? super V&gt; p)</code></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="anchored_keys_module"><a class="anchor" href="#anchored_keys_module"></a>14. Anchored Keys module</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Infinispan version 11 introduces an experimental module that allows scaling up a cluster
and adding new nodes without expensive <strong>state transfer</strong>.</p>
</div>
<div class="sect2">
<h3 id="background"><a class="anchor" href="#background"></a>14.1. Background</h3>
<div class="paragraph">
<p>For background, the preferred way to scale up the storage capacity of a Infinispan cluster
is to use distributed caches.
A distributed cache stores each key/value pair on <code>num-owners</code> nodes,
and each node can compute the location of a key (aka the key owners) directly.</p>
</div>
<div class="paragraph">
<p>Infinispan achieves this by statically mapping cache keys to <code>num-segments</code> <strong>consistent hash segments</strong>,
and then dynamically mapping segments to nodes based on the cache&#8217;s <strong>topology</strong>
(roughly the current plus the historical membership of the cache).
Whenever a new node joins the cluster, the cache is <strong>rebalanced</strong>, and the new node replaces an existing node
as the owner of some segments.
The key/value pairs in those segments are copied to the new node and removed from the no-longer-owner node
via <strong>state transfer</strong>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Because the allocation of segments to nodes is based on random UUIDs generated at start time,
it is common (though less so after
<a href="https://issues.redhat.com/browse/ISPN-11679">ISPN-11679</a>
), for segments to also move from one old node to another old node.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="architecture"><a class="anchor" href="#architecture"></a>14.2. Architecture</h3>
<div class="paragraph">
<p>The basic idea is to skip the static mapping of keys to segments and to map keys directly to nodes.</p>
</div>
<div class="paragraph">
<p>When a key/value pair is inserted into the cache,
the newest member becomes the <strong>anchor owner</strong> of that key, and the only node storing the actual value.
In order to make the anchor location available without an extra remote lookup,
all the other nodes store a reference to the anchor owner.</p>
</div>
<div class="paragraph">
<p>That way, when another node joins, it only needs to receive the location information from the existing nodes,
and values can stay on the anchor owner, minimizing the amount of traffic.</p>
</div>
</div>
<div class="sect2">
<h3 id="limitations"><a class="anchor" href="#limitations"></a>14.3. Limitations</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Only one node can be added at a time</dt>
<dd>
<p>An external actor (e.g. a Kubernetes/OpenShift operator, or a human administrator)
must monitor the load on the current nodes, and add a new node whenever the newest node
is close to "full".</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Because the anchor owner information is replicated on all the nodes, and values are never moved off a node,
the memory usage of each node will keep growing as new entries and nodes are added.
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">There is no redundancy</dt>
<dd>
<p>Every value is only stored on a single node.
When a node crashes or even stops gracefully, the values stored on that node are lost.</p>
</dd>
<dt class="hdlist1">Transactions are not supported</dt>
<dd>
<p>A later version may add transaction support, but the fact that any node stop or crash
loses entries makes transactions a lot less valuable compared to a distributed cache.</p>
</dd>
<dt class="hdlist1">Hot Rod clients do not know the anchor owner</dt>
<dd>
<p>Hot Rod clients cannot use the topology information from the servers to locate the anchor owner.
Instead, the server receiving a Hot Rod get request must make an additional request to the anchor owner
in order to retrieve the value.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="configuration"><a class="anchor" href="#configuration"></a>14.4. Configuration</h3>
<div class="paragraph">
<p>The module is still very young and does not yet support many Infinispan features.</p>
</div>
<div class="paragraph">
<p>Eventually, if it proves useful, it may become another cache mode, just like scattered caches.
For now, configuring a cache with anchored keys requires a replicated cache with a custom element <code>anchored-keys</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;infinispan
      xmlns="urn:infinispan:config:14.0"
      xmlns:anchored="urn:infinispan:config:anchored:14.0"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="urn:infinispan:config:14.0
            https://infinispan.org/schemas/infinispan-config-14.0.xsd
            urn:infinispan:config:anchored:14.0
            https://infinispan.org/schemas/infinispan-anchored-config-14.0.xsd"&gt;

    &lt;cache-container default-cache="default"&gt;
        &lt;transport/&gt;
        &lt;replicated-cache name="default"&gt;
            &lt;anchored:anchored-keys/&gt;
        &lt;/replicated-cache&gt;
    &lt;/cache-container&gt;

&lt;/infinispan&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the <code>&lt;anchored-keys/&gt;</code> element is present, the module automatically enables anchored keys
and makes some required configuration changes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Disables <code>await-initial-transfer</code></p>
</li>
<li>
<p>Enables conflict resolution with the equivalent of</p>
<div class="paragraph">
<p><code>&lt;partition-handling when-split="ALLOW_READ_WRITES" merge-policy="PREFER_NON_NULL"/&gt;</code></p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The cache will fail to start if these attributes are explicitly set to other values,
if state transfer is disabled, or if transactions are enabled.</p>
</div>
</div>
<div class="sect2">
<h3 id="implementation_status"><a class="anchor" href="#implementation_status"></a>14.5. Implementation status</h3>
<div class="paragraph">
<p>Basic operations are implemented: <code>put</code>, <code>putIfAbsent</code>, <code>get</code>, <code>replace</code>, <code>remove</code>, <code>putAll</code>, <code>getAll</code>.</p>
</div>
<div class="sect3">
<h4 id="functional_commands"><a class="anchor" href="#functional_commands"></a>14.5.1. Functional commands</h4>
<div class="paragraph">
<p>The <code>FunctionalMap</code> API is not implemented.</p>
</div>
<div class="paragraph">
<p>Other operations that rely on the functional API&#8217;s implementation do not work either: <code>merge</code>, <code>compute</code>,
<code>computeIfPresent</code>, <code>computeIfAbsent</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="partition_handling"><a class="anchor" href="#partition_handling"></a>14.5.2. Partition handling</h4>
<div class="paragraph">
<p>When a node crashes, surviving nodes do not remove anchor references pointing to that node.
In theory, this could allow merges to skip conflict resolution, but currently the <code>PREFERRED_NON_NULL</code>
merge policy is configured automatically and cannot be changed.</p>
</div>
</div>
<div class="sect3">
<h4 id="listeners"><a class="anchor" href="#listeners"></a>14.5.3. Listeners</h4>
<div class="paragraph">
<p>Cluster listeners and client listeners are implemented and receive the correct notifications.</p>
</div>
<div class="paragraph">
<p>Non-clustered embedded listeners currently receive notifications on all the nodes, not just the node
where the value is stored.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="performance_considerations"><a class="anchor" href="#performance_considerations"></a>14.6. Performance considerations</h3>
<div class="sect3">
<h4 id="clientserver_latency"><a class="anchor" href="#clientserver_latency"></a>14.6.1. Client/Server Latency</h4>
<div class="paragraph">
<p>The client always contacts the primary owner, so any read has a
<code>(N-1)/N</code> probability of requiring a unicast RPC from the primary to the anchor owner.</p>
</div>
<div class="paragraph">
<p>Writes require the primary to send the value to one node and the anchor address
to all the other nodes, which is currently done with <code>N-1</code> unicast RPCs.</p>
</div>
<div class="paragraph">
<p>In theory we could send in parallel one unicast RPC for the value and one multicast RPC for the address,
but that would need additional logic to ignore the address on the anchor owner
and with TCP multicast RPCs are implemented as parallel unicasts anyway.</p>
</div>
</div>
<div class="sect3">
<h4 id="memory_overhead"><a class="anchor" href="#memory_overhead"></a>14.6.2. Memory overhead</h4>
<div class="paragraph">
<p>Compared to a distributed cache with one owner, an anchored-keys cache
contains copies of all the keys and their locations, plus the overhead of the cache itself.</p>
</div>
<div class="paragraph">
<p>Therefore, a node with anchored-keys caches should stop accepting new entries when it has less than
<code>(&lt;key size&gt; + &lt;per-key overhead&gt;) * &lt;number of entries not yet inserted&gt;</code> bytes available.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The number of entries not yet inserted is obviously very hard to estimate.
In the future we may provide a way to limit the overhead of key location information,
e.g. by using a distributed cache.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The per-key overhead is lowest for off-heap storage, around 63 bytes:
8 bytes for the entry reference in <code>MemoryAddressHash.memory</code>,
29 bytes for the off-heap entry header,
and 26 bytes for the serialized <code>RemoteMetadata</code> with the owner&#8217;s address.</p>
</div>
<div class="paragraph">
<p>The per-key overhead of the ConcurrentHashMap-based on-heap cache,
assuming a 64-bit JVM with compressed OOPS, would be around 92 bytes:
32 bytes for <code>ConcurrentHashMap.Node</code>, 32 bytes for <code>MetadataImmortalCacheEntry</code>,
24 bytes for <code>RemoteMetadata</code>, and 4 bytes in the <code>ConcurrentHashMap.table</code> array.</p>
</div>
</div>
<div class="sect3">
<h4 id="state_transfer"><a class="anchor" href="#state_transfer"></a>14.6.3. State transfer</h4>
<div class="paragraph">
<p>State transfer does not transfer values, only keys and anchor owner information.</p>
</div>
<div class="paragraph">
<p>Assuming that the values are much bigger compared to the keys,
state transfer for an anchored keys cache should also be much faster
compared to the state transfer of a distributed cache of a similar size.
But for small values, there may not be a visible improvement.</p>
</div>
<div class="paragraph">
<p>The initial state transfer does not block a joiner from starting,
because it will just ask another node for the anchor owner.
However, the remote lookups can be expensive, especially in embedded mode,
but also in server mode, if the client is not <code>HASH_DISTRIBUTION_AWARE</code>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cloudevents_integration_module"><a class="anchor" href="#cloudevents_integration_module"></a>15. CloudEvents Integration Module (Experimental)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Infinispan version 12 introduces an experimental module that converts
Infinispan events to CloudEvents events and sends them to a Kafka topic
in structured mode, with the JSON format.</p>
</div>
<div class="paragraph">
<p>This allows Infinispan be further used as a Knative source.</p>
</div>
<div class="paragraph">
<p>There are two broad kinds of events, and they can be sent to different
Kafka topics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cache entry modifications: created, updated, removed, expired</p>
</li>
<li>
<p>Audit events: user login, access denied</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="configuration_2"><a class="anchor" href="#configuration_2"></a>15.1. Configuration</h3>
<div class="paragraph">
<p>CloudEvents integration is enabled by adding the module to the global
configuration and configuring at least a list of bootstrap Kafka servers
and a topic.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;infinispan
xmlns="urn:infinispan:config:14.0"
xmlns:ce="urn:infinispan:config:cloudevents:14.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="urn:infinispan:config:14.0
https://infinispan.org/schemas/infinispan-config-14.0.xsd
urn:infinispan:config:cloudevents:14.0
https://infinispan.org/schemas/infinispan-cloudevents-config-14.0.xsd"&gt;

    &lt;cache-container default-cache="default"&gt;
        &lt;transport/&gt;
        &lt;ce:cloudevents bootstrap-servers="127.0.0.1:9092"
                                   audit-topic="audit"
                                   cache-entries-topic="cache-events"/&gt;

        &lt;replicated-cache name="default"&gt;
            &lt;ce:cloudevents-cache enabled="false"/&gt;
        &lt;/replicated-cache&gt;
    &lt;/cache-container&gt;

&lt;/infinispan&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-java" data-lang="java">GlobalConfigurationBuilder managerBuilder = GlobalConfigurationBuilder.defaultClusteredBuilder();
CloudEventsGlobalConfigurationBuilder cloudEventsGlobalBuilder =
    managerBuilder.addModule(CloudEventsGlobalConfigurationBuilder.class);
cloudEventsGlobalBuilder.bootstrapServers("localhost:9092");
cloudEventsGlobalBuilder.cacheEntriesTopic("ispn");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Currently only the list of bootstrap servers, the number of acks, and the
cache entries/audit topic names are configurable.</p>
</div>
</div>
<div class="sect2">
<h3 id="event_format"><a class="anchor" href="#event_format"></a>15.2. Event Format</h3>
<div class="paragraph">
<p>The events are sent in
<a href="https://github.com/cloudevents/spec/blob/v1.0/kafka-protocol-binding.md#13-content-modes">Kafka structured mode</a>,
in the
<a href="https://github.com/cloudevents/spec/blob/v1.0/json-format.md">JSON event format</a></p>
</div>
<div class="paragraph">
<p>This is an example of an event:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-json" data-lang="json">{
    "specversion": "1.0",
    "source": "/infinispan/CLUSTER/testCache",
    "type": "org.infinispan.entry.created",
    "time": "2020-10-29T22:05:08.767950Z",
    "subject": "key-1",
    "id": "key-1:CommandInvocation:Test-NodeA:0",
    "data": {
       "property": "value"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>source</code> field starts with <code>/infinispan/</code>, then the cluster name,
and ends with the cache name.</p>
</div>
<div class="paragraph">
<p>The <code>type</code> field is a straightforward mapping of the Infinispan cache entry
event types, prefixed with <code>org.infinispan.entry</code>.</p>
</div>
<div class="paragraph">
<p>The <code>data</code> field is the new entry value (or the old value, for remove events).
If the value is Protostream-encoded, a Java object that can be marshalled
to Protostream, or a Java primitive wrapper, it is converted to JSON.
If the value is not encoded with Protostream or it is a Java object
and the cache manager is configured to use another marshaller,
the marshalled value is written as a string.
If the marshalled value is not a valid UTF-8 string, it is first Base64-encoded.</p>
</div>
<div class="paragraph">
<p>The <code>subject</code> field is the affected cache key, converted to a string
using the same mechanism as the values.
The only difference is that the resulting JSON is also wrapped in a string.</p>
</div>
<div class="paragraph">
<p>TODO: The JSON conversion currently adds <code>\n</code> and space characters,
which are escaped and preserved in the <code>subject</code> field value.
We may want to Base64-encode protostream keys instead.</p>
</div>
<div class="paragraph">
<p>The <code>id</code> field is composed from the key and a transaction/invocation id.
Expiration events do not have an invocation id, so a random id is generated
instead.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ispn_modules"><a class="anchor" href="#ispn_modules"></a>16. Infinispan Modules for WildFly</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To use Infinispan inside applications deployed to WildFly, you should install Infinispan modules that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Let you deploy applications without packaging Infinispan JAR files in your WAR or EAR file.</p>
</li>
<li>
<p>Allow you to use a Infinispan version that is independent to the one bundled with WildFly.</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Infinispan modules are deprecated and planned for removal.
These modules provide a temporary solution until WildFly directly manages the <code>infinispan</code> subsystem.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="install_ispn_modules"><a class="anchor" href="#install_ispn_modules"></a>16.1. Installing Infinispan Modules</h3>
<div class="paragraph">
<p>Download and install Infinispan modules for WildFly.</p>
</div>
<div class="olist arabic">
<div class="title">Prerequisites</div>
<ol class="arabic">
<li>
<p>JDK 8 or later.</p>
</li>
<li>
<p>An existing WildFly installation.</p>
</li>
</ol>
</div>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Download the ZIP archive for the  modules from the <a href="https://infinispan.org/download/">Infinispan software downloads</a>.</p>
</li>
<li>
<p>Extract the ZIP archive and copy the contents of <code>modules</code> to the <code>modules</code> directory of your WildFly installation so that you get the resulting structure:</p>
<div class="paragraph">
<p><code>$WILDFLY_HOME/modules/system/add-ons/ispn/org/infinispan/ispn-14.0</code></p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="configure_ispn_modules"><a class="anchor" href="#configure_ispn_modules"></a>16.2. Configuring Applications to Use Infinispan Modules</h3>
<div class="paragraph">
<p>After you install Infinispan modules for WildFly, configure your application to use Infinispan functionality.</p>
</div>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>In your project <code>pom.xml</code> file, mark the required Infinispan dependencies as <em>provided</em>.</p>
</li>
<li>
<p>Configure your artifact archiver to generate the appropriate <code>MANIFEST.MF</code> file.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-xml" data-lang="xml">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.infinispan&lt;/groupId&gt;
    &lt;artifactId&gt;infinispan-core&lt;/artifactId&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.infinispan&lt;/groupId&gt;
    &lt;artifactId&gt;infinispan-cachestore-jdbc&lt;/artifactId&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
&lt;build&gt;
  &lt;plugins&gt;
     &lt;plugin&gt;
       &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
       &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
       &lt;configuration&gt;
         &lt;archive&gt;
           &lt;manifestEntries&gt;
             &lt;Dependencies&gt;org.infinispan:ispn-14.0 services&lt;/Dependencies&gt;
           &lt;/manifestEntries&gt;
         &lt;/archive&gt;
      &lt;/configuration&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Infinispan functionality is packaged as a single module, <code>org.infinispan</code>,
that you can add as an entry to your application&#8217;s manifest as follows:</p>
</div>
<div class="listingblock">
<div class="title">MANIFEST.MF</div>
<div class="content">
<pre class="highlight"><code>Manifest-Version: 1.0
Dependencies: org.infinispan:ispn-14.0 services</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">AWS dependencies</div>
<p>If you require AWS dependencies, such as S3_PING, add the following module to your application&#8217;s manifest:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Manifest-Version: 1.0
Dependencies: com.amazonaws.aws-java-sdk:ispn-14.0 services</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="custom_interceptors_chapter"><a class="anchor" href="#custom_interceptors_chapter"></a>17. Custom Interceptors</h2>
<div class="sectionbody">
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Custom interceptors are deprecated in Infinispan and will be removed in a
future version.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Custom interceptors are a way of extending Infinispan by being able to influence or respond to any modifications to cache. Example of such modifications are: elements are added/removed/updated or transactions are committed.</p>
</div>
<div class="sect2">
<h3 id="adding_custom_interceptors_declaratively"><a class="anchor" href="#adding_custom_interceptors_declaratively"></a>17.1. Adding custom interceptors declaratively</h3>
<div class="paragraph">
<p>Custom interceptors can be added on a per named cache basis. This is because each named cache have its own interceptor stack. Following xml snippet depicts the ways in which a custom interceptor can be added.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-xml" data-lang="xml">&lt;local-cache name="cacheWithCustomInterceptors"&gt;
  &lt;!-- Define custom interceptors. --&gt;
  &lt;!-- Custom interceptors should extend
       org.infinispan.interceptors.BaseCustomAsyncInterceptor --&gt;
  &lt;custom-interceptors&gt;
    &lt;interceptor position="FIRST" class="com.mycompany.CustomInterceptor1"&gt;
      &lt;property name="attributeOne"&gt;value1&lt;/property&gt;
      &lt;property name="attributeTwo"&gt;value2&lt;/property&gt;
    &lt;/interceptor&gt;
    &lt;interceptor position="LAST" class="com.mycompany.CustomInterceptor2"/&gt;
    &lt;interceptor index="3" class="com.mycompany.CustomInterceptor1"/&gt;
    &lt;interceptor before="org.infinispanpan.interceptors.CallInterceptor"
                 class="com.mycompany.CustomInterceptor2"/&gt;
    &lt;interceptor after="org.infinispanpan.interceptors.CallInterceptor"
                 class="com.mycompany.CustomInterceptor1"/&gt;
  &lt;/custom-interceptors&gt;
&lt;/local-cache&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="adding_custom_interceptors_programmatically"><a class="anchor" href="#adding_custom_interceptors_programmatically"></a>17.2. Adding custom interceptors programmatically</h3>
<div class="paragraph">
<p>In order to do that one needs to obtain a reference to the <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/AdvancedCache.html"><code>AdvancedCache</code></a>. This can be done as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">CacheManager cm = getCacheManager();//magic
Cache aCache = cm.getCache("aName");
AdvancedCache advCache = aCache.getAdvancedCache();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then one of the <em>addInterceptor()</em> methods should be used to add the actual interceptor. For further documentation refer to <a href="https://docs.jboss.org/infinispan/14.0/apidocs/org/infinispan/AdvancedCache.html"><code>AdvancedCache</code></a> javadoc.</p>
</div>
</div>
<div class="sect2">
<h3 id="custom_interceptor_design"><a class="anchor" href="#custom_interceptor_design"></a>17.3. Custom interceptor design</h3>
<div class="paragraph">
<p>When writing a custom interceptor, you need to abide by the following rules.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Custom interceptors must declare a public, empty constructor to enable construction.</p>
</li>
<li>
<p>Custom interceptors will have setters for any property defined through property tags used in the XML configuration.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="extending"><a class="anchor" href="#extending"></a>18. Extending Infinispan</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Infinispan can be extended to provide the ability for an end user to add
additional configurations, operations and components outside of the scope of the ones normally provided by Infinispan.</p>
</div>
<div class="sect2">
<h3 id="custom_commands"><a class="anchor" href="#custom_commands"></a>18.1. Custom Commands</h3>
<div class="paragraph">
<p>Infinispan makes use of a <a href="http://en.wikipedia.org/wiki/Command_pattern">command/visitor pattern</a> to
implement the various top-level methods you see on the public-facing API.</p>
</div>
<div class="paragraph">
<p>While the core commands - and their corresponding visitors - are hard-coded as
a part of Infinispan&#8217;s core module, module authors can extend and enhance Infinispan
by creating new custom commands.</p>
</div>
<div class="paragraph">
<p>As a module author (such as <a href="https://github.com/infinispan/infinispan/tree/main/query">infinispan-query</a>, etc.) you can define your own commands.</p>
</div>
<div class="paragraph">
<p>You do so by:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a <code>META-INF/services/org.infinispan.commands.module.ModuleCommandExtensions</code> file and ensure this is packaged in your jar.</p>
</li>
<li>
<p>Implementing <a href="https://github.com/infinispan/infinispan/blob/main/core/src/main/java/org/infinispan/commands/module/ModuleCommandFactory.java"><code>ModuleCommandFactory</code></a> and
<a href="https://github.com/infinispan/infinispan/blob/main/core/src/main/java/org/infinispan/commands/module/ModuleCommandExtensions.java"><code>ModuleCommandExtensions</code></a></p>
</li>
<li>
<p>Specifying the fully-qualified class name of the  <a href="https://github.com/infinispan/infinispan/blob/main/core/src/main/java/org/infinispan/commands/module/ModuleCommandExtensions.java"><code>ModuleCommandExtensions</code></a>
implementation in <code>META-INF/services/org.infinispan.commands.module.ModuleCommandExtensions</code>.</p>
</li>
<li>
<p>Implement your custom commands and visitors for these commands</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="an_example"><a class="anchor" href="#an_example"></a>18.1.1. An Example</h4>
<div class="paragraph">
<p>Here is an example of an <code>META-INF/services/org.infinispan.commands.module.ModuleCommandExtensions</code> file, configured accordingly:</p>
</div>
<div class="listingblock">
<div class="title">org.infinispan.commands.module.ModuleCommandExtensions</div>
<div class="content">
<pre>org.infinispan.query.QueryModuleCommandExtensions</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="preassigned_custom_command_id_ranges"><a class="anchor" href="#preassigned_custom_command_id_ranges"></a>18.1.2. Preassigned Custom Command Id Ranges</h4>
<div class="paragraph">
<p>This is the list of <code>Command</code> identifiers that are used by Infinispan based modules or frameworks.
Infinispan users should avoid using ids within these ranges. (RANGES to be finalised yet!)
Being this a single byte, ranges can&#8217;t be too large.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Infinispan Query:</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100 - 119</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hibernate Search:</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">120 - 139</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hot Rod Server:</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">140 - 141</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="extending_the_configuration_builders_and_parsers"><a class="anchor" href="#extending_the_configuration_builders_and_parsers"></a>18.2. Extending the configuration builders and parsers</h3>
<div class="paragraph">
<p>If your custom module requires configuration, it is possible to enhance Infinispan&#8217;s configuration builders and
parsers. Look at the <a href="https://github.com/infinispan/infinispan/blob/main/core/src/test/java/org/infinispan/configuration/module">custom module tests</a>
for a detail example on how to implement this.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2022-03-01 12:40:45 -0500
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-8601422-1', 'auto');
  ga('send', 'pageview');

</script>

</body>
</html>