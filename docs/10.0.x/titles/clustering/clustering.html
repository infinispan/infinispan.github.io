<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]--> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <meta name="generator" content="Asciidoctor 1.5.8"> <title>Creating Infinispan Clusters</title> <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"> <style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Uncomment @import statement below to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock pre.nowrap,.literalblock pre.nowrap pre,.listingblock pre.nowrap,.listingblock pre.nowrap pre{white-space:pre;word-wrap:normal}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #dddddf}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt,.quoteblock .quoteblock{margin:0 0 1.25em;padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd){background:#f8f8f7}
table.stripes-none tr,table.stripes-odd tr:nth-of-type(even){background:none}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style> <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"> <style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style> <link rel="canonical" href="http://infinispan.org/docs/stable/user_guide/user_guide.html"> <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.1/themes/default/style.min.css"> <link rel="stylesheet" href="../../css/css.css"> <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.1/jstree.min.js"></script> <script src="../../js/js.js"></script> </head> <body class="book toc2 toc-left"> <div id="header"> <h1>Creating Infinispan Clusters</h1> <div id="toc" class="toc2"> <div id="toctitle">Table of Contents</div> <ul class="sectlevel1"> <li><a href="#clustering">1. Clustering</a> <ul class="sectlevel2"> <li><a href="#which_cache_mode_should_i_use">1.1. Which cache mode should I use?</a></li> <li><a href="#local_mode">1.2. Local Mode</a></li> </ul> </li> <li><a href="#simple_cache">2. Simple Cache</a> <ul class="sectlevel2"> <li><a href="#declarative_configuration">2.1. Declarative configuration</a></li> <li><a href="#programmatic_configuration">2.2. Programmatic configuration</a></li> <li><a href="#invalidation_mode">2.3. Invalidation Mode</a></li> <li><a href="#replicated_mode">2.4. Replicated Mode</a></li> <li><a href="#distribution_mode">2.5. Distribution Mode</a> <ul class="sectlevel3"> <li><a href="#read_consistency">2.5.1. Read consistency</a></li> <li><a href="#key_ownership">2.5.2. Key Ownership</a> <ul class="sectlevel4"> <li><a href="#capacity_factors">Capacity Factors</a></li> <li><a href="#zero_capacity_node">Zero Capacity Node</a></li> <li><a href="#hashing_configuration">Hashing Configuration</a></li> </ul> </li> <li><a href="#initial_cluster_size">2.5.3. Initial cluster size</a></li> <li><a href="#l1_caching">2.5.4. L1 Caching</a></li> <li><a href="#server_hinting">2.5.5. Server Hinting</a> <ul class="sectlevel4"> <li><a href="#configuration">Configuration</a></li> </ul> </li> <li><a href="#key_affinity_service">2.5.6. Key affinity service</a> <ul class="sectlevel4"> <li><a href="#api">API</a></li> <li><a href="#lifecycle">Lifecycle</a></li> <li><a href="#topology_changes">Topology changes</a></li> <li><a href="#grouping_api">The Grouping API</a></li> <li><a href="#how_does_it_work">How does it work?</a></li> <li><a href="#how_do_i_use_the_grouping_api">How do I use the grouping API?</a></li> <li><a href="#advanced_interface">Advanced Interface</a></li> </ul> </li> </ul> </li> <li><a href="#scattered_mode">2.6. Scattered Mode</a></li> <li><a href="#asynchronous_options">2.7. Asynchronous Options</a> <ul class="sectlevel3"> <li><a href="#asynchronous_communications">2.7.1. Asynchronous Communications</a></li> <li><a href="#asynchronous_api">2.7.2. Asynchronous API</a></li> <li><a href="#return_values">2.7.3. Return Values</a></li> </ul> </li> <li><a href="#partition_handling">2.8. Partition handling</a> <ul class="sectlevel3"> <li><a href="#split_brain">2.8.1. Split brain</a> <ul class="sectlevel4"> <li><a href="#split_strategies">Split Strategies</a> <ul class="sectlevel5"> <li><a href="#allow_read_writes">ALLOW_READ_WRITES</a></li> <li><a href="#deny_read_writes">DENY_READ_WRITES</a></li> <li><a href="#allow_reads">ALLOW_READS</a></li> </ul> </li> <li><a href="#current_limitations">Current limitations</a></li> </ul> </li> <li><a href="#successive_node_failures">2.8.2. Successive nodes stopped</a></li> <li><a href="#conflict_manager">2.8.3. Conflict Manager</a> <ul class="sectlevel4"> <li><a href="#detecting_conflicts">Detecting Conflicts</a></li> <li><a href="#merge_policies">Merge Policies</a></li> </ul> </li> <li><a href="#conflict_manager_usage">2.8.4. Usage</a></li> <li><a href="#partition_handling_configuration">2.8.5. Configuring partition handling</a> <ul class="sectlevel4"> <li><a href="#partition_handling_custom_merge_policy">Implement a custom merge policy</a></li> <li><a href="#deploy_custom_merge_policies_to_a_infinispan_server_instance">Deploy custom merge policies to a Infinispan server instance</a></li> </ul> </li> <li><a href="#partition_handling_monitoring">2.8.6. Monitoring and administration</a></li> </ul> </li> </ul> </li> </ul> </div> </div> <div id="content"> <div class="sect1"> <h2 id="clustering"><a class="anchor" href="#clustering"></a>1. Clustering</h2> <div class="sectionbody"> <div class="paragraph"> <p>A cache manager can be configured to be either local (standalone) or clustered. When clustered, manager instances use JGroups' discovery protocols to automatically discover neighboring instances on the same local network and form a cluster.</p> </div> <div class="paragraph"> <p>Creating a local-only cache manager is trivial: just use the no-argument <code>DefaultCacheManager</code> constructor, or supply the following XML configuration file.</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;infinispan</span><span class="tag">/&gt;</span></code></pre> </div> </div> <div class="paragraph"> <p>To start a clustered cache manager, you need to create a clustered configuration.</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java">GlobalConfigurationBuilder gcb = GlobalConfigurationBuilder.defaultClusteredBuilder();
DefaultCacheManager manager = <span class="keyword">new</span> DefaultCacheManager(gcb.build());</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;infinispan&gt;</span>
  <span class="tag">&lt;cache-container&gt;</span>
    <span class="tag">&lt;transport</span><span class="tag">/&gt;</span>
  <span class="tag">&lt;/cache-container&gt;</span>
<span class="tag">&lt;/infinispan&gt;</span></code></pre> </div> </div> <div class="paragraph"> <p>Individual caches can then be configured in different modes:</p> </div> <div class="ulist"> <ul> <li> <p><strong>Local</strong>: changes and reads are never replicated. This is the only mode available in non-clustered cache managers.</p> </li> <li> <p><strong>Invalidation</strong>: changes are not replicated, instead the key is invalidated on all nodes; reads are local.</p> </li> <li> <p><strong>Replicated</strong>: changes are replicated to all nodes, reads are always local.</p> </li> <li> <p><strong>Distributed</strong>: changes are replicated to a fixed number of nodes, reads request the value from at least one of the owner nodes.</p> </li> </ul> </div> <div class="sect2"> <h3 id="which_cache_mode_should_i_use"><a class="anchor" href="#which_cache_mode_should_i_use"></a>1.1. Which cache mode should I use?</h3> <div class="paragraph"> <p>Which cache you should use depends on the qualities/guarantees you need for your data. The following table summarizes the most important ones:</p> </div> <table class="tableblock frame-all grid-all stretch"> <colgroup> <col style="width: 18.1818%;"> <col style="width: 13.6363%;"> <col style="width: 13.6363%;"> <col style="width: 13.6363%;"> <col style="width: 13.6363%;"> <col style="width: 13.6363%;"> <col style="width: 13.6367%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"></th> <th class="tableblock halign-center valign-top">Simple</th> <th class="tableblock halign-center valign-top">Local</th> <th class="tableblock halign-center valign-top">Invalidation</th> <th class="tableblock halign-center valign-top">Replicated</th> <th class="tableblock halign-center valign-top">Distributed</th> <th class="tableblock halign-center valign-top">Scattered</th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Clustered</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="red">No</strong></p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="red">No</strong></p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="green">Yes</strong></p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="green">Yes</strong></p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="green">Yes</strong></p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="green">Yes</strong></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Read performance</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="green">Highest</strong><br> (local)</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="green">High</strong><br> (local)</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="green">High</strong><br> (local)</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="green">High</strong><br> (local)</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="yellow">Medium</strong><br> (owners)</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="yellow">Medium</strong><br> (primary)</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Write performance</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="green">Highest</strong><br> (local)</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="green">High</strong><br> (local)</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="red">Low</strong><br> (all nodes, no data)</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="red">Lowest</strong><br> (all nodes)</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="yellow">Medium</strong><br> (owner nodes)</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="yellow">Higher</strong><br> (single RPC)</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Capacity</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="red">Single node</strong></p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="red">Single node</strong></p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="red">Single node</strong></p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="red">Smallest node</strong></p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="green">Cluster</strong><br> \$(sum_(i=1)^"nodes""node_capacity")/"owners"\$</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="green">Cluster</strong><br> \$(sum_(i=1)^"nodes""node_capacity")/"2"\$</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Availability</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="red">Single node</strong></p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="red">Single node</strong></p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="red">Single node</strong></p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="green">All nodes</strong></p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="yellow">Owner nodes</strong></p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="yellow">Owner nodes</strong></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Features</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="red">No TX, persistence, indexing</strong></p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="green">All</strong></p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="green">All</strong></p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="green">All</strong></p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="green">All</strong></p></td> <td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="yellow">No TX</strong></p></td> </tr> </tbody> </table> </div> <div class="sect2"> <h3 id="local_mode"><a class="anchor" href="#local_mode"></a>1.2. Local Mode</h3> <div class="paragraph"> <p>While Infinispan is particularly interesting in clustered mode, it also offers a very capable local mode. In this mode, it acts as a simple, in-memory data cache similar to a <code>ConcurrentHashMap</code>.</p> </div> <div class="paragraph"> <p>But why would one use a local cache rather than a map? Caches offer a lot of features over and above a simple map, including write-through and write-behind to a persistent store, eviction of entries to prevent running out of memory, and expiration.</p> </div> <div class="paragraph"> <p>Infinispan&#8217;s <code>Cache</code> interface extends JDK&#8217;s <code>ConcurrentMap</code>&#8201;&#8212;&#8201;making migration from a map to Infinispan trivial.</p> </div> <div class="paragraph"> <p>Infinispan caches also support transactions, either integrating with an existing transaction manager or running a separate one. Local caches transactions have two choices:</p> </div> <div class="olist arabic"> <ol class="arabic"> <li> <p>When to lock? <strong>Pessimistic locking</strong> locks keys on a write operation or when the user calls <code>AdvancedCache.lock(keys)</code> explicitly. <strong>Optimistic locking</strong> only locks keys during the transaction commit, and instead it throws a <code>WriteSkewCheckException</code> at commit time, if another transaction modified the same keys after the current transaction read them.</p> </li> <li> <p>Isolation level. We support <strong>read-committed</strong> and <strong>repeatable read</strong>.</p> </li> </ol> </div> </div> </div> </div> <div class="sect1"> <h2 id="simple_cache"><a class="anchor" href="#simple_cache"></a>2. Simple Cache</h2> <div class="sectionbody"> <div class="paragraph"> <p>Traditional local caches use the same architecture as clustered caches, i.e. they use the interceptor stack. That way a lot of the implementation can be reused. However, if the advanced features are not needed and performance is more important, the interceptor stack can be stripped away and simple cache can be used.</p> </div> <div class="paragraph"> <p>So, which features are stripped away? From the configuration perspective, simple cache does not support:</p> </div> <div class="ulist"> <ul> <li> <p>transactions and invocation batching</p> </li> <li> <p>persistence (cache stores and loaders)</p> </li> <li> <p>custom interceptors (there&#8217;s no interceptor stack!)</p> </li> <li> <p>indexing</p> </li> <li> <p>transcoding</p> </li> <li> <p>store as binary (which is hardly useful for local caches)</p> </li> </ul> </div> <div class="paragraph"> <p>From the API perspective these features throw an exception:</p> </div> <div class="ulist"> <ul> <li> <p>adding custom interceptors</p> </li> <li> <p>Distributed Executors Framework</p> </li> </ul> </div> <div class="paragraph"> <p>So, what&#8217;s left?</p> </div> <div class="ulist"> <ul> <li> <p>basic map-like API</p> </li> <li> <p>cache listeners (local ones)</p> </li> <li> <p>expiration</p> </li> <li> <p>eviction</p> </li> <li> <p>security</p> </li> <li> <p>JMX access</p> </li> <li> <p>statistics (though for max performance it is recommended to switch this off using statistics-available=false)</p> </li> </ul> </div> <div class="sect2"> <h3 id="declarative_configuration"><a class="anchor" href="#declarative_configuration"></a>2.1. Declarative configuration</h3> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="xml"> <span class="tag">&lt;local-cache</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">mySimpleCache</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">simple-cache</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- expiration, eviction, security... --&gt;</span>
 <span class="tag">&lt;/local-cache&gt;</span></code></pre> </div> </div> </div> <div class="sect2"> <h3 id="programmatic_configuration"><a class="anchor" href="#programmatic_configuration"></a>2.2. Programmatic configuration</h3> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java">CacheManager cm = getCacheManager();
ConfigurationBuilder builder = <span class="keyword">new</span> ConfigurationBuilder().simpleCache(<span class="predefined-constant">true</span>);
cm.defineConfiguration(<span class="string"><span class="delimiter">&quot;</span><span class="content">mySimpleCache</span><span class="delimiter">&quot;</span></span>, builder.build());
Cache cache = cm.getCache(<span class="string"><span class="delimiter">&quot;</span><span class="content">mySimpleCache</span><span class="delimiter">&quot;</span></span>);</code></pre> </div> </div> <div class="paragraph"> <p>Simple cache checks against features it does not support, if you configure it to use e.g. transactions, configuration validation will throw an exception.</p> </div> </div> <div class="sect2"> <h3 id="invalidation_mode"><a class="anchor" href="#invalidation_mode"></a>2.3. Invalidation Mode</h3> <div class="paragraph"> <p>In invalidation, the caches on different nodes do not actually share any data. Instead, when a key is written to, the cache only aims to remove data that may be stale from other nodes. This cache mode only makes sense if you have another, permanent store for your data such as a database and are only using Infinispan as an optimization in a read-heavy system, to prevent hitting the database for every read. If a cache is configured for invalidation, every time data is changed in a cache, other caches in the cluster receive a message informing them that their data is now stale and should be removed from memory and from any local store.</p> </div> <div class="imageblock text-center"> <div class="content"> <img src="./images/clustering-invalidation.svg" alt="clustering invalidation"> </div> <div class="title">Figure 1. Invalidation mode</div> </div> <div class="paragraph"> <p>Sometimes the application reads a value from the external store and wants to write it to the local cache, without removing it from the other nodes. To do this, it must call <code>Cache.putForExternalRead(key, value)</code> instead of <code>Cache.put(key, value)</code>.</p> </div> <div class="paragraph"> <p>Invalidation mode can be used with a shared cache store. A write operation will both update the shared store, and it would remove the stale values from the other nodes' memory. The benefit of this is twofold: network traffic is minimized as invalidation messages are very small compared to replicating the entire value, and also other caches in the cluster look up modified data in a lazy manner, only when needed.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon"> <i class="fa icon-note" title="Note"></i> </td> <td class="content"> Never use invalidation mode with a <strong>local</strong> store. The invalidation message will not remove entries in the local store, and some nodes will keep seeing the stale value. </td> </tr> </table> </div> <div class="paragraph"> <p>An invalidation cache can also be configured with a special cache loader, <code>ClusterLoader</code>. When <code>ClusterLoader</code> is enabled, read operations that do not find the key on the local node will request it from all the other nodes first, and store it in memory locally. In certain situation it will store stale values, so only use it if you have a high tolerance for stale values.</p> </div> <div class="paragraph"> <p>Invalidation mode can be synchronous or asynchronous. When synchronous, a write blocks until all nodes in the cluster have evicted the stale value. When asynchronous, the originator broadcasts invalidation messages but doesn&#8217;t wait for responses. That means other nodes still see the stale value for a while after the write completed on the originator.</p> </div> <div class="paragraph"> <p>Transactions can be used to batch the invalidation messages. Transactions acquire the key lock on the primary owner. To find more about how primary owners are assigned, please read the <a href="#key_ownership">Key Ownership</a> section.</p> </div> <div class="ulist"> <ul> <li> <p>With pessimistic locking, each write triggers a lock message, which is broadcast to all the nodes. During transaction commit, the originator broadcasts a one-phase prepare message (optionally fire-and-forget) which invalidates all affected keys and releases the locks.</p> </li> <li> <p>With optimistic locking, the originator broadcasts a prepare message, a commit message, and an unlock message (optional). Either the one-phase prepare or the unlock message is fire-and-forget, and the last message always releases the locks.</p> </li> </ul> </div> </div> <div class="sect2"> <h3 id="replicated_mode"><a class="anchor" href="#replicated_mode"></a>2.4. Replicated Mode</h3> <div class="paragraph"> <p>Entries written to a replicated cache on any node will be replicated to all other nodes in the cluster, and can be retrieved locally from any node. Replicated mode provides a quick and easy way to share state across a cluster, however replication practically only performs well in small clusters (under 10 nodes), due to the number of messages needed for a write scaling linearly with the cluster size. Infinispan can be configured to use UDP multicast, which mitigates this problem to some degree.</p> </div> <div class="paragraph"> <p>Each key has a primary owner, which serializes data container updates in order to provide consistency. To find more about how primary owners are assigned, please read the <a href="#key_ownership">Key Ownership</a> section.</p> </div> <div class="imageblock text-center"> <div class="content"> <img src="./images/clustering-replicated.svg" alt="clustering replicated"> </div> <div class="title">Figure 2. Replicated mode</div> </div> <div class="paragraph"> <p>Replicated mode can be synchronous or asynchronous.</p> </div> <div class="ulist"> <ul> <li> <p>Synchronous replication blocks the caller (e.g. on a <code>cache.put(key, value)</code>) until the modifications have been replicated successfully to all the nodes in the cluster.</p> </li> <li> <p>Asynchronous replication performs replication in the background, and write operations return immediately. Asynchronous replication is not recommended, because communication errors, or errors that happen on remote nodes are not reported to the caller.</p> </li> </ul> </div> <div class="paragraph"> <p>If transactions are enabled, write operations are not replicated through the primary owner.</p> </div> <div class="ulist"> <ul> <li> <p>With pessimistic locking, each write triggers a lock message, which is broadcast to all the nodes. During transaction commit, the originator broadcasts a one-phase prepare message and an unlock message (optional). Either the one-phase prepare or the unlock message is fire-and-forget.</p> </li> <li> <p>With optimistic locking, the originator broadcasts a prepare message, a commit message, and an unlock message (optional). Again, either the one-phase prepare or the unlock message is fire-and-forget.</p> </li> </ul> </div> </div> <div class="sect2"> <h3 id="distribution_mode"><a class="anchor" href="#distribution_mode"></a>2.5. Distribution Mode</h3> <div class="paragraph"> <p>Distribution tries to keep a fixed number of copies of any entry in the cache, configured as <code>numOwners</code>. This allows the cache to scale linearly, storing more data as nodes are added to the cluster.</p> </div> <div class="paragraph"> <p>As nodes join and leave the cluster, there will be times when a key has more or less than <code>numOwners</code> copies. In particular, if <code>numOwners</code> nodes leave in quick succession, some entries will be lost, so we say that a distributed cache tolerates <code>numOwners - 1</code> node failures.</p> </div> <div class="paragraph"> <p>The number of copies represents a trade-off between performance and durability of data. The more copies you maintain, the lower performance will be, but also the lower the risk of losing data due to server or network failures. Regardless of how many copies are maintained, distribution still scales linearly, and this is key to Infinispan&#8217;s scalability.</p> </div> <div class="paragraph"> <p>The owners of a key are split into one <strong>primary owner</strong>, which coordinates writes to the key, and zero or more <strong>backup owners</strong>. To find more about how primary and backup owners are assigned, please read the <a href="#key_ownership">Key Ownership</a> section.</p> </div> <div class="imageblock text-center"> <div class="content"> <img src="./images/clustering-distributed.svg" alt="clustering distributed"> </div> <div class="title">Figure 3. Distributed mode</div> </div> <div class="paragraph"> <p>A read operation will request the value from the primary owner, but if it doesn&#8217;t respond in a reasonable amount of time, we request the value from the backup owners as well. (The <code>infinispan.stagger.delay</code> system property, in milliseconds, controls the delay between requests.) A read operation may require <code>0</code> messages if the key is present in the local cache, or up to <code>2 * numOwners</code> messages if all the owners are slow.</p> </div> <div class="paragraph"> <p>A write operation will also result in at most <code>2 * numOwners</code> messages: one message from the originator to the primary owner, <code>numOwners - 1</code> messages from the primary to the backups, and the corresponding ACK messages.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon"> <i class="fa icon-note" title="Note"></i> </td> <td class="content"> Cache topology changes may cause retries and additional messages, both for reads and for writes. </td> </tr> </table> </div> <div class="paragraph"> <p>Just as replicated mode, distributed mode can also be synchronous or asynchronous. And as in replicated mode, asynchronous replication is not recommended because it can lose updates. In addition to losing updates, asynchronous distributed caches can also see a stale value when a thread writes to a key and then immediately reads the same key.</p> </div> <div class="paragraph"> <p>Transactional distributed caches use the same kinds of messages as transactional replicated caches, except lock/prepare/commit/unlock messages are sent only to the <strong>affected nodes</strong> (all the nodes that own at least one key affected by the transaction) instead of being broadcast to all the nodes in the cluster. As an optimization, if the transaction writes to a single key and the originator is the primary owner of the key, lock messages are not replicated.</p> </div> <div class="sect3"> <h4 id="read_consistency"><a class="anchor" href="#read_consistency"></a>2.5.1. Read consistency</h4> <div class="paragraph"> <p>Even with synchronous replication, distributed caches are not linearizable. (For transactional caches, we say they do not support serialization/snapshot isolation.) We can have one thread doing a single put:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java">cache.get(k) -&gt; v1
cache.put(k, v2)
cache.get(k) -&gt; v2</code></pre> </div> </div> <div class="paragraph"> <p>But another thread might see the values in a different order:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java">cache.get(k) -&gt; v2
cache.get(k) -&gt; v1</code></pre> </div> </div> <div class="paragraph"> <p>The reason is that read can return the value from <strong>any</strong> owner, depending on how fast the primary owner replies. The write is not atomic across all the owners&#8201;&#8212;&#8201;in fact, the primary commits the update only after it receives a confirmation from the backup. While the primary is waiting for the confirmation message from the backup, reads from the backup will see the new value, but reads from the primary will see the old one.</p> </div> </div> <div class="sect3"> <h4 id="key_ownership"><a class="anchor" href="#key_ownership"></a>2.5.2. Key Ownership</h4> <div class="paragraph"> <p>Distributed caches split entries into a fixed number of segments and assign each segment to a list of owner nodes. Replicated caches do the same, with the exception that every node is an owner.</p> </div> <div class="paragraph"> <p>The first node in the list of owners is the <strong>primary owner</strong>. The other nodes in the list are <strong>backup owners</strong>. When the cache topology changes, because a node joins or leaves the cluster, the segment ownership table is broadcast to every node. This allows nodes to locate keys without making multicast requests or maintaining metadata for each key.</p> </div> <div class="paragraph"> <p>The <code>numSegments</code> property configures the number of segments available. However, the number of segments cannot change unless the cluster is restarted.</p> </div> <div class="paragraph"> <p>Likewise the key-to-segment mapping cannot change. Keys must always map to the same segments regardless of cluster topology changes. It is important that the key-to-segment mapping evenly distributes the number of segments allocated to each node while minimizing the number of segments that must move when the cluster topology changes.</p> </div> <div class="paragraph"> <p>You can customize the key-to-segment mapping by configuring a <a href="https://docs.jboss.org/infinispan/10.0/apidocs/org/infinispan/distribution/ch/KeyPartitioner.html">KeyPartitioner</a> or by using the <a href="#grouping_api">Grouping API</a>.</p> </div> <div class="paragraph"> <p>However, Infinispan provides the following implementations:</p> </div> <div class="dlist"> <dl> <dt class="hdlist1">SyncConsistentHashFactory</dt> <dd> <p>Uses an algorithm based on <a href="http://en.wikipedia.org/wiki/Consistent_hashing">consistent hashing</a>. Selected by default when server hinting is disabled.</p> <div class="paragraph"> <p>This implementation always assigns keys to the same nodes in every cache as long as the cluster is symmetric. In other words, all caches run on all nodes. This implementation does have some negative points in that the load distribution is slightly uneven. It also moves more segments than strictly necessary on a join or leave.</p> </div> </dd> <dt class="hdlist1">TopologyAwareSyncConsistentHashFactory</dt> <dd> <p>Similar to <code>SyncConsistentHashFactory</code>, but adapted for <a href="#server_hinting">Server Hinting</a>. Selected by default when server hinting is enabled.</p> </dd> <dt class="hdlist1">DefaultConsistentHashFactory</dt> <dd> <p>Achieves a more even distribution than <code>SyncConsistentHashFactory</code>, but with one disadvantage. The order in which nodes join the cluster determines which nodes own which segments. As a result, keys might be assigned to different nodes in different caches.</p> <div class="paragraph"> <p>Was the default from version 5.2 to version 8.1 with server hinting disabled.</p> </div> </dd> <dt class="hdlist1">TopologyAwareConsistentHashFactory</dt> <dd> <p>Similar to <em>DefaultConsistentHashFactory</em>, but adapted for <a href="#server_hinting">Server Hinting</a>.</p> <div class="paragraph"> <p>Was the default from version 5.2 to version 8.1 with server hinting enabled.</p> </div> </dd> <dt class="hdlist1">ReplicatedConsistentHashFactory</dt> <dd> <p>Used internally to implement replicated caches. You should never explicitly select this algorithm in a distributed cache.</p> </dd> </dl> </div> <div class="sect4"> <h5 id="capacity_factors"><a class="anchor" href="#capacity_factors"></a>Capacity Factors</h5> <div class="paragraph"> <p>Capacity factors are another way to customize the mapping of segments to nodes. The nodes in a cluster are not always identical. If a node has 2x the memory of a "regular" node, configuring it with a <code>capacityFactor</code> of <code>2</code> tells Infinispan to allocate 2x segments to that node. The capacity factor can be any non-negative number, and the hashing algorithm will try to assign to each node a load weighted by its capacity factor (both as a primary owner and as a backup owner).</p> </div> <div class="paragraph"> <p>One interesting use case is nodes with a capacity factor of <code>0</code>. This could be useful when some nodes are too short-lived to be useful as data owners, but they can&#8217;t use HotRod (or other remote protocols) because they need transactions. With cross-site replication as well, the "site master" should only deal with forwarding commands between sites and shouldn&#8217;t handle user requests, so it makes sense to configure it with a capacity factor of <code>0</code>.</p> </div> </div> <div class="sect4"> <h5 id="zero_capacity_node"><a class="anchor" href="#zero_capacity_node"></a>Zero Capacity Node</h5> <div class="paragraph"> <p>You might need to configure a whole node where the capacity factor is <code>0</code> for every cache, user defined caches and internal caches. When defining a zero capacity node, the node won&#8217;t hold any data. This is how you declare a zero capacity node:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="xml">   <span class="tag">&lt;cache-container</span> <span class="attribute-name">zero-capacity-node</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span></code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">new</span> GlobalConfigurationBuilder().zeroCapacityNode(<span class="predefined-constant">true</span>);</code></pre> </div> </div> <div class="paragraph"> <p>However, note that this will be true for distributed caches only. If you are using replicated caches, the node will still keep a copy of the value. Use only distributed caches to make the best use of this feature.</p> </div> </div> <div class="sect4"> <h5 id="hashing_configuration"><a class="anchor" href="#hashing_configuration"></a>Hashing Configuration</h5> <div class="paragraph"> <p>This is how you configure hashing declaratively, via XML:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="xml">   <span class="tag">&lt;distributed-cache</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">distributedCache</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">owners</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">segments</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">100</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">capacity-factor</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span></code></pre> </div> </div> <div class="paragraph"> <p>And this is how you can configure it programmatically, in Java:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Configuration</span> c = <span class="keyword">new</span> ConfigurationBuilder()
   .clustering()
      .cacheMode(CacheMode.DIST_SYNC)
      .hash()
         .numOwners(<span class="integer">2</span>)
         .numSegments(<span class="integer">100</span>)
         .capacityFactor(<span class="integer">2</span>)
   .build();</code></pre> </div> </div> </div> </div> <div class="sect3"> <h4 id="initial_cluster_size"><a class="anchor" href="#initial_cluster_size"></a>2.5.3. Initial cluster size</h4> <div class="paragraph"> <p>Infinispan&#8217;s very dynamic nature in handling topology changes (i.e. nodes being added / removed at runtime) means that, normally, a node doesn&#8217;t wait for the presence of other nodes before starting. While this is very flexible, it might not be suitable for applications which require a specific number of nodes to join the cluster before caches are started. For this reason, you can specify how many nodes should have joined the cluster before proceeding with cache initialization. To do this, use the <code>initialClusterSize</code> and <code>initialClusterTimeout</code> transport properties. The declarative XML configuration:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="xml">   <span class="tag">&lt;transport</span> <span class="attribute-name">initial-cluster-size</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">4</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">initial-cluster-timeout</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">30000</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span></code></pre> </div> </div> <div class="paragraph"> <p>The programmatic Java configuration:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java">GlobalConfiguration global = <span class="keyword">new</span> GlobalConfigurationBuilder()
   .transport()
       .initialClusterSize(<span class="integer">4</span>)
       .initialClusterTimeout(<span class="integer">30000</span>)
   .build();</code></pre> </div> </div> <div class="paragraph"> <p>The above configuration will wait for <em>4</em> nodes to join the cluster before initialization. If the initial nodes do not appear within the specified timeout, the cache manager will fail to start.</p> </div> </div> <div class="sect3"> <h4 id="l1_caching"><a class="anchor" href="#l1_caching"></a>2.5.4. L1 Caching</h4> <div class="paragraph"> <p>When L1 is enabled, a node will keep the result of remote reads locally for a short period of time (configurable, 10 minutes by default), and repeated lookups will return the local L1 value instead of asking the owners again.</p> </div> <div class="imageblock text-center"> <div class="content"> <img src="./images/clustering-l1.svg" alt="clustering l1"> </div> <div class="title">Figure 4. L1 caching</div> </div> <div class="paragraph"> <p>L1 caching is not free though. Enabling it comes at a cost, and this cost is that every entry update must broadcast an invalidation message to all the nodes. L1 entries can be evicted just like any other entry when the the cache is configured with a maximum size. Enabling L1 will improve performance for repeated reads of non-local keys, but it will slow down writes and it will increase memory consumption to some degree.</p> </div> <div class="paragraph"> <p>Is L1 caching right for you? The correct approach is to benchmark your application with and without L1 enabled and see what works best for your access pattern.</p> </div> </div> <div class="sect3"> <h4 id="server_hinting"><a class="anchor" href="#server_hinting"></a>2.5.5. Server Hinting</h4> <div class="paragraph"> <p>The following topology hints can be specified:</p> </div> <div class="dlist"> <dl> <dt class="hdlist1">Machine</dt> <dd> <p>This is probably the most useful, when multiple JVM instances run on the same node, or even when multiple virtual machines run on the same physical machine.</p> </dd> <dt class="hdlist1">Rack</dt> <dd> <p>In larger clusters, nodes located on the same rack are more likely to experience a hardware or network failure at the same time.</p> </dd> <dt class="hdlist1">Site</dt> <dd> <p>Some clusters may have nodes in multiple physical locations for extra resilience. Note that Cross site replication is another alternative for clusters that need to span two or more data centres.</p> </dd> </dl> </div> <div class="paragraph"> <p>All of the above are optional. When provided, the distribution algorithm will try to spread the ownership of each segment across as many sites, racks, and machines (in this order) as possible.</p> </div> <div class="sect4"> <h5 id="configuration"><a class="anchor" href="#configuration"></a>Configuration</h5> <div class="paragraph"> <p>The hints are configured at transport level:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;transport</span>
    <span class="attribute-name">cluster</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">MyCluster</span><span class="delimiter">&quot;</span></span>
    <span class="attribute-name">machine</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">LinuxServer01</span><span class="delimiter">&quot;</span></span>
    <span class="attribute-name">rack</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Rack01</span><span class="delimiter">&quot;</span></span>
    <span class="attribute-name">site</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">US-WestCoast</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span></code></pre> </div> </div> </div> </div> <div class="sect3"> <h4 id="key_affinity_service"><a class="anchor" href="#key_affinity_service"></a>2.5.6. Key affinity service</h4> <div class="paragraph"> <p>In a distributed cache, a key is allocated to a list of nodes with an opaque algorithm. There is no easy way to reverse the computation and generate a key that maps to a particular node. However, we can generate a sequence of (pseudo-)random keys, see what their primary owner is, and hand them out to the application when it needs a key mapping to a particular node.</p> </div> <div class="sect4"> <h5 id="api"><a class="anchor" href="#api"></a>API</h5> <div class="paragraph"> <p>Following code snippet depicts how a reference to this service can be obtained and used.</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// 1. Obtain a reference to a cache</span>
Cache cache = ...
Address address = cache.getCacheManager().getAddress();

<span class="comment">// 2. Create the affinity service</span>
KeyAffinityService keyAffinityService = KeyAffinityServiceFactory.newLocalKeyAffinityService(
      cache,
      <span class="keyword">new</span> RndKeyGenerator(),
      <span class="predefined-type">Executors</span>.newSingleThreadExecutor(),
      <span class="integer">100</span>);

<span class="comment">// 3. Obtain a key for which the local node is the primary owner</span>
<span class="predefined-type">Object</span> localKey = keyAffinityService.getKeyForAddress(address);

<span class="comment">// 4. Insert the key in the cache</span>
cache.put(localKey, <span class="string"><span class="delimiter">&quot;</span><span class="content">yourValue</span><span class="delimiter">&quot;</span></span>);</code></pre> </div> </div> <div class="paragraph"> <p>The service is started at step 2: after this point it uses the supplied <em>Executor</em> to generate and queue keys. At step 3, we obtain a key from the service, and at step 4 we use it.</p> </div> </div> <div class="sect4"> <h5 id="lifecycle"><a class="anchor" href="#lifecycle"></a>Lifecycle</h5> <div class="paragraph"> <p><code>KeyAffinityService</code> extends <code>Lifecycle</code>, which allows stopping and (re)starting it:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Lifecycle</span> {
<span class="error"></span><span class="error"></span> <span class="type">void</span> start();
<span class="error"></span><span class="error"></span> <span class="type">void</span> stop();
}</code></pre> </div> </div> <div class="paragraph"> <p>The service is instantiated through <code>KeyAffinityServiceFactory</code>. All the factory methods have an <code>Executor</code> parameter, that is used for asynchronous key generation (so that it won&#8217;t happen in the caller&#8217;s thread). It is the user&#8217;s responsibility to handle the shutdown of this <code>Executor</code>.</p> </div> <div class="paragraph"> <p>The <code>KeyAffinityService</code>, once started, needs to be explicitly stopped. This stops the background key generation and releases other held resources.</p> </div> <div class="paragraph"> <p>The only situation in which <code>KeyAffinityService</code> stops by itself is when the cache manager with which it was registered is shutdown.</p> </div> </div> <div class="sect4"> <h5 id="topology_changes"><a class="anchor" href="#topology_changes"></a>Topology changes</h5> <div class="paragraph"> <p>When the cache topology changes (i.e. nodes join or leave the cluster), the ownership of the keys generated by the <code>KeyAffinityService</code> might change. The key affinity service keep tracks of these topology changes and doesn&#8217;t return keys that would currently map to a different node, but it won&#8217;t do anything about keys generated earlier.</p> </div> <div class="paragraph"> <p>As such, applications should treat <code>KeyAffinityService</code> purely as an optimization, and they should not rely on the location of a generated key for correctness.</p> </div> <div class="paragraph"> <p>In particular, applications should not rely on keys generated by <code>KeyAffinityService</code> for the same address to always be located together. Collocation of keys is only provided by the <a href="#grouping_api">Grouping API</a>.</p> </div> </div> <div class="sect4"> <h5 id="grouping_api"><a class="anchor" href="#grouping_api"></a>The Grouping API</h5> <div class="paragraph"> <p>Complementary to <a href="#key_affinity_service">Key affinity service</a>, the grouping API allows you to co-locate a group of entries on the same nodes, but without being able to select the actual nodes.</p> </div> </div> <div class="sect4"> <h5 id="how_does_it_work"><a class="anchor" href="#how_does_it_work"></a>How does it work?</h5> <div class="paragraph"> <p>By default, the segment of a key is computed using the key&#8217;s <code>hashCode()</code>. If you use the grouping API, Infinispan will compute the segment of the group and use that as the segment of the key. See the <a href="#key_ownership">Key Ownership</a> section for more details on how segments are then mapped to nodes.</p> </div> <div class="paragraph"> <p>When the group API is in use, it is important that every node can still compute the owners of every key without contacting other nodes. For this reason, the group cannot be specified manually. The group can either be intrinsic to the entry (generated by the key class) or extrinsic (generated by an external function).</p> </div> </div> <div class="sect4"> <h5 id="how_do_i_use_the_grouping_api"><a class="anchor" href="#how_do_i_use_the_grouping_api"></a>How do I use the grouping API?</h5> <div class="paragraph"> <p>First, you must enable groups. If you are configuring Infinispan programmatically, then call:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Configuration</span> c = <span class="keyword">new</span> ConfigurationBuilder()
   .clustering().hash().groups().enabled()
   .build();</code></pre> </div> </div> <div class="paragraph"> <p>Or, if you are using XML:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;distributed-cache&gt;</span>
 <span class="tag">&lt;groups</span> <span class="attribute-name">enabled</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/distributed-cache&gt;</span></code></pre> </div> </div> <div class="paragraph"> <p>If you have control of the key class (you can alter the class definition, it&#8217;s not part of an unmodifiable library), then we recommend using an intrinsic group. The intrinsic group is specified by adding the <code>@Group</code> annotation to a method. Let&#8217;s take a look at an example:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">User</span> {
   ...
   String office;
   ...

   public <span class="type">int</span> hashCode() {
      <span class="comment">// Defines the hash for the key, normally used to determine location</span>
      ...
   }

   <span class="comment">// Override the location by specifying a group</span>
   <span class="comment">// All keys in the same group end up with the same owners</span>
   <span class="annotation">@Group</span>
   <span class="directive">public</span> <span class="predefined-type">String</span> getOffice() {
      <span class="keyword">return</span> office;
   }
   }
}</code></pre> </div> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon"> <i class="fa icon-note" title="Note"></i> </td> <td class="content"> The group method must return a <code>String</code> </td> </tr> </table> </div> <div class="paragraph"> <p>If you don&#8217;t have control over the key class, or the determination of the group is an orthogonal concern to the key class, we recommend using an extrinsic group. An extrinsic group is specified by implementing the <code>Grouper</code> interface.</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Grouper</span>&lt;T&gt; {
    <span class="predefined-type">String</span> computeGroup(T key, <span class="predefined-type">String</span> group);

    <span class="predefined-type">Class</span>&lt;T&gt; getKeyType();
}</code></pre> </div> </div> <div class="paragraph"> <p>If multiple <code>Grouper</code> classes are configured for the same key type, all of them will be called, receiving the value computed by the previous one. If the key class also has a <code>@Group</code> annotation, the first <code>Grouper</code> will receive the group computed by the annotated method. This allows you even greater control over the group when using an intrinsic group. Let&#8217;s take a look at an example <code>Grouper</code> implementation:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">KXGrouper</span> <span class="directive">implements</span> Grouper&lt;<span class="predefined-type">String</span>&gt; {

   <span class="comment">// The pattern requires a String key, of length 2, where the first character is</span>
   <span class="comment">// &quot;k&quot; and the second character is a digit. We take that digit, and perform</span>
   <span class="comment">// modular arithmetic on it to assign it to group &quot;0&quot; or group &quot;1&quot;.</span>
   <span class="directive">private</span> <span class="directive">static</span> <span class="predefined-type">Pattern</span> kPattern = <span class="predefined-type">Pattern</span>.compile(<span class="string"><span class="delimiter">&quot;</span><span class="content">(^k)(&lt;a&gt;</span><span class="char">\\</span><span class="content">d&lt;/a&gt;)$</span><span class="delimiter">&quot;</span></span>);

   <span class="directive">public</span> <span class="predefined-type">String</span> computeGroup(<span class="predefined-type">String</span> key, <span class="predefined-type">String</span> group) {
      <span class="predefined-type">Matcher</span> matcher = kPattern.matcher(key);
      <span class="keyword">if</span> (matcher.matches()) {
         <span class="predefined-type">String</span> g = <span class="predefined-type">Integer</span>.parseInt(matcher.group(<span class="integer">2</span>)) % <span class="integer">2</span> + <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>;
         <span class="keyword">return</span> g;
      } <span class="keyword">else</span> {
         <span class="keyword">return</span> <span class="predefined-constant">null</span>;
      }
   }

   <span class="directive">public</span> <span class="predefined-type">Class</span>&lt;<span class="predefined-type">String</span>&gt; getKeyType() {
      <span class="keyword">return</span> <span class="predefined-type">String</span>.class;
   }
}</code></pre> </div> </div> <div class="paragraph"> <p><code>Grouper</code> implementations must be registered explicitly in the cache configuration. If you are configuring Infinispan programmatically:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Configuration</span> c = <span class="keyword">new</span> ConfigurationBuilder()
   .clustering().hash().groups().enabled().addGrouper(<span class="keyword">new</span> KXGrouper())
   .build();</code></pre> </div> </div> <div class="paragraph"> <p>Or, if you are using XML:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;distributed-cache&gt;</span>
   <span class="tag">&lt;groups</span> <span class="attribute-name">enabled</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
      <span class="tag">&lt;grouper</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.KXGrouper</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
   <span class="tag">&lt;/groups&gt;</span>
<span class="tag">&lt;/distributed-cache&gt;</span></code></pre> </div> </div> </div> <div class="sect4"> <h5 id="advanced_interface"><a class="anchor" href="#advanced_interface"></a>Advanced Interface</h5> <div class="paragraph"> <p><code>AdvancedCache</code> has two group-specific methods:</p> </div> <div class="dlist"> <dl> <dt class="hdlist1"><a href="https://docs.jboss.org/infinispan/10.0/apidocs/org/infinispan/AdvancedCache.html#getGroup-java.lang.String-">getGroup(groupName)</a></dt> <dd> <p>Retrieves all keys in the cache that belong to a group.</p> </dd> <dt class="hdlist1"><a href="https://docs.jboss.org/infinispan/10.0/apidocs/org/infinispan/AdvancedCache.html#removeGroup-java.lang.String-">removeGroup(groupName)</a></dt> <dd> <p>Removes all the keys in the cache that belong to a group.</p> </dd> </dl> </div> <div class="paragraph"> <p>Both methods iterate over the entire data container and store (if present), so they can be slow when a cache contains lots of small groups.</p> </div> </div> </div> </div> <div class="sect2"> <h3 id="scattered_mode"><a class="anchor" href="#scattered_mode"></a>2.6. Scattered Mode</h3> <div class="paragraph"> <p>Scattered mode is very similar to Distribution Mode as it allows linear scaling of the cluster. It allows single node failure by maintaining two copies of the data (as Distribution Mode with numOwners=2). Unlike Distributed, the location of data is not fixed; while we use the same Consistent Hash algorithm to locate the primary owner, the backup copy is stored on the node that wrote the data last time. When the write originates on the primary owner, backup copy is stored on any other node (the exact location of this copy is not important).</p> </div> <div class="paragraph"> <p>This has the advantage of single RPC for any write (Distribution Mode requires one or two RPCs), but reads have to always target the primary owner. That results in faster writes but possibly slower reads, and therefore this mode is more suitable for write-intensive applications.</p> </div> <div class="paragraph"> <p>Storing multiple backup copies also results in slightly higher memory consumption. In order to remove out-of-date backup copies, invalidation messages are broadcast in the cluster, which generates some overhead. This makes scattered mode less performant in very big clusters (this behaviour might be optimized in the future).</p> </div> <div class="paragraph"> <p>When a node crashes, the primary copy may be lost. Therefore, the cluster has to reconcile the backups and find out the last written backup copy. This process results in more network traffic during state transfer.</p> </div> <div class="paragraph"> <p>Since the writer of data is also a backup, even if we specify machine/rack/site ids on the transport level the cluster cannot be resilient to more than one failure on the same machine/rack/site.</p> </div> <div class="paragraph"> <p>Currently it is not possible to use scattered mode in transactional cache. Asynchronous replication is not supported either; use asynchronous Cache API instead. Functional commands are not implemented neither but these are expected to be added soon.</p> </div> <div class="paragraph"> <p>The cache is configured in a similar way as the other cache modes, here is an example of declarative configuration:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="xml">   <span class="tag">&lt;scattered-cache</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">scatteredCache</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span></code></pre> </div> </div> <div class="paragraph"> <p>And this is how you can configure it programmatically:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Configuration</span> c = <span class="keyword">new</span> ConfigurationBuilder()
   .clustering().cacheMode(CacheMode.SCATTERED_SYNC)
   .build();</code></pre> </div> </div> <div class="paragraph"> <p>Scattered mode is not exposed in the server configuration as the server is usually accessed through the Hot Rod protocol. The protocol automatically selects primary owner for the writes and therefore the write (in distributed mode with two owner) requires single RPC inside the cluster, too. Therefore, scattered cache would not bring the performance benefit.</p> </div> </div> <div class="sect2"> <h3 id="asynchronous_options"><a class="anchor" href="#asynchronous_options"></a>2.7. Asynchronous Options</h3> <div class="sect3"> <h4 id="asynchronous_communications"><a class="anchor" href="#asynchronous_communications"></a>2.7.1. Asynchronous Communications</h4> <div class="paragraph"> <p>All clustered cache modes can be configured to use asynchronous communications with the <a href="https://docs.jboss.org/infinispan/10.0/configdocs/"><code>mode="ASYNC"</code></a> attribute on the <code>&lt;replicated-cache/&gt;</code>, <code>&lt;distributed-cache&gt;</code>, or <code>&lt;invalidation-cache/&gt;</code> element.</p> </div> <div class="paragraph"> <p>With asynchronous communications, the originator node does not receive any acknowledgement from the other nodes about the status of the operation, so there is no way to check if it succeeded on other nodes.</p> </div> <div class="paragraph"> <p>We do not recommend asynchronous communications in general, as they can cause inconsistencies in the data, and the results are hard to reason about. Nevertheless, sometimes speed is more important than consistency, and the option is available for those cases.</p> </div> </div> <div class="sect3"> <h4 id="asynchronous_api"><a class="anchor" href="#asynchronous_api"></a>2.7.2. Asynchronous API</h4> <div class="paragraph"> <p>The Asynchronous API allows you to use synchronous communications, but without blocking the user thread.</p> </div> <div class="paragraph"> <p>There is one caveat: The asynchronous operations do NOT preserve the program order. If a thread calls <code>cache.putAsync(k, v1); cache.putAsync(k, v2)</code>, the final value of <code>k</code> may be either <code>v1</code> or <code>v2</code>. The advantage over using asynchronous communications is that the final value can&#8217;t be <code>v1</code> on one node and <code>v2</code> on another.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon"> <i class="fa icon-note" title="Note"></i> </td> <td class="content"> Prior to version 9.0, the asynchronous API was emulated by borrowing a thread from an internal thread pool and running a blocking operation on that thread. </td> </tr> </table> </div> </div> <div class="sect3"> <h4 id="return_values"><a class="anchor" href="#return_values"></a>2.7.3. Return Values</h4> <div class="paragraph"> <p>Because the <code>Cache</code> interface extends <code>java.util.Map</code>, write methods like <code>put(key, value)</code> and <code>remove(key)</code> return the previous value by default.</p> </div> <div class="paragraph"> <p>In some cases, the return value may not be correct:</p> </div> <div class="olist arabic"> <ol class="arabic"> <li> <p>When using <code>AdvancedCache.withFlags()</code> with <code>Flag.IGNORE_RETURN_VALUE</code>, <code>Flag.SKIP_REMOTE_LOOKUP</code>, or <code>Flag.SKIP_CACHE_LOAD</code>.</p> </li> <li> <p>When the cache is configured with <code>unreliable-return-values="true"</code>.</p> </li> <li> <p>When using asynchronous communications.</p> </li> <li> <p>When there are multiple concurrent writes to the same key, and the cache topology changes. The topology change will make Infinispan retry the write operations, and a retried operation&#8217;s return value is not reliable.</p> </li> </ol> </div> <div class="paragraph"> <p>Transactional caches return the correct previous value in cases 3 and 4. However, transactional caches also have a gotcha: in distributed mode, the read-committed isolation level is implemented as repeatable-read. That means this example of "double-checked locking" won&#8217;t work:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java">Cache cache = ...
TransactionManager tm = ...

tm.begin();
<span class="keyword">try</span> {
   <span class="predefined-type">Integer</span> v1 = cache.get(k);
   <span class="comment">// Increment the value</span>
   <span class="predefined-type">Integer</span> v2 = cache.put(k, v1 + <span class="integer">1</span>);
   <span class="keyword">if</span> (Objects.equals(v1, v2) {
      <span class="comment">// success</span>
   } <span class="keyword">else</span> {
      <span class="comment">// retry</span>
   }
} <span class="keyword">finally</span> {
  tm.commit();
}</code></pre> </div> </div> <div class="paragraph"> <p>The correct way to implement this is to use <code>cache.getAdvancedCache().withFlags(Flag.FORCE_WRITE_LOCK).get(k)</code>.</p> </div> <div class="paragraph"> <p>In caches with optimistic locking, writes can also return stale previous values. Write skew checks can avoid stale previous values.</p> </div> </div> </div> <div class="sect2"> <h3 id="partition_handling"><a class="anchor" href="#partition_handling"></a>2.8. Partition handling</h3> <div class="paragraph"> <p>An Infinispan cluster is built out of a number of nodes where data is stored. In order not to lose data in the presence of node failures, Infinispan copies the same data&#8201;&#8212;&#8201;cache entry in Infinispan parlance&#8201;&#8212;&#8201;over multiple nodes. This level of data redundancy is configured through the <code>numOwners</code> configuration attribute and ensures that as long as fewer than <code>numOwners</code> nodes crash simultaneously, Infinispan has a copy of the data available.</p> </div> <div class="paragraph"> <p>However, there might be catastrophic situations in which more than <code>numOwners</code> nodes disappear from the cluster:</p> </div> <div class="dlist"> <dl> <dt class="hdlist1">Split brain</dt> <dd> <p>Caused e.g. by a router crash, this splits the cluster in two or more partitions, or sub-clusters that operate independently. In these circumstances, multiple clients reading/writing from different partitions see different versions of the same cache entry, which for many application is problematic. Note there are ways to alleviate the possibility for the split brain to happen, such as redundant networks or <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Deployment_Guide/s2-networkscripts-interfaces-chan.html">IP bonding</a>. These only reduce the window of time for the problem to occur, though.</p> </dd> <dt class="hdlist1"><code>numOwners</code> nodes crash in sequence</dt> <dd> <p>When at least <code>numOwners</code> nodes crash in rapid succession and Infinispan does not have the time to properly rebalance its state between crashes, the result is partial data loss.</p> </dd> </dl> </div> <div class="paragraph"> <p>The partition handling functionality discussed in this section allows the user to configure what operations can be performed on a cache in the event of a split brain occurring. Infinispan provides multiple partition handling strategies, which in terms of Brewer&#8217;s <a href="http://en.wikipedia.org/wiki/CAP_theorem">CAP theorem</a> determine whether availability or consistency is sacrificed in the presence of partition(s). Below is a list of the provided strategies:</p> </div> <table class="tableblock frame-all grid-all stretch"> <colgroup> <col style="width: 33.3333%;"> <col style="width: 33.3333%;"> <col style="width: 33.3334%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">Strategy</th> <th class="tableblock halign-left valign-top">Description</th> <th class="tableblock halign-left valign-top">CAP</th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">DENY_READ_WRITES</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">If the partition does not have all owners for a given segment, both reads and writes are denied for all keys in that segment.</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Consistency</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">ALLOW_READS</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Allows reads for a given key if it exists in this partition, but only allows writes if this partition contains all owners of a segment. This is still a consistent approach because some entries are readable if available in this partition, but from a client application perspective it is not deterministic.</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Consistency</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">ALLOW_READ_WRITES</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Allow entries on each partition to diverge, with conflict resolution attempted upon the partitions merging.</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Availability</p></td> </tr> </tbody> </table> <div class="paragraph"> <p>The requirements of your application should determine which strategy is appropriate. For example, DENY_READ_WRITES is more appropriate for applications that have high consistency requirements; i.e. when the data read from the system must be accurate. Whereas if Infinispan is used as a best-effort cache, partitions maybe perfectly tolerable and the ALLOW_READ_WRITES might be more appropriate as it favours availability over consistency.</p> </div> <div class="paragraph"> <p>The following sections describe how Infinispan handles <a href="#split_brain">split brain</a> and <a href="#successive_node_failures">successive failures</a> for each of the partition handling strategies. This is followed by a section describing how Infinispan allows for automatic conflict resolution upon partition merges via <a href="#merge_policies">merge policies</a>. Finally, we provide a section describing <a href="#partition_handling_configuration">how to configure partition handling strategies and merge policies</a>.</p> </div> <div class="sect3"> <h4 id="split_brain"><a class="anchor" href="#split_brain"></a>2.8.1. Split brain</h4> <div class="paragraph"> <p>In a split brain situation, each network partition will install its own JGroups view, removing the nodes from the other partition(s). We don&#8217;t have a direct way of determining whether the has been split into two or more partitions, since the partitions are unaware of each other. Instead, we assume the cluster has split when one or more nodes disappear from the JGroups cluster without sending an explicit leave message.</p> </div> <div class="sect4"> <h5 id="split_strategies"><a class="anchor" href="#split_strategies"></a>Split Strategies</h5> <div class="paragraph"> <p>In this section, we detail how each partition handling strategy behaves in the event of split brain occurring.</p> </div> <div class="sect5"> <h6 id="allow_read_writes"><a class="anchor" href="#allow_read_writes"></a>ALLOW_READ_WRITES</h6> <div class="paragraph"> <p>Each partition continues to function as an independent cluster, with all partitions remaining in AVAILABLE mode. This means that each partition may only see a part of the data, and each partition could write conflicting updates in the cache. During a partition merge these conflicts are automatically resolved by utilising the <a href="#conflict_manager">ConflictManager</a> and the configured <a href="#merge_policies">EntryMergePolicy</a>.</p> </div> </div> <div class="sect5"> <h6 id="deny_read_writes"><a class="anchor" href="#deny_read_writes"></a>DENY_READ_WRITES</h6> <div class="paragraph"> <p>When a split is detected each partition does not start a rebalance immediately, but first it checks whether it should enter <strong>DEGRADED</strong> mode instead:</p> </div> <div class="ulist"> <ul> <li> <p>If at least one segment has lost all its owners (meaning at least <em>numOwners</em> nodes left since the last rebalance ended), the partition enters DEGRADED mode.</p> </li> <li> <p>If the partition does not contain a simple majority of the nodes (floor(numNodes/2) + 1) in the <em>latest stable topology</em>, the partition also enters DEGRADED mode.</p> </li> <li> <p>Otherwise the partition keeps functioning normally, and it starts a rebalance.</p> </li> </ul> </div> <div class="paragraph"> <p>The <em>stable topology</em> is updated every time a rebalance operation ends and the coordinator determines that another rebalance is not necessary.</p> </div> <div class="paragraph"> <p>These rules ensures that at most one partition stays in AVAILABLE mode, and the other partitions enter DEGRADED mode.</p> </div> <div class="paragraph"> <p>When a partition is in DEGRADED mode, it only allows access to the keys that are wholly owned:</p> </div> <div class="ulist"> <ul> <li> <p>Requests (reads and writes) for entries that have all the copies on nodes within this partition are honoured.</p> </li> <li> <p>Requests for entries that are partially or totally owned by nodes that disappeared are rejected with an <code>AvailabilityException</code>.</p> </li> </ul> </div> <div class="paragraph"> <p>This guarantees that partitions cannot write different values for the same key (cache is consistent), and also that one partition can not read keys that have been updated in the other partitions (no stale data).</p> </div> <div class="paragraph"> <p>To exemplify, consider the initial cluster <code>M = {A, B, C, D}</code>, configured in distributed mode with <code>numOwners = 2</code>. Further on, consider three keys <code>k1</code>, <code>k2</code> and <code>k3</code> (that might exist in the cache or not) such that <code>owners(k1) = {A,B}</code>, <code>owners(k2) = {B,C}</code> and <code>owners(k3) = {C,D}</code>. Then the network splits in two partitions, <code>N1 = {A, B}</code> and <code>N2 = {C, D}</code>, they enter DEGRADED mode and behave like this:</p> </div> <div class="ulist"> <ul> <li> <p>on <code>N1</code>, <code>k1</code> is available for read/write, <code>k2</code> (partially owned) and <code>k3</code> (not owned) are not available and accessing them results in an <code>AvailabilityException</code></p> </li> <li> <p>on <code>N2</code>, <code>k1</code> and <code>k2</code> are not available for read/write, <code>k3</code> is available</p> </li> </ul> </div> <div class="paragraph"> <p>A relevant aspect of the partition handling process is the fact that when a split brain happens, the resulting partitions rely on the original segment mapping (the one that existed before the split brain) in order to calculate key ownership. So it doesn&#8217;t matter if <code>k1</code>, <code>k2</code>, or <code>k3</code> already existed cache or not, their availability is the same.</p> </div> <div class="paragraph"> <p>If at a further point in time the network heals and <code>N1</code> and <code>N2</code> partitions merge back together into the initial cluster <code>M</code>, then <code>M</code> exits the degraded mode and becomes fully available again. During this merge operation, because <code>M</code> has once again become fully available, the <a href="#conflict_manager">ConflictManager</a> and the configured <a href="#merge_policies">EntryMergePolicy</a> are used to check for any conflicts that may have occurred in the interim period between the split brain occurring and being detected.</p> </div> <div class="paragraph"> <p>As another example, the cluster could split in two partitions <code>O1 = {A, B, C}</code> and <code>O2 = {D}</code>, partition <code>O1</code> will stay fully available (rebalancing cache entries on the remaining members). Partition <code>O2</code>, however, will detect a split and enter the degraded mode. Since it doesn&#8217;t have any fully owned keys, it will reject any read or write operation with an <code>AvailabilityException</code>.</p> </div> <div class="paragraph"> <p>If afterwards partitions <code>O1</code> and <code>O2</code> merge back into <code>M</code>, then the <a href="#conflict_manager">ConflictManager</a> attempts to resolve any conflicts and <code>D</code> once again becomes fully available.</p> </div> </div> <div class="sect5"> <h6 id="allow_reads"><a class="anchor" href="#allow_reads"></a>ALLOW_READS</h6> <div class="paragraph"> <p>Partitions are handled in the same manner as DENY_READ_WRITES, except that when a partition is in DEGRADED mode read operations on a partially owned key WILL not throw an AvailabilityException.</p> </div> </div> </div> <div class="sect4"> <h5 id="current_limitations"><a class="anchor" href="#current_limitations"></a>Current limitations</h5> <div class="paragraph"> <p>Two partitions could start up isolated, and as long as they don&#8217;t merge they can read and write inconsistent data. In the future, we will allow custom availability strategies (e.g. check that a certain node is part of the cluster, or check that an external machine is accessible) that could handle that situation as well.</p> </div> </div> </div> <div class="sect3"> <h4 id="successive_node_failures"><a class="anchor" href="#successive_node_failures"></a>2.8.2. Successive nodes stopped</h4> <div class="paragraph"> <p>As mentioned in the previous section, Infinispan can&#8217;t detect whether a node left the JGroups view because of a process/machine crash, or because of a network failure: whenever a node leaves the JGroups cluster abruptly, it is assumed to be because of a network problem.</p> </div> <div class="paragraph"> <p>If the configured number of copies (<code>numOwners</code>) is greater than 1, the cluster can remain available and will try to make new replicas of the data on the crashed node. However, other nodes might crash during the rebalance process. If more than <code>numOwners</code> nodes crash in a short interval of time, there is a chance that some cache entries have disappeared from the cluster altogether. In this case, with the DENY_READ_WRITES or ALLOW_READS strategy enabled, Infinispan assumes (incorrectly) that there is a split brain and enters DEGRADED mode as described in the split-brain section.</p> </div> <div class="paragraph"> <p>The administrator can also shut down more than <code>numOwners</code> nodes in rapid succession, causing the loss of the data stored only on those nodes. When the administrator shuts down a node gracefully, Infinispan knows that the node can&#8217;t come back. However, the cluster doesn&#8217;t keep track of how each node left, and the cache still enters DEGRADED mode as if those nodes had crashed.</p> </div> <div class="paragraph"> <p>At this stage there is no way for the cluster to recover its state, except stopping it and repopulating it on restart with the data from an external source. Clusters are expected to be configured with an appropriate <code>numOwners</code> in order to avoid <code>numOwners</code> successive node failures, so this situation should be pretty rare. If the application can handle losing some of the data in the cache, the administrator can force the availability mode back to AVAILABLE via JMX.</p> </div> </div> <div class="sect3"> <h4 id="conflict_manager"><a class="anchor" href="#conflict_manager"></a>2.8.3. Conflict Manager</h4> <div class="paragraph"> <p>The conflict manager is a tool that allows users to retrieve all stored replica values for a given key. In addition to allowing users to process a stream of cache entries whose stored replicas have conflicting values. Furthermore, by utilising implementations of the <a href="#merge_policies">EntryMergePolicy</a> interface it is possible for said conflicts to be resolved automatically.</p> </div> <div class="sect4"> <h5 id="detecting_conflicts"><a class="anchor" href="#detecting_conflicts"></a>Detecting Conflicts</h5> <div class="paragraph"> <p>Conflicts are detected by retrieving each of the stored values for a given key. The conflict manager retrieves the value stored from each of the key&#8217;s write owners defined by the current consistent hash. The .equals method of the stored values is then used to determine whether all values are equal. If all values are equal then no conflicts exist for the key, otherwise a conflict has occurred. Note that null values are returned if no entry exists on a given node, therefore we deem a conflict to have occurred if both a null and non-null value exists for a given key.</p> </div> </div> <div class="sect4"> <h5 id="merge_policies"><a class="anchor" href="#merge_policies"></a>Merge Policies</h5> <div class="paragraph"> <p>In the event of conflicts arising between one or more replicas of a given CacheEntry, it is necessary for a conflict resolution algorithm to be defined, therefore we provide the <a href="https://docs.jboss.org/infinispan/10.0/apidocs/org/infinispan/conflict/EntryMergePolicy.html">EntryMergePolicy</a> interface. This interface consists of a single method, "merge", whose returned CacheEntry is utilised as the "resolved" entry for a given key. When a non-null CacheEntry is returned, this entries value is "put" to all replicas in the cache. However when the merge implementation returns a null value, all replicas associated with the conflicting key are removed from the cache.</p> </div> <div class="paragraph"> <p>The merge method takes two parameters: the "preferredEntry" and "otherEntries". In the context of a partition merge, the preferredEntry is the primary replica of a CacheEntry stored in the partition that contains the most nodes or if partitions are equal the one with the largest topologyId. In the event of overlapping partitions, i.e. a node A is present in the topology of both partitions {A}, {A,B,C}, we pick {A} as the preferred partition as it will have the higher topologId as the other partition&#8217;s topology is behind. When a partition merge is not occurring, the "preferredEntry" is simply the primary replica of the CacheEntry. The second parameter, "otherEntries" is simply a list of all other entries associated with the key for which a conflict was detected.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon"> <i class="fa icon-note" title="Note"></i> </td> <td class="content"> EntryMergePolicy::merge is only called when a conflict has been detected, it is not called if all CacheEntrys are the same. </td> </tr> </table> </div> <div class="paragraph"> <p>Currently Infinispan provides the following implementations of EntryMergePolicy:</p> </div> <table class="tableblock frame-all grid-all stretch"> <colgroup> <col style="width: 50%;"> <col style="width: 50%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">Policy</th> <th class="tableblock halign-left valign-top">Description</th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">MergePolicy.NONE (default)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">No attempt is made to resolve conflicts. Entries hosted on the minority partition are removed and the nodes in this partition do not hold any data until the rebalance starts. Note, this behaviour is equivalent to prior Infinispan versions which did not support conflict resolution. Note, in this case all changes made to entries hosted on the minority partition are lost, but once the rebalance has finished all entries will be consistent.</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">MergePolicy.PREFERRED_ALWAYS</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Always utilise the "preferredEntry". MergePolicy.NONE is almost equivalent to PREFERRED_ALWAYS, albeit without the performance impact of performing conflict resolution, therefore MergePolicy.NONE should be chosen unless the following scenario is a concern. When utilising the DENY_READ_WRITES or DENY_READ strategy, it is possible for a write operation to only partially complete when the partitions enter DEGRADED mode, resulting in replicas containing inconsistent values. MergePolicy.PREFERRED_ALWAYS will detect said inconsistency and resolve it, whereas with MergePolicy.NONE the CacheEntry replicas will remain inconsistent after the cluster has rebalanced.</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">MergePolicy.PREFERRED_NON_NULL</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Utilise the "preferredEntry" if it is non-null, otherwise utilise the first entry from "otherEntries".</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">MergePolicy.REMOVE_ALL</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Always remove a key from the cache when a conflict is detected.</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Fully qualified class name</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">The custom implementation for merge will be used <a href="#partition_handling_custom_merge_policy">Custom merge policy</a></p></td> </tr> </tbody> </table> </div> </div> <div class="sect3"> <h4 id="conflict_manager_usage"><a class="anchor" href="#conflict_manager_usage"></a>2.8.4. Usage</h4> <div class="paragraph"> <p>During a partition merge the ConflictManager automatically attempts to resolve conflicts utilising the configured EntryMergePolicy, however it is also possible to manually search for/resolve conflicts as required by your application.</p> </div> <div class="paragraph"> <p>The code below shows how to retrieve an EmbeddedCacheManager&#8217;s ConflictManager, how to retrieve all versions of a given key and how to check for conflicts across a given cache.</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java">EmbeddedCacheManager manager = <span class="keyword">new</span> DefaultCacheManager(<span class="string"><span class="delimiter">&quot;</span><span class="content">example-config.xml</span><span class="delimiter">&quot;</span></span>);
Cache&lt;<span class="predefined-type">Integer</span>, <span class="predefined-type">String</span>&gt; cache = manager.getCache(<span class="string"><span class="delimiter">&quot;</span><span class="content">testCache</span><span class="delimiter">&quot;</span></span>);
ConflictManager&lt;<span class="predefined-type">Integer</span>, <span class="predefined-type">String</span>&gt; crm = ConflictManagerFactory.get(cache.getAdvancedCache());

<span class="comment">// Get All Versions of Key</span>
<span class="predefined-type">Map</span>&lt;Address, InternalCacheValue&lt;<span class="predefined-type">String</span>&gt;&gt; versions = crm.getAllVersions(<span class="integer">1</span>);

<span class="comment">// Process conflicts stream and perform some operation on the cache</span>
Stream&lt;<span class="predefined-type">Map</span>&lt;Address, InternalCacheEntry&lt;<span class="predefined-type">Integer</span>, <span class="predefined-type">String</span>&gt;&gt;&gt; stream = crm.getConflicts();
stream.forEach(map -&gt; {
   CacheEntry&lt;<span class="predefined-type">Object</span>, <span class="predefined-type">Object</span>&gt; entry = map.values().iterator().next();
   <span class="predefined-type">Object</span> conflictKey = entry.getKey();
   cache.remove(conflictKey);
});

<span class="comment">// Detect and then resolve conflicts using the configured EntryMergePolicy</span>
crm.resolveConflicts();

<span class="comment">// Detect and then resolve conflicts using the passed EntryMergePolicy instance</span>
crm.resolveConflicts((preferredEntry, otherEntries) -&gt; preferredEntry);</code></pre> </div> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon"> <i class="fa icon-note" title="Note"></i> </td> <td class="content"> Although the <code>ConflictManager::getConflicts</code> stream is processed per entry, the underlying spliterator is in fact lazily-loading cache entries on a per segment basis. </td> </tr> </table> </div> </div> <div class="sect3"> <h4 id="partition_handling_configuration"><a class="anchor" href="#partition_handling_configuration"></a>2.8.5. Configuring partition handling</h4> <div class="paragraph"> <p>Unless the cache is distributed or replicated, partition handling configuration is ignored. The default partition handling strategy is ALLOW_READ_WRITES and the default EntryMergePolicy is MergePolicies::PREFERRED_ALWAYS.</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;distributed-cache</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">the-default-cache</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
   <span class="tag">&lt;partition-handling</span> <span class="attribute-name">when-split</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ALLOW_READ_WRITES</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">merge-policy</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">PREFERRED_NON_NULL</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/distributed-cache&gt;</span></code></pre> </div> </div> <div class="paragraph"> <p>The same can be achieved programmatically:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java">ConfigurationBuilder dcc = <span class="keyword">new</span> ConfigurationBuilder();
dcc.clustering().partitionHandling()
                    .whenSplit(PartitionHandling.ALLOW_READ_WRITES)
                    .mergePolicy(MergePolicies.PREFERRED_ALWAYS);</code></pre> </div> </div> <div class="sect4"> <h5 id="partition_handling_custom_merge_policy"><a class="anchor" href="#partition_handling_custom_merge_policy"></a>Implement a custom merge policy</h5> <div class="paragraph"> <p>It&#8217;s also possible to provide custom implementations of the EntryMergePolicy</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;distributed-cache</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">the-default-cache</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
   <span class="tag">&lt;partition-handling</span> <span class="attribute-name">when-split</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ALLOW_READ_WRITES</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">merge-policy</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.example.CustomMergePolicy</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/distributed-cache&gt;</span></code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java">ConfigurationBuilder dcc = <span class="keyword">new</span> ConfigurationBuilder();
dcc.clustering().partitionHandling()
                    .whenSplit(PartitionHandling.ALLOW_READ_WRITES)
                    .mergePolicy(<span class="keyword">new</span> CustomMergePolicy());</code></pre> </div> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">CustomMergePolicy</span> <span class="directive">implements</span> EntryMergePolicy&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; {

   <span class="annotation">@Override</span>
   <span class="directive">public</span> CacheEntry&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; merge(CacheEntry&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; preferredEntry, <span class="predefined-type">List</span>&lt;CacheEntry&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt;&gt; otherEntries) {
      <span class="comment">// decide which entry should be used</span>

      <span class="keyword">return</span> the_solved_CacheEntry;
   }</code></pre> </div> </div> </div> <div class="sect4"> <h5 id="deploy_custom_merge_policies_to_a_infinispan_server_instance"><a class="anchor" href="#deploy_custom_merge_policies_to_a_infinispan_server_instance"></a>Deploy custom merge policies to a Infinispan server instance</h5> <div class="paragraph"> <p>To utilise a custom EntryMergePolicy implementation on the server, it&#8217;s necessary for the implementation class(es) to be deployed to the server. This is accomplished by utilising the java service-provider convention and packaging the class files in a jar which has a META-INF/services/org.infinispan.conflict.EntryMergePolicy file containing the fully qualified class name of the EntryMergePolicy implementation.</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code># list all necessary implementations of EntryMergePolicy with the full qualified name
org.example.CustomMergePolicy</code></pre> </div> </div> <div class="paragraph"> <p>In order for a Custom merge policy to be utilised on the server, you should enable object storage, if your policies semantics require access to the stored Key/Value objects. This is because cache entries in the server may be stored in a marshalled format and the Key/Value objects returned to your policy would be instances of WrappedByteArray. However, if the custom policy only depends on the metadata associated with a cache entry, then object storage is not required and should be avoided (unless needed for other reasons) due to the additional performance cost of marshalling data per request. Finally, object storage is never required if one of the provided merge policies is used.</p> </div> </div> </div> <div class="sect3"> <h4 id="partition_handling_monitoring"><a class="anchor" href="#partition_handling_monitoring"></a>2.8.6. Monitoring and administration</h4> <div class="paragraph"> <p>The availability mode of a cache is exposed in JMX as an attribute in the <a href="https://docs.jboss.org/infinispan/10.0/apidocs/jmxComponents.html#Cache">Cache MBean</a>. The attribute is writable, allowing an administrator to forcefully migrate a cache from DEGRADED mode back to AVAILABLE (at the cost of consistency).</p> </div> <div class="paragraph"> <p>The availability mode is also accessible via the <a href="https://docs.jboss.org/infinispan/10.0/apidocs/org/infinispan/AdvancedCache.html">AdvancedCache</a> interface:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java">AdvancedCache ac = cache.getAdvancedCache();

<span class="comment">// Read the availability</span>
<span class="type">boolean</span> available = ac.getAvailability() == AvailabilityMode.AVAILABLE;

<span class="comment">// Change the availability</span>
<span class="keyword">if</span> (!available) {
   ac.setAvailability(AvailabilityMode.AVAILABLE);
}</code></pre> </div> </div> </div> </div> </div> </div> </div> <div id="footer"> <div id="footer-text"> Last updated 2019-07-12 16:02:11 UTC </div> </div> <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-8601422-1', 'auto');
  ga('send', 'pageview');

</script> <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
});
</script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script> </body> </html>