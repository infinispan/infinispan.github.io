<!DOCTYPE html> <html lang="en"> <head> <title>Blog - Infinispan</title> <meta charset="utf-8"> <meta content="width=device-width, initial-scale=1.0" name="viewport"> <meta content="DENY" http-equiv="X-Frame-Options"> <meta content="1; mode=block" http-equiv="X-XSS-Protection"> <meta content="nosniff" http-equiv="X-Content-Type-Options"> <link href="https://static.jboss.org/theme/css/bootstrap-community/3.2.0.2/bootstrap-community.min.css" media="screen" rel="stylesheet"> <link crossorigin="anonymous" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" rel="stylesheet"> <script id="dpal" src="https://www.redhat.com/dtm.js" type="text/javascript"></script> <link href="/images/favicon.png" rel="shortcut icon" type="image/png"> <link href="//static.jboss.org/images/example/apple-touch-icon-144x144-precomposed.png" rel="apple-touch-icon-precomposed" sizes="144x144"> <link href="//static.jboss.org/images/example/apple-touch-icon-114x114-precomposed.png" rel="apple-touch-icon-precomposed" sizes="114x114"> <link href="//static.jboss.org/images/example/apple-touch-icon-72x72-precomposed.png" rel="apple-touch-icon-precomposed" sizes="72x72"> <link href="//static.jboss.org/images/example/apple-touch-icon-precomposed.png" rel="apple-touch-icon-precomposed"> <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/github.min.css" rel="stylesheet"> <link href="https://static.jboss.org/css/rhbar.css" media="screen" rel="stylesheet"> <style>
      .jumbotron {
        padding: 0.5em 0.1em 0.5em 0.1em;
        background-image: none;
        background-color: #ffec9f;
      }
      .jumbotron p, 
      .jumbotron h1 {
        color: #656565;
      }
      .dropup {
        z-index: 1032;
      }
      .navbar {
        font-size: x-large;
      }
      .navbar ul {
        padding-top: 0.7em;
      }
      .navbar-brand {
        height: 80px;
      }
      .navbar-default {
        background-color: white;
      }
      .navbar-default .navbar-nav > li > a {
        color: #336699;
      }
      .navbar-default .navbar-nav > li > a:hover {
        color: #204060;
      }
      .navbar-default .navbar-nav > .open > a,
      .navbar-default .navbar-nav > .open > a:hover,
      .navbar-default .navbar-nav > .open > a:focus {
        background-color: #4a5d75;
      }
      h3.well {
        border-color: #ffd630;
        background-color: #ffec9f;
      }
      .panel-sidebar {
        border-color: #f5f5f5;
      }
      .panel-sidebar > .panel-heading {
        border-color: #e3e3e3;
        background-color: #f5f5f5;
        color: #656565;
      }
      .btn-primary {
        border-color: #ffd630;
        background-color: #ffec9f;
        color: #656565;
      }
      footer.container {
        background-color: white;
      }
      footer.container h1, footer.container h2, footer.container h3, footer.container h4, footer.container h5, footer.container h6, footer.container p, footer.container a {
        color: #656565;
      }
      footer.container ul {
        padding: 0;
      }
      i.enormous-icon {
        margin-top: 0.3em;
      }
      .home-examples {
        font-size: 16px;
      }
    </style> <script src="//static.jboss.org/theme/js/libs/jquery/jquery-1.9.1.min.js"></script> <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.7/highlight.min.js"></script> <script>
      hljs.initHighlightingOnLoad();
    </script> <script>
     (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
     
    ga('create', 'UA-8601422-1', 'auto');
    ga('send', 'pageview');
    
    </script> </head> <body> <div id=""> <ul class="visuallyhidden" id="top"> <li> <a accesskey="n" href="#nav" title="Skip to navigation">Skip to navigation</a> </li> <li> <a accesskey="c" href="#page" title="Skip to content">Skip to content</a> </li> </ul> <div id="rhbar"> <a class="jbdevlogo" href="http://www.jboss.org/projects/about"></a> <a class="rhlogo" href="http://www.redhat.com/"></a> </div> <div class="container" id="content"> <nav class="navbar navbar-default navbar-fixed-top"> <div class="container"> <div class="navbar-header"> <button aria-expanded="false" class="navbar-toggle collapsed" data-target="#thenavbar" data-toggle="collapse"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> <a class="navbar-brand" href="/"> <img alt="Infinispan" src="/images/infinispan_nav_brand.png"> </a> </div> <div class="navbar-collapse collapse" id="thenavbar"> <ul class="nav navbar-nav"> <li class="dropdown"> <a class="dropdown-toggle" data-toggle="dropdown" href="/about">About <b class="caret"></b></a> <ul class="dropdown-menu"> <li><a href="/about">Introduction</a></li> <li><a href="/features">Features</a></li> <li><a href="/release-notes">Release notes</a></li> <li><a href="/blog">Blog</a></li> <li><a href="/references">References</a></li> <li><a href="/experiments/">Experiments</a></li> </ul> </li> <li class="dropdown"> <a class="dropdown-toggle" data-toggle="dropdown" href="/documentation">Learn <b class="caret"></b></a> <ul class="dropdown-menu"> <li><a href="/documentation">Documentation</a></li> <li><a href="/tutorials">Tutorials</a></li> <li><a href="/videos">Videos</a></li> </ul> </li> <li class="dropdown"> <a class="dropdown-toggle" data-toggle="dropdown" href="/download">Download <b class="caret"></b></a> <ul class="dropdown-menu"> <li><a href="/download">Infinispan Releases</a></li> <li><a href="/cache-store-implementations">Cache Store Implementations</a></li> <li><a href="/hotrod-clients">Hot Rod Clients</a></li> <li><a href="/integrations">Integrations</a></li> <li><a href="/download-archive">Archive</a></li> </ul> </li> <li class="dropdown"> <a class="dropdown-toggle" data-toggle="dropdown" href="/community">Community <b class="caret"></b></a> <ul class="dropdown-menu"> <li><a href="/community">Ask for Help</a></li> <li><a href="/getinvolved">Get Involved</a></li> </ul> </li> <li class=""><a href="/roadmap">Road Map</a></li> <li class="divider"></li> </ul> </div> </div> </nav> <div class="post"></div> <h3> Monday, 19 February 2018 </h3> <h1> <a href="/blog/2018/02/19/distributed-iteration-improvements/">Distributed iteration improvements</a> </h1> <div class="content"> <div id="preamble"> <div class="sectionbody"> <div class="paragraph"> <p>Infinispan hasn&#8217;t always provided a way for iterating upon entries in a distributed cache. In fact the <a href="https://issues.jboss.org/browse/ISPN-4222">first iteration</a> wasn&#8217;t until Infinispan 7. Then in Infinispan 8, with the addition of Java 8, we fully integrated this into <a href="http://blog.infinispan.org/2015/09/distributed-streams.html">distributed streams</a>, which brought some minor iteration improvements in performance.</p> </div> <div class="paragraph"> <p>We are proud to announce that with Infinispan 9.2 there are even more improvements. This contains no API changes, although those will surely come in the future. This one is purely for performance and utilization.</p> </div> </div> </div> <div class="sect1"> <h2 id="_new_implementation_details"><a class="anchor" href="#_new_implementation_details"></a>New implementation details</h2> <div class="sectionbody"> <div class="sect2"> <h3 id=""><a class="anchor" href="#"></a> </h3> <div class="paragraph"> <p>There are a few different aspects that have been changed.  A lot of these revolve around the amount of entries being retrieved at once, which if you are familiar with DistributedStreams can be configured via the <a href="https://docs.jboss.org/infinispan/9.2/apidocs/org/infinispan/BaseCacheStream.html#distributedBatchSize-int-">distributedBatchSize</a> method. Note that if this is not specified it defaults to the <a href="https://docs.jboss.org/infinispan/9.2/apidocs/org/infinispan/configuration/cache/StateTransferConfigurationBuilder.html#chunkSize-int-">chunk size</a> in state transfer.</p> </div> <div class="sect3"> <h4 id="_entry_retrieval_is_now_pull_based_instead_of_push"><a class="anchor" href="#_entry_retrieval_is_now_pull_based_instead_of_push"></a>Entry retrieval is now pull based instead of push</h4> <div class="paragraph"> <p>Infinispan core (embedded) has added <a href="https://github.com/ReactiveX/RxJava/tree/2.x">rxjava2</a> and <a href="https://github.com/reactive-streams/reactive-streams-jvm">reactive streams</a> as dependencies and rewrote all of the old push style iterator code over to pull style to fully utilize the Publisher and Subscriber interfaces.</p> </div> <div class="paragraph"> <p>With this we only pull up to the batchSize in entries at a time from any set of nodes. The old style utilized push with call stack blocking, which could return up two times the amount of entries. Also since we aren&#8217;t performing call stack blocking, we don&#8217;t have to waste threads as these calls to retrieve entries are done async and finish very quickly irrespective of user interaction. The old method required multiple threads to be reserved for this purpose.</p> </div> </div> <div class="sect3"> <h4 id="_streamed_batches"><a class="anchor" href="#_streamed_batches"></a>Streamed batches</h4> <div class="paragraph"> <p>The responses from a remote node are written directly to the output stream so there are no intermediate collections allocated. This means we only have to iterate upon the data once as we retain the iterator between requests. On the originator we still have to store the batches in a collection to be enqueued for the user to pull.</p> </div> </div> <div class="sect3"> <h4 id="_rewritten_parallel_distribution"><a class="anchor" href="#_rewritten_parallel_distribution"></a>Rewritten Parallel Distribution</h4> <div class="paragraph"> <p>Great care was taken to implement parallel distribution in a way to vastly reduce contention and ensure that we properly follow the batchSize configuration.</p> </div> <div class="paragraph"> <p>When parallel distribution is in use the new implementation will start 4 remote node requests sharing the batch size (so each one gets 1/4). This way we can guarantee that we only have the desired size irrespective of the number of nodes in the cluster. The old implementation would request batchSize from all nodes at the same time. So not only did it reserve a thread for node but could easily swamp your JVM memory, causing OutOfMemoryErrors (which no one likes). The latter alone made us force the default to be sequential distribution when using an iterator.</p> </div> <div class="paragraph"> <p>The old implementation would write entries from all nodes (including local) to the same shared queue. The new implementation has a different queue for each request, which allows for faster queues with no locking to be used.</p> </div> <div class="paragraph"> <p>Due to these changes and other isolations between threads, we can now make parallel distribution the default setting for the iterator method. And as you will see this has improved performance nicely.</p> </div> </div> </div> </div> </div> <div class="sect1"> <h2 id="_performance"><a class="anchor" href="#_performance"></a>Performance</h2> <div class="sectionbody"> <div class="paragraph"> <p>We have written a <a href="http://openjdk.java.net/projects/code-tools/jmh/">JMH</a> test harness specifically for this blog post, testing 9.1.5.Final <a href="https://github.com/infinispan/infinispan/releases/tag/9.1.5.Final">build</a> against latest 9.2.0.SNAPSHOT. The test runs by default with 4GB of heap with 6 nodes in a distributed cache with 2 owners. It has varying entry count, entry sizes and distributed batch sizes.</p> </div> <div class="paragraph"> <p>Due to the variance in each test a large number of tests were ran and with different permutations to make sure it covered a large amount of test cases. The JMH test that was ran can be found at <a href="https://github.com/infinispan/infinispan-benchmarks/tree/master/iteration">github</a>. All the default settings were used for the run except -t4 (runs with 4 worker threads) was provided. This was all ran on my measly laptop (i7-4810MQ and 16 GB) - maxing out the CPU was not a hard task.</p> </div> <div class="paragraph"> <p><strong>CAVEAT</strong>: The tests don&#8217;t do anything with the iterator and just try to pull them as fast as they can. Obviously if you have a lot of processing done between iterations you will likely not see as good of a performance increase.</p> </div> <div class="paragraph"> <p>The entire results can be found <a href="https://docs.google.com/spreadsheets/d/18v8e6vG-4aX8Pk-ihB3p1H5cQvsSQlFMhQSKxPhSLf0/edit?usp=sharing">here</a>. It shows each permutation and how many operations per second and finds the difference (green shows 5% or more and red shows -5% or less).</p> </div> <table class="tableblock frame-all grid-all stretch"> <colgroup> <col style="width: 33.3333%;"> <col style="width: 33.3333%;"> <col style="width: 33.3334%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">Operation</th> <th class="tableblock halign-left valign-top">Average Gain</th> <th class="tableblock halign-left valign-top">Code</th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Specified Distribution Mode</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">3.5%</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">.entrySet().stream().sequentialDistribution.iterator()</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Default</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">11%</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">.entrySet().iterator()</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">No Rehash</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">14%</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">.entrySet().stream().disableRehashAware().iterator()</p></td> </tr> </tbody> </table> <div class="paragraph"> <p>The above 3 rows show a few different ways you could have been invoking the iterator method. The second row is probably by far the most used case. In this case you should see around a <strong>11</strong>% increase in performance (results will vary). This is due to the new pulling method as well as parallel distribution becoming the new default running mode. It is unlikely a user was using the other 2 methods, but are provided for a more complete view.</p> </div> <div class="paragraph"> <p>If you were specifying a distribution mode manually, either sequential or distribution you will only see a few percent faster run (<strong>3.5</strong>%), but every little bit helps! Also if you can switch to parallel you may want to think about doing so.</p> </div> <div class="paragraph"> <p>Also you can see if you were running with rehash disabled prior, it has even more gains (<strong>14</strong>%). Those don&#8217;t even include the fact that no rehash was <strong>28</strong>% faster than with before (which means it is about <strong>32</strong>% faster in general now). So if you can get away with a <em>at most once</em> guarantee, disabling rehash will provide the best throughput.</p> </div> </div> </div> <div class="sect1"> <h2 id="_whats_next"><a class="anchor" href="#_whats_next"></a>Whats next? </h2> <div class="sectionbody"> <div class="paragraph"> <p>As was mentioned this is not exposed to the user directly. You still interact with the iterator as you would normally. We should remedy this at some point.</p> </div> <div class="sect2"> <h3 id="_expose_new_method"><a class="anchor" href="#_expose_new_method"></a>Expose new method</h3> <div class="paragraph"> <p>We would love to eventually expose a method to return a Publisher directly to the user so that they can get the full benefits of having a pull based implementation underneath.</p> </div> <div class="paragraph"> <p>This way any intermediate operations applied to the stream before would be distributed and anything applied to the Publisher would be done locally. And just like the iterator method this publisher would be fully rehash aware if you have it configured to do so and would make sure you get all entries delivered in an <em>exactly once</em> fashion (rehash disabled guarantees <em>at most once</em>).</p> </div> <div class="paragraph"> <p>Another side benefit is that the Subscriber methods could be called on different threads so there is no overhead required on the ISPN side for coordinating these into queue(s). Thus the Subscriber <em>should</em> be able to retrieve all entries faster than just doing an iterator.</p> </div> </div> <div class="sect2"> <h3 id="_java_9_flow"><a class="anchor" href="#_java_9_flow"></a>Java 9 Flow</h3> <div class="paragraph"> <p>Also many of you may be wondering why we aren&#8217;t using the new Flow API introduced in Java 9. Luckily the Flow API is a 1:1 conversion of reactive streams. So whenever Infinispan will start supporting Java 9 interfaces/classes, we hope to properly expose these as the JDK classes.</p> </div> </div> <div class="sect2"> <h3 id="_segment_based_iteration"><a class="anchor" href="#_segment_based_iteration"></a>Segment Based Iteration </h3> <div class="paragraph"> <p>With Infinispan 9.3, we hope to introduce <a href="https://issues.jboss.org/browse/ISPN-5451">data container</a> and <a href="https://issues.jboss.org/browse/ISPN-6026">cache store</a> segment aware iteration. This means when iterating over either we would only have to process entries that map to a given segment. This should reduce the time and processing for iteration substantially, especially for cache stores. Keep your eyes out for a future blog post detailing these as 9.3 development commences.</p> </div> </div> <div class="sect2"> <h3 id="_give_us_feedback"><a class="anchor" href="#_give_us_feedback"></a>Give us Feedback</h3> <div class="paragraph"> <p>We hope you find a bit more performance when working with your distributed iteration. Also we value any feedback on what you want our APIs to look like or find any bugs. As always let us know at any of the places listed <a href="http://infinispan.org/community/">here</a>.</p> </div> </div> </div> </div> </div> <a class="label" href="/blog/tags/9.2/"> 9.2 </a> <a class="label" href="/blog/tags/performance/"> performance </a> <a class="label" href="/blog/tags/streams/"> streams </a> <a class="label" href="/blog/tags/distribution/"> distribution </a> <a class="label" href="/blog/tags/iteration/"> iteration </a> <hr> <div class="post"></div> <h3> Monday, 05 December 2016 </h3> <h1> <a href="/blog/2016/12/05/infinispan-900beta1-ruppaner/">Infinispan 9.0.0.Beta1 "Ruppaner"</a> </h1> <div class="content"> <div id="preamble"> <div class="sectionbody"> <div class="paragraph"> <p><a href="http://design.jboss.org/infinispan/infinispan9/logo/final/infinispan9_pixelsizes_600.gif"><span class="image"><img src="http://design.jboss.org/infinispan/infinispan9/logo/final/infinispan9_pixelsizes_600.gif" alt="image" width="320" height="77"></span></a></p> </div> <div class="paragraph"> <p>It took us quite a bit to get here, but we&#8217;re finally ready to announce Infinispan 9.0.0.Beta1, which comes loaded with a ton of goodies.</p> </div> <div class="paragraph"> <p>Performance improvements</p> </div> <div class="ulist"> <ul> <li> <p>JGroups 4</p> </li> <li> <p>A new algorithm for non-transactional writes (aka the Triangle) which reduces the number of RPCs required when performing writes </p> </li> <li> <p>A new faster internal marshaller which produced smaller payloads. </p> </li> <li> <p>A new asynchronous interceptor core</p> </li> </ul> </div> <div class="paragraph"> <p>Off-Heap support</p> </div> <div class="ulist"> <ul> <li> <p>Avoid the size of the data in the caches affecting your GC times</p> </li> </ul> </div> <div class="paragraph"> <p><a href="https://github.com/ben-manes/caffeine">CaffeineMap</a>-based bounded data container</p> </div> <div class="ulist"> <ul> <li> <p>Superior performance</p> </li> <li> <p>More reliable eviction</p> </li> </ul> </div> <div class="paragraph"> <p>Ickle, Infinispan&#8217;s new query language</p> </div> <div class="ulist"> <ul> <li> <p>A limited yet powerful subset of JPQL</p> </li> <li> <p>Supports full-text predicates</p> </li> </ul> </div> <div class="paragraph"> <p>The Server Admin console now supports both Standalone and Domain modes</p> </div> <div class="paragraph"> <p>Pluggable marshallers for Kryo and ProtoStuff</p> </div> <div class="paragraph"> <p>The LevelDB cache store has been replaced with the better-maintained and faster <a href="http://rocksdb.org/">RocksDB</a> </p> </div> <div class="paragraph"> <p>Spring Session support</p> </div> <div class="paragraph"> <p>Upgraded Spring to 4.3.4.RELEASE</p> </div> <div class="paragraph"> <p>We will be blogging about the above in detail over the coming weeks, including benchmarks and tutorials.</p> </div> <div class="paragraph"> <p>The following improvements were also present in our previous Alpha releases:</p> </div> <div class="paragraph"> <p>Graceful clustered shutdown / restart with persistent state</p> </div> <div class="paragraph"> <p>Support for streaming values over Hot Rod, useful when you are dealing with very large entries</p> </div> <div class="paragraph"> <p>Cloud and Containers</p> </div> <div class="ulist"> <ul> <li> <p>Out-of-the box support for Kubernetes discovery</p> </li> </ul> </div> <div class="paragraph"> <p>Cache store improvements</p> </div> <div class="ulist"> <ul> <li> <p>The JDBC cache store now use transactions and upserts. Also the internal connection pool is now based on <a href="https://brettwooldridge.github.io/HikariCP/">HikariCP</a></p> </li> </ul> </div> <div class="paragraph"> <p>Also, our documentation has received a big overhaul and we believe it is vastly superior than before.</p> </div> <div class="paragraph"> <p>There will be one more Beta including further performance improvements as well as additional features, so stay tuned.</p> </div> <div class="paragraph"> <p>Infinispan 9 is codenamed "Ruppaner" in honor of the <a href="http://www.ruppaner-bodensee.de/die-brauerei/">Konstanz brewery</a>, since many of the improvements of this release have been brewed on the shores of the Bodensee !</p> </div> <div class="paragraph"> <p>Prost!</p> </div> </div> </div> </div> <a class="label" href="/blog/tags/9.0/"> 9.0 </a> <a class="label" href="/blog/tags/beta/"> beta </a> <a class="label" href="/blog/tags/release/"> release </a> <a class="label" href="/blog/tags/marshalling/"> marshalling </a> <a class="label" href="/blog/tags/off-heap/"> off-heap </a> <a class="label" href="/blog/tags/performance/"> performance </a> <a class="label" href="/blog/tags/query/"> query </a> <hr> <div class="post"></div> <h3> Friday, 09 January 2015 </h3> <h1> <a href="/blog/2015/01/09/infinispan-710beta1/">Infinispan 7.1.0.Beta1</a> </h1> <div class="content"> <div id="preamble"> <div class="sectionbody"> <div class="paragraph"> <p>Dear Infinispan community,</p> </div> <div class="paragraph"> <p>We&#8217;re proud to announce the first Beta release of Infinispan 7.1.0.</p> </div> <div class="paragraph"> <p>Infinispan brings the following major improvements:</p> </div> <div class="ulist"> <ul> <li> <p>Near-Cache support for Remote HotRod caches</p> </li> <li> <p>Annotation-based generation of ProtoBuf serializers which removes the need to write the schema files by hand and greatly improves usability of Remote Queries</p> </li> <li> <p>Cluster Listener Event Batching, which coalesces events for better performance</p> </li> <li> <p>Cluster- and node-wide aggregated statistics</p> </li> <li> <p>Vast improvements to the indexing performance</p> </li> <li> <p>Support for domain mode and the security vault in the server</p> </li> <li> <p>Further improvements to the Partition Handling with many stability fixes and the removal of the Unavailable mode: a cluster can now be either Available or Degraded.</p> </li> </ul> </div> <div class="paragraph"> <p>Of course there&#8217;s also the usual slew of bug fixes, performance and memory usage improvements and documentation cleanups.</p> </div> <div class="paragraph"> <p>Feel free to join us and shape the future releases on our <a href="http://www.jboss.org/infinispan/forums">forums</a>, our <a href="https://lists.jboss.org/mailman/listinfo/infinispan-dev">mailing lists</a> or our <a href="http://webchat.freenode.net/?channels=%23infinispan">#infinispan</a> IRC channel.</p> </div> <div class="paragraph"> <p>For a complete list of features and bug fixes included in this release please refer to the <a href="https://issues.jboss.org/secure/ReleaseNote.jspa?projectId=12310799&amp;version=12325979">release notes</a>. Visit our <a href="http://infinispan.org/download/">downloads</a> section to find the latest release.</p> </div> <div class="paragraph"> <p>Thanks to everyone for their involvement and contribution!</p> </div> </div> </div> </div> <a class="label" href="/blog/tags/release/"> release </a> <a class="label" href="/blog/tags/near caching/"> near caching </a> <a class="label" href="/blog/tags/7.1/"> 7.1 </a> <a class="label" href="/blog/tags/domain mode/"> domain mode </a> <a class="label" href="/blog/tags/performance/"> performance </a> <a class="label" href="/blog/tags/Protobuf/"> Protobuf </a> <a class="label" href="/blog/tags/indexing/"> indexing </a> <a class="label" href="/blog/tags/annotations/"> annotations </a> <hr> <div class="post"></div> <h3> Thursday, 05 June 2014 </h3> <h1> <a href="/blog/2014/06/05/mapreduce-performance-improvements/">Map/Reduce Performance improvements between Infinispan 6 and 7</a> </h1> <div class="content"> <div class="sect1"> <h2 id="_introduction"><a class="anchor" href="#_introduction"></a>Introduction</h2> <div class="sectionbody"> <div class="paragraph"> <p>There have been a number of recent Infinispan 7.0 Map/Reduce performance related <a href="https://issues.jboss.org/browse/ISPN-4241?filter=12321790">improvements</a> that we were eager to test in our performance lab and subsequently share with you. The results are more than promising. In the word count use case, Map/Reduce task execution speed and throughput improvement is between fourfold and sixfold in certain situations that were tested.</p> </div> <div class="paragraph"> <p>We have achieved these improvements by focusing on:</p> </div> <div class="ulist"> <ul> <li> <p>Optimized mapper/reducer parallel execution on all nodes</p> </li> <li> <p>Improving the handling and processing of larger data sets</p> </li> <li> <p>Reducing the amount of memory needed for execution of MapReduceTask</p> </li> </ul> </div> </div> </div> <div class="sect1"> <h2 id="_performance_test_results"><a class="anchor" href="#_performance_test_results"></a>Performance Test Results</h2> <div class="sectionbody"> <div class="paragraph"> <p>The performance tests were run using the following parameters:</p> </div> <div class="ulist"> <ul> <li> <p>An Infinispan 7.0.0-SNAPSHOT build created after the last commits from the list were committed to the Infinispan GIT repo on May 9th vs Infinispan 6.0.1.Final </p> </li> <li> <p>OpenJDK version 1.7.0_55 with 4GB of heap and the following JVM options:</p> </li> <li> <p>Random data filled 30% of the Java heap, and 100 random words were used to create the 8 kilobyte cache values. The cache keys were generated using key affinity, so that the generated data would be distributed evenly in the cache. These values were chosen, so that a comparison to Infinispan 6 could be made. Infinispan 7 can handle a final result map with a much larger set of keys than is possible in Infinispan 6. The actual amount of heap size that is used for data will be larger due to backup copies, since the cluster is running in distributed mode.</p> </li> <li> <p>The MapReduceTask executes a word count against the cache values using <a href="https://github.com/infinispan/infinispan/blob/master/demos/distexec/src/main/java/org/infinispan/demo/mapreduce/WordCountMapperEmitPerValue.java">mapper</a>, <a href="https://github.com/infinispan/infinispan/blob/master/demos/distexec/src/main/java/org/infinispan/demo/mapreduce/WordCountReducer.java">reducer, combiner</a>, and <a href="https://github.com/infinispan/infinispan/blob/master/demos/distexec/src/main/java/org/infinispan/demo/mapreduce/WordCountCollator.java">collator</a> implementations. The collator returns the 10 most frequently occurring words in the cache data. The task used a distributed reduce phase and a shared intermediate cache. The MapReduceTask is executed 10 times against the data in the cache and the values are reported as an average of these durations.</p> </li> </ul> </div> <div class="sect2"> <h3 id="_from_1_to_8_nodes_using_a_fixed_amount_of_data_and_30_of_the_heap"><a class="anchor" href="#_from_1_to_8_nodes_using_a_fixed_amount_of_data_and_30_of_the_heap"></a>From 1 to 8 nodes using a fixed amount of data and 30% of the heap</h3> <div class="paragraph"> <p>This test executes two word count executions on each cluster with an increasing number of nodes. The first execution uses an increasing amount of data equal to 30% of the total Java heap across the cluster (i.e. With one node, the data consumes 30% of 4 GB. With two nodes, the data consumes 30% of 8 GB, etc.), and the second execution uses a fixed amount of data, (1352 MB which is approximately 30% of 4 GB). Throughput is calculated by dividing the total amount of data processed by the Map/Reduce task by the duration. The following charts show the throughput as nodes are added to the cluster for these two scenarios:</p> </div> <div class="paragraph"> <p><a href="http://3.bp.blogspot.com/-TZD4uFGgkuc/U5ApZx-8KGI/AAAAAAAAABo/VSJkbhFFnDg/s1600/ISPN_6_fixed_size_and_30%25_throughput.png"><span class="image"><img src="http://3.bp.blogspot.com/-TZD4uFGgkuc/U5ApZx-8KGI/AAAAAAAAABo/VSJkbhFFnDg/s1600/ISPN_6_fixed_size_and_30%25_throughput.png" alt="image"></span></a></p> </div> <div class="paragraph"> <p><a href="http://3.bp.blogspot.com/-pCrAYjE-GF4/U5ApZ1CkjXI/AAAAAAAAABs/5FNXfsU-eBc/s1600/ISPN_7_fixed_size_and_30%25_throughput.png"><span class="image"><img src="http://3.bp.blogspot.com/-pCrAYjE-GF4/U5ApZ1CkjXI/AAAAAAAAABs/5FNXfsU-eBc/s1600/ISPN_7_fixed_size_and_30%25_throughput.png" alt="image"></span></a></p> </div> <div class="paragraph"> <p>These charts clearly show the increase in throughput that were made in Infinispan 7. The throughput also seems to scale in an almost linear fashion for this word count scenario. With one node, Infinispan 7 processes the 30% of heap data in about 100 MB/sec, two nodes process almost 200 MB/sec, and 8 nodes process over 700 MB/sec.</p> </div> </div> <div class="sect2"> <h3 id="_from_1_to_8_nodes_using_different_heap_size_percentages"><a class="anchor" href="#_from_1_to_8_nodes_using_different_heap_size_percentages"></a>From 1 to 8 nodes using different heap size percentages</h3> <div class="paragraph"> <p>This test executes the word count task using different percentages of heap size as nodes are added to the cluster. (5%, 10%, 15%, 20%, 25%, and 30%) Here are the throughput results for this test:</p> </div> <div class="paragraph"> <p><a href="http://2.bp.blogspot.com/-exDRqNYcquI/U5AqAFGveiI/AAAAAAAAAB4/Yqn0_j6bL-w/s1600/ISPN6_multi_ram_percent_throughput.png"><span class="image"><img src="http://2.bp.blogspot.com/-exDRqNYcquI/U5AqAFGveiI/AAAAAAAAAB4/Yqn0_j6bL-w/s1600/ISPN6_multi_ram_percent_throughput.png" alt="image"></span></a>http://2.bp.blogspot.com/-fqmkYkxZtyI/U5AqS08Xk9I/AAAAAAAAACA/_wsTOmSbkdc/s1600/ISPN7_multi_ram_percent_throughput.png[<span class="image"><img src="http://2.bp.blogspot.com/-fqmkYkxZtyI/U5AqS08Xk9I/AAAAAAAAACA/_wsTOmSbkdc/s1600/ISPN7_multi_ram_percent_throughput.png" alt="image"></span>]</p> </div> <div class="paragraph"> <p>Once again, these charts show an increase in throughput when performing the same word count task using Infinispan 7. The chart for Infinispan 7 shows more fluctuation in the throughput across the different percentages of heap size. The throughput plotted in the Infinispan 6 chart is more consistent.</p> </div> </div> <div class="sect2"> <h3 id="_from_1_to_8_nodes_using_different_value_sizes"><a class="anchor" href="#_from_1_to_8_nodes_using_different_value_sizes"></a>From 1 to 8 nodes using different value sizes</h3> <div class="paragraph"> <p>This test executes the word count task using 30% of the heap size and different cache value sizes as nodes are added to the cluster. (1KB, 2KB, 4KB, 8KB, 16KB, 32KB, 64KB, 128KB, 256KB, 512KB, 1MB, and 2MB) Here are the throughput results for this test:</p> </div> <div class="paragraph"> <p><a href="http://3.bp.blogspot.com/-Roq8XeAB9Tw/U48EUKEGezI/AAAAAAAAABQ/tM3VSPv8iik/s1600/ISPN6_multi_value_size_throughput.png"><span class="image"><img src="http://3.bp.blogspot.com/-Roq8XeAB9Tw/U48EUKEGezI/AAAAAAAAABQ/tM3VSPv8iik/s1600/ISPN6_multi_value_size_throughput.png" alt="image"></span></a></p> </div> <div class="paragraph"> <p><a href="http://4.bp.blogspot.com/-GSUDu54xlXg/U48EVvvhcbI/AAAAAAAAABY/bUI1o2YFUpY/s1600/ISPN7_multi_value_size_throughput.png"><span class="image"><img src="http://4.bp.blogspot.com/-GSUDu54xlXg/U48EVvvhcbI/AAAAAAAAABY/bUI1o2YFUpY/s1600/ISPN7_multi_value_size_throughput.png" alt="image"></span></a></p> </div> <div class="paragraph"> <p>These results are more interesting. The throughput in Infinispan 7 is higher for certain cache size values, but closer to Infinispan 6 or even slower for other cache size values. The throughput peaks for 32KB cache values, but can be much lower for larger and smaller values. Smaller values require more overhead, but for larger values this behavior is not expected. This result needs to be investigated more closely.</p> </div> </div> </div> </div> <div class="sect1"> <h2 id="_conclusion"><a class="anchor" href="#_conclusion"></a>Conclusion</h2> <div class="sectionbody"> <div class="paragraph"> <p>The performance tests show that Infinispan 7 Map/Reduce improvements have increased the throughput and execution speed four to sixfold in some use cases. The changes have also allowed Infinispan 7 to process data sets that include larger intermediate results and produce larger final result maps. There are still areas of the Map/Reduce algorithm that need to be improved:</p> </div> <div class="ulist"> <ul> <li> <p>The Map/Reduce algorithm should be self-tuning. The <a href="https://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/distexec/mapreduce/MapReduceTask.java#L400">maxCollectorSize</a> parameter controls the number of values that the collector holds in memory, and it is not trivial to determine the optimal value for a given scenario. The value is based on the size of the values in the cache and the size of the intermediate results. A user is likely to know the size of the cache values, but currently <a href="https://issues.jboss.org/browse/ISPN-4318">Infinispan does not report statistics</a> about the intermediate results to the user. The Map/Reduce algorithm should analyze the environment at runtime and adjust the size of the collector dynamically.</p> </li> <li> <p>The fact that the throughput results vary with different value sizes needs to be investigated more closely. This could be due to the fact that the maxCollectorSize value used for these tests is not ideal for all value sizes, but there might be other causes for this behaviour.</p> </li> </ul> </div> </div> </div> </div> <a class="label" href="/blog/tags/radargun/"> radargun </a> <a class="label" href="/blog/tags/benchmarks/"> benchmarks </a> <a class="label" href="/blog/tags/performance/"> performance </a> <a class="label" href="/blog/tags/map reduce/"> map reduce </a> <a class="label" href="/blog/tags/7.0/"> 7.0 </a> <a class="label" href="/blog/tags/6.0/"> 6.0 </a> <hr> <div class="post"></div> <h3> Wednesday, 16 October 2013 </h3> <h1> <a href="/blog/2013/10/16/new-book-performance-of-open-source/">New book: Performance of Open Source Applications, with a chapter on Infinispan</a> </h1> <div class="content"> <div class="sect1"> <h2 id="_note_cross_posted_from_maniks_personal_blog"><a class="anchor" href="#_note_cross_posted_from_maniks_personal_blog"></a><em>*NOTE:* Cross-posted from <a href="http://manik.surtani.org/2013/10/new-book-performance-of-open-source.html">Manik&#8217;s personal blog</a></em></h2> <div class="sectionbody"> <div class="paragraph"> <p><a href="http://aosabook.org/en/index.html"><span class="image"><img src="http://aosabook.org/images/posa-cover.png" alt="image" width="242" height="320"></span></a>From the good folks who brought you the excellent <a href="http://aosabook.org/en/index.html">Architecture of Open Source Applications</a> (AOSA), available for free online, as a PDF, for e-book readers or as a good old-fashioned dead tree, we&#8217;re now treated to a new tome - the <a href="http://aosabook.org/en/index.html">Performance of Open Source Applications</a> (POSA).</p> </div> <div class="paragraph"> <p>POSA follows the same concept as AOSA - a different authoritative figure in the open source community is responsible for each chapter, providing you with excellent insight on how some of the most popular open source applications have been designed and built.  POSA focuses specifically on performance rather than general software architecture, and I&#8217;ve contributed a chapter on the performance related work conducted for Infinispan (see <a href="http://aosabook.org/en/posa/infinispan.html">Chapter 7</a>).</p> </div> <div class="paragraph"> <p>Have a read, I&#8217;d love to know what you think.</p> </div> <div class="paragraph"> <p>Cheers Manik</p> </div> </div> </div> </div> <a class="label" href="/blog/tags/performance/"> performance </a> <a class="label" href="/blog/tags/book/"> book </a> <hr> <div class="post"></div> <h3> Monday, 16 September 2013 </h3> <h1> <a href="/blog/2013/09/16/new-persistence-api-in-infinispan/">New persistence API in Infinispan 6.0.0.Alpha4</a> </h1> <div class="content"> <div id="preamble"> <div class="sectionbody"> <div class="paragraph"> <p>The existing CacheLoader/CacheStore API has been around since Infinispan 4.0. In this release of Infinispan we&#8217;ve taken a major step forward in both simplifying the integration with persistence and opening the door for some pretty significant performance improvements.</p> </div> </div> </div> <div class="sect1"> <h2 id="_whats_new"><a class="anchor" href="#_whats_new"></a>What&#8217;s new</h2> <div class="sectionbody"> <div class="paragraph"> <p>So here&#8217;s what the new persistence integration brings to the table:</p> </div> <div class="ulist"> <ul> <li> <p>alignment with <a href="http://jcp.org/en/jsr/detail?id=107">JSR-107</a>: now we have a <a href="http://docs.jboss.org/infinispan/6.0/apidocs/org/infinispan/persistence/spi/CacheWriter.html">CacheWriter</a> and <a href="http://docs.jboss.org/infinispan/6.0/apidocs/org/infinispan/persistence/spi/CacheLoader.html">CacheLoader</a> interface similar to the the <a href="https://github.com/jsr107/jsr107spec/blob/master/src/main/java/javax/cache/integration/CacheLoader.java">loader</a> and <a href="https://github.com/jsr107/jsr107spec/blob/master/src/main/java/javax/cache/integration/CacheWriter.java">writer</a> in JSR 107, which should considerably help writing portable stores across JCache compliant vendors</p> </li> <li> <p>simplified transaction integration: all the locking is now handled within the Infinispan layer, so implementors don&#8217;t have to be concerned coordinating concurrent access to the store (old <a href="http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/loaders/LockSupportCacheStore.html">LockSupportCacheStore</a> is dropped for that reason).</p> </li> <li> <p>parallel iteration: it is now possible to iterate over entries in the store with multiple threads in parallel. Map/Reduce tasks immediately benefit from this, as the map/reduce  tasks now run in parallel over both the nodes in the cluster and within the same node (multiple threads)</p> </li> <li> <p><a href="https://issues.jboss.org/browse/ISPN-3512">reduced serialization</a> (translated in less CPU usage): the new API allows exposing the stored entries in serialized format. If an entry is fetched from persistent storage for the sole purpose of being sent remotely, we no longer need to deserialize it (when reading from the store) and serialize it back (when writing to the wire). Now we can write to the wire the serialized format as read fro the storage directly</p> </li> </ul> </div> </div> </div> <div class="sect1"> <h2 id="_api"><a class="anchor" href="#_api"></a>API</h2> <div class="sectionbody"> <div class="paragraph"> <p>Now let&#8217;s take a look at the API in more detail:</p> </div> <div class="paragraph"> <p><a href="http://1.bp.blogspot.com/-aqX4MDbuzy4/Ujbq-om6YsI/AAAAAAAAMkQ/taQggrqe7Kc/s1600/new_loader_API.png"><span class="image"><img src="http://1.bp.blogspot.com/-aqX4MDbuzy4/Ujbq-om6YsI/AAAAAAAAMkQ/taQggrqe7Kc/s320/new_loader_API.png" alt="image" width="320" height="305"></span></a></p> </div> <div class="paragraph"> <p>  The diagram above shows the main classes in the API:</p> </div> <div class="ulist"> <ul> <li> <p><a href="http://docs.jboss.org/infinispan/6.0/apidocs/org/infinispan/commons/io/ByteBuffer.html">ByteBuffer</a></p> <div class="ulist"> <ul> <li> <p>abstracts the serialized form on an object</p> </li> </ul> </div> </li> <li> <p><a href="http://docs.jboss.org/infinispan/6.0/apidocs/org/infinispan/persistence/spi/MarshalledEntry.html">MarshalledEntry</a> - abstracts the information held within a persistent store corresponding to a key-value added to the cache. Provides method for reading this information both in serialized (<a href="http://docs.jboss.org/infinispan/6.0/apidocs/org/infinispan/commons/io/ByteBuffer.html">ByteBuffer</a>) and deserialized (Object) format. Normally data read from the store is kept in serialized format and lazily deserialized on demand, within the <a href="http://docs.jboss.org/infinispan/6.0/apidocs/org/infinispan/persistence/spi/MarshalledEntry.html">MarshalledEntry</a> implementation</p> </li> <li> <p> <a href="http://docs.jboss.org/infinispan/6.0/apidocs/org/infinispan/persistence/spi/CacheWriter.html">CacheWriter</a> and <a href="http://docs.jboss.org/infinispan/6.0/apidocs/org/infinispan/persistence/spi/CacheLoader.html">CacheLoader</a>  provide basic methods for reading and writing to a store</p> </li> <li> <p><a href="http://docs.jboss.org/infinispan/6.0/apidocs/org/infinispan/persistence/spi/AdvancedCacheLoader.html">AdvancedCacheLoader</a> and <a href="http://docs.jboss.org/infinispan/6.0/apidocs/org/infinispan/persistence/spi/AdvancedCacheWriter.html">AdvancedCacheWriter</a> provide operations to manipulate the underlaying storage in bulk: parallel iteration and purging of expired entries, clear and size. </p> </li> </ul> </div> <div class="paragraph"> <p>A provider might choose to only implement a subset of these interfaces:</p> </div> <div class="ulist"> <ul> <li> <p>Not implementing the  <a href="http://docs.jboss.org/infinispan/6.0/apidocs/org/infinispan/persistence/spi/AdvancedCacheWriter.html">AdvancedCacheWriter</a> makes the given writer not usable for purging expired entries or clear</p> </li> <li> <p>Not implementing  the <a href="http://docs.jboss.org/infinispan/6.0/apidocs/org/infinispan/persistence/spi/AdvancedCacheLoader.html">AdvancedCacheLoader</a> makes the information stored in the given loader not used for preloading, nor for the map/reduce iteration</p> </li> </ul> </div> <div class="paragraph"> <p>If you&#8217;re looking at migrating your existing store to the new API, looking at the <a href="https://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/persistence/file/SingleFileStore.java">SingleFileStore</a>  for inspiration can be of great help.</p> </div> <div class="sect3"> <h4 id="_configuration"><a class="anchor" href="#_configuration"></a>Configuration</h4> <div class="paragraph"> <p>And finally, the way the stores are configured has changed:</p> </div> <div class="ulist"> <ul> <li> <p>the 5.x <em>loaders</em> element is now replaced with <em>persistence</em></p> </li> <li> <p>both the loaders and writers are configured through a unique <em>store</em> element  (vs <em>loader</em> and  <em>store</em>, as allowed in 5.x)</p> </li> <li> <p>the <em>preload</em> and <em>shared</em> attributes are configured at each individual store, giving more flexibility when it comes to configuring multiple chained stores </p> </li> </ul> </div> <div class="paragraph"> <p>Cheers,</p> </div> <div class="paragraph"> <p>Mircea</p> </div> </div> </div> </div> </div> <a class="label" href="/blog/tags/persistence/"> persistence </a> <a class="label" href="/blog/tags/jsr 107/"> jsr 107 </a> <a class="label" href="/blog/tags/loader/"> loader </a> <a class="label" href="/blog/tags/store/"> store </a> <a class="label" href="/blog/tags/performance/"> performance </a> <a class="label" href="/blog/tags/6.0/"> 6.0 </a> <a class="label" href="/blog/tags/API/"> API </a> <hr> <div class="post"></div> <h3> Thursday, 18 July 2013 </h3> <h1> <a href="/blog/2013/07/18/faster-file-cache-store-no-extra/">Faster file cache store (no extra dependencies!) in 6.0.0.Alpha1</a> </h1> <div class="content"> <div id="preamble"> <div class="sectionbody"> <div class="paragraph"> <p>As <a href="http://infinispan.blogspot.ch/2013/07/infinispan-600alpha1-is-out.html">announced yesterday by Adrian</a>, the brand new Infinispan 6.0.0.Alpha1 release contains a new file-based cache store which needs no extra dependencies. This is essentially a replacement of the existing FileCacheStore which didn&#8217;t perform as expected, and caused major issues due to the number of files it created.</p> </div> <div class="paragraph"> <p>The new cache store, contributed by a <a href="https://github.com/kblees">Karsten Blees</a> (who also contributed an improved asynchronous cache store), is called <a href="https://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/loaders/file/SingleFileCacheStore.java">SingleFileCacheStore</a> and it keeps all data in a single file. The way it looks up data is by keeping an in-memory index of keys and the positions of their values in this file. This design outperforms the existing FileCacheStore and even LevelDB based JNI cache store.</p> </div> <div class="paragraph"> <p>The classic case for a file based cache store is when you want to have a cache with a cache store available locally which stores data that has overflowed from memory, having exceeded size and/or time restrictions. We ran some performance tests to verify how fast different cache store implementations could deal with reading and writing overflowed data, and these are the results we got (in Ks):</p> </div> <div class="ulist"> <ul> <li> <p>FileCacheStore: 0.75k reads/s, 0.285k writes/s</p> </li> <li> <p>LevelDB-JNI impl: 46k reads/s, 15.2k writes/s</p> </li> <li> <p>SingleFileCacheStore: 458k reads/s, 137k writes/s</p> </li> </ul> </div> <div class="paragraph"> <p>The difference is quite astonishing but as already hinted, this performance increase comes at a cost. Having to maintain an index of keys and positions in the file in memory has a cost in terms of extra memory required, and potential impact on GC. That&#8217;s why the SingleFileCacheStore is not recommended for use cases where the keys are too big.</p> </div> <div class="paragraph"> <p>In order to help tame this memory consumption issues, the <a href="http://docs.jboss.org/infinispan/6.0/apidocs/org/infinispan/configuration/cache/SingleFileCacheStoreConfigurationBuilder.html#maxEntries(int)">size of the cache store can be optionally limited, providing a maximum number of entries to store in it</a>. However, setting this parameter will only work in use cases where Infinispan is used as a cache. When used as a cache, data not present in Infinispan can be recomputed or re-retrieved from the authoritative data store and stored in Infinispan cache. The reason for this limitation is because once the maximum number of entries is reached, older data in the cache store is removed, so if Infinispan was used as an authoritative data store, it would lead to data loss which is not good.</p> </div> <div class="paragraph"> <p>Existing FileCacheStore users might wonder: what is it gonna happen to the existing FileCacheStore? We&#8217;re not 100% sure yet what we&#8217;re going to do with it, but we&#8217;re looking into some ways to migrate data from the FileCacheStore to the SingleFileCacheStore. <a href="https://issues.jboss.org/browse/ISPN-3318">Some interesting ideas</a> have already been submitted which we&#8217;ll investigate in next Infinispan 6.0 pre-releases.</p> </div> <div class="paragraph"> <p>So, if you&#8217;re a FileCacheStore user, give the new SingleFileCacheStore a go and let us know how it goes! Switching from one to the other is <a href="https://github.com/infinispan/infinispan/blob/master/core/src/test/java/org/infinispan/loaders/file/SingleFileCacheStoreFunctionalTest.java#L58">easy</a> :)</p> </div> <div class="paragraph"> <p>Cheers,</p> </div> <div class="paragraph"> <p>Galder</p> </div> </div> </div> </div> <a class="label" href="/blog/tags/persistence/"> persistence </a> <a class="label" href="/blog/tags/alpha/"> alpha </a> <a class="label" href="/blog/tags/performance/"> performance </a> <a class="label" href="/blog/tags/6.0/"> 6.0 </a> <hr> <div class="post"></div> <h3> Tuesday, 02 July 2013 </h3> <h1> <a href="/blog/2013/07/02/lower-memory-overhead-in-infinispan/">Lower memory overhead in Infinispan 5.3.0.Final</a> </h1> <div class="content"> <div id="preamble"> <div class="sectionbody"> <div class="paragraph"> <p>Infinispan users worried about memory consumption should upgrade to <a href="http://infinispan.blogspot.cz/2013/06/infinispan-530final-is-out.html">Infinispan 5.3.0.Final</a> as soon as possible, because as part of the work we&#8217;ve done to <a href="https://docs.jboss.org/author/x/2oD2Aw">support storing byte arrays without wrappers</a>, and the development of the <a href="http://infinispan.blogspot.co.uk/2013/05/interoperability-between-embedded-and.html">interoperability mode</a>, we&#8217;ve been working to reduce Infinispan&#8217;s memory overhead.</p> </div> <div class="paragraph"> <p>To measure overhead, we&#8217;ve used <a href="http://infinispan.blogspot.cz/2013/01/infinispan-memory-overhead.html">Martin Gencur&#8217;s excellent memory consumption tests</a>. The results for entries with 512 bytes are:</p> </div> <div class="paragraph"> <p>Infinispan memory overhead, used in library mode: Infinispan 5.2.0.Final: ~151 bytes Infinispan 5.3.0.Final: ~135 bytes Memory consumption reduction: ~12%</p> </div> <div class="paragraph"> <p>Infinispan memory overhead, for the Hot Rod server: Infinispan 5.2.0.Final: ~174 bytes Infinispan 5.3.0.Final: ~151 bytes Memory consumption reduction: ~15%</p> </div> <div class="paragraph"> <p>Infinispan memory overhead, for the REST server: Infinispan 5.2.0.Final: ~208 bytes Infinispan 5.3.0.Final: ~172 bytes Memory consumption reduction: ~21%</p> </div> <div class="paragraph"> <p>Infinispan memory overhead, for the Memcached server:</p> </div> <div class="paragraph"> <p>Infinispan 5.2.0.Final: ~184 bytes</p> </div> <div class="paragraph"> <p>Infinispan 5.3.0.Final: ~180 bytes Memory consumption reduction: ~2%</p> </div> <div class="paragraph"> <p>This is great news for the Infinispan community but our effort doesn&#8217;t end here. We&#8217;ll be working on further improvements in next releases to bring down cost even further.</p> </div> <div class="paragraph"> <p>Cheers,</p> </div> <div class="paragraph"> <p>Galder</p> </div> </div> </div> </div> <a class="label" href="/blog/tags/overhead/"> overhead </a> <a class="label" href="/blog/tags/5.3/"> 5.3 </a> <a class="label" href="/blog/tags/memory/"> memory </a> <a class="label" href="/blog/tags/performance/"> performance </a> <hr> <div class="post"></div> <h3> Friday, 10 May 2013 </h3> <h1> <a href="/blog/2013/05/10/infinispan-vs-hazelcast-performance/">Infinispan vs Hazelcast Performance</a> </h1> <div class="content"> <div id="preamble"> <div class="sectionbody"> <div class="paragraph"> <p><a href="https://bitbucket.org/ssmoot">Sam Smoot</a> has recently compared the performance of Infinispan versus Hazelcast both with default cache settings and posted <a href="https://bitbucket.org/ssmoot/scala-map-benchmarks">some interesting performance results with Infinispan coming on top</a> :)</p> </div> <div class="paragraph"> <p>@Sam, we hear you and we&#8217;re working on reducing the number of JARs required for standalone, default use case :)</p> </div> <div class="paragraph"> <p>Cheers, Galder</p> </div> </div> </div> </div> <a class="label" href="/blog/tags/performance/"> performance </a> <hr> <div class="post"></div> <h3> Saturday, 12 January 2013 </h3> <h1> <a href="/blog/2013/01/12/infinispan-memory-overhead/">Infinispan memory overhead</a> </h1> <div class="content"> <div id="preamble"> <div class="sectionbody"> <div class="paragraph"> <p>Have you ever wondered how much Java heap memory is actually consumed when data is stored in Infinispan cache? Let&#8217;s look at some numbers obtained through real measurement.</p> </div> <div class="paragraph"> <p>The strategy was the following:</p> </div> <div class="paragraph"> <p>1) Start Infinispan server in local mode (only one server instance, eviction disabled) 2) Keep calling full garbage collection (via JMX or directly via System.gc() when Infinispan is deployed as a library) until the difference in consumed memory by the running server gets under 100kB between two consecutive runs of GC 3) Load the cache with <strong>100MB</strong> of data via respective client (or directly store in the cache when Infinispan is deployed as a library) 4) Keep calling the GC until the used memory is stabilised 5) Measure the difference between the final values of consumed memory after the first and second cycle of GC runs 6) Repeat steps 3, 4 and 5 four times to get an average value (first iteration ignored)</p> </div> <div class="paragraph"> <p>The amount of consumed memory was obtained from a verbose GC log (related JVM options: -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:/tmp/gc.log)</p> </div> <div class="paragraph"> <p>The test output looks like this: <a href="https://gist.github.com/4512589" class="bare">https://gist.github.com/4512589</a></p> </div> <div class="paragraph"> <p>The operating system (Ubuntu) as well as JVM (Oracle JDK 1.6) were 64-bit. Infinispan 5.2.0.Beta6. Keys were kept intentionally small (10 character Strings) with byte arrays as values. The target entry size is a sum of key size and value size.</p> </div> </div> </div> <div class="sect1"> <h2 id="_memory_overhead_of_infinispan_accessed_through_clients"><a class="anchor" href="#_memory_overhead_of_infinispan_accessed_through_clients"></a><strong>Memory overhead of Infinispan accessed through clients</strong></h2> <div class="sectionbody"> <div class="paragraph"> <p>==</p> </div> <div class="paragraph"> <p><strong>HotRod client</strong></p> </div> <div class="paragraph"> <p>entry size &#8594; overall memory</p> </div> <div class="paragraph"> <p>512B       &#8594; 137144kB</p> </div> <div class="paragraph"> <p>1kB        &#8594; 120184kB</p> </div> <div class="paragraph"> <p>10kB       &#8594; 104145kB</p> </div> <div class="paragraph"> <p>1MB        &#8594; 102424kB</p> </div> <div class="paragraph"> <p>So how much additional memory is consumed on top of each entry?</p> </div> <div class="paragraph"> <p>entry size/actual memory per entry &#8594; overhead per entry</p> </div> <div class="paragraph"> <p>512B/686B                &#8594; ~174B</p> </div> <div class="paragraph"> <p>1kB(1024B)/1202B         &#8594; ~178B</p> </div> <div class="paragraph"> <p>10kB(10240B)/10414B      &#8594; ~176B</p> </div> <div class="paragraph"> <p>1MB(1048576B)/1048821B   &#8594; ~245B</p> </div> <div class="paragraph"> <p><strong>MemCached client (text protocol, SpyMemcached client) </strong></p> </div> <div class="paragraph"> <p>entry size &#8594; overall memory</p> </div> <div class="paragraph"> <p>512B       &#8594; 139197kB</p> </div> <div class="paragraph"> <p>1kB        &#8594; 120517kB</p> </div> <div class="paragraph"> <p>10kB       &#8594; 104226kB</p> </div> <div class="paragraph"> <p>1MB        &#8594; N/A (SpyMemcached allows max. 20kB per entry)</p> </div> <div class="paragraph"> <p>entry size/actual memory per entry &#8594; overhead per entry</p> </div> <div class="paragraph"> <p>512B/696B               &#8594; ~184B</p> </div> <div class="paragraph"> <p>1kB(1024B)/1205B        &#8594; ~181B</p> </div> <div class="paragraph"> <p>10kB(10240B)/10422B     &#8594; ~182B</p> </div> <div class="paragraph"> <p>==</p> </div> <div class="paragraph"> <p><strong>REST client (Content-Type: application/octet-stream)</strong></p> </div> <div class="paragraph"> <p>entry size &#8594; overall memory</p> </div> <div class="paragraph"> <p>512B       &#8594; 143998kB</p> </div> <div class="paragraph"> <p>1kB        &#8594; 122909kB</p> </div> <div class="paragraph"> <p>10kB       &#8594; 104466kB</p> </div> <div class="paragraph"> <p>1MB        &#8594; 102412kB</p> </div> <div class="paragraph"> <p>entry size/actual memory per entry &#8594; overhead per entry</p> </div> <div class="paragraph"> <p>512B/720B               &#8594; ~208B</p> </div> <div class="paragraph"> <p>1kB(1024B)/1229B        &#8594; ~205B</p> </div> <div class="paragraph"> <p>10kB(10240B)/10446B     &#8594; ~206B</p> </div> <div class="paragraph"> <p>1MB(1048576B)/1048698B  &#8594; ~123B</p> </div> <div class="paragraph"> <p>The memory overhead for individual entries seems to be more or less constant across different cache entry sizes.</p> </div> </div> </div> <div class="sect1"> <h2 id="_memory_overhead_of_infinispan_deployed_as_a_library"><a class="anchor" href="#_memory_overhead_of_infinispan_deployed_as_a_library"></a>Memory overhead of Infinispan deployed as a library</h2> <div class="sectionbody"> <div class="paragraph"> <p>Infinispan was deployed to <a href="http://www.jboss.org/jbossas">JBoss Application Server 7</a> using <a href="http://arquillian.org/">Arquillian</a>.</p> </div> <div class="paragraph"> <p>entry size &#8594; overall memory/overall with storeAsBinary</p> </div> <div class="paragraph"> <p>512B       &#8594; 132736kB / 132733kB</p> </div> <div class="paragraph"> <p>1kB        &#8594; 117568kB / 117568kB</p> </div> <div class="paragraph"> <p>10kB       &#8594; 103953kB / 103950kB</p> </div> <div class="paragraph"> <p>1MB        &#8594; 102414kB / 102415kB</p> </div> <div class="paragraph"> <p>There was almost no difference in overall consumed memory when enabling or disabling storeAsBinary.</p> </div> <div class="paragraph"> <p>entry size/actual memory per entry&#8594; overhead per entry (w/o storeAsBinary)</p> </div> <div class="paragraph"> <p>512B/663B               &#8594; ~151B</p> </div> <div class="paragraph"> <p>1kB(1024B)/1175B        &#8594; ~151B</p> </div> <div class="paragraph"> <p>10kB(10240B)/10395B     &#8594; ~155B</p> </div> <div class="paragraph"> <p>1MB(1048576B)/1048719B  &#8594; ~143B</p> </div> <div class="paragraph"> <p>As you can see, the overhead per entry is constant across different entry sizes and is ~151 bytes.</p> </div> </div> </div> <div class="sect1"> <h2 id="_conclusion"><a class="anchor" href="#_conclusion"></a>Conclusion</h2> <div class="sectionbody"> <div class="paragraph"> <p>The memory overhead is slightly more than 150 bytes per entry when storing data into the cache locally. When accessing the cache via remote clients, the memory overhead is a little bit higher and ranges from ~170 to ~250 bytes, depending on remote client type and cache entry size. If we ignored the statistics for 1MB entries, which could be affected by a small number of entries (100) stored in the cache, the range would have been even narrower.</p> </div> <div class="paragraph"> <p>Cheers, Martin</p> </div> </div> </div> </div> <a class="label" href="/blog/tags/overhead/"> overhead </a> <a class="label" href="/blog/tags/memory/"> memory </a> <a class="label" href="/blog/tags/performance/"> performance </a> <hr> <div class="pagination-links"><span class="current-page">1</span> <a href="/blog/tags/performance/page/2/" class="page-link">2</a> <a href="/blog/tags/performance/page/2/" class="next-link">Next</a> </div> </div> <footer class="container"> <hr> <div class="row"> <div class="col-md-2 col-md-offset-1"> <h4>Navigate</h4> <ul> <li> <a href="/about" title="About">About</a> </li> <li> <a href="/documentation" title="Learn">Learn</a> </li> <li> <a href="/community" title="Community">Community</a> </li> <li> <a href="/getinvolved" title="Get Involved">Get Involved</a> </li> <li> <a href="/download" title="Download">Download</a> </li> </ul> </div> <div class="col-md-2"> <h4>Contribute</h4> <ul> <li> <a href="https://issues.jboss.org/browse/ISPN" title="Submit a bug">Submit a bug</a> </li> <li> <a href="https://github.com/infinispan" title="Write code">Write Code</a> </li> </ul> <h4>Follow Us</h4> <ul> <li> <a href="https://blog.infinispan.org" title="Blog">Blog</a> </li> <li> <a href="https://twitter.com/infinispan" title="Twitter">Twitter</a> </li> </ul> </div> <div class="col-md-2"> <h4>Open Source</h4> <p> Infinispan is released under the <b>Apache 2.0 open source license.</b> Learn more about the Apache 2.0 license <a href="https://www.apache.org/licenses/LICENSE-2.0">here.</a> </p> </div> <div class="col-md-2"> <h4>A member of</h4> <a alt="CloudTM" href="http://www.cloudtm.eu/" target="_NEW"> <img src="/images/cloudtm.png"> </a> <a alt="LEADS" href="http://leads-project.eu/" target="_NEW"> <img src="/images/leads.png"> </a> <a alt="CloudButton" href="http://cloudbutton.eu/" target="_NEW"> <img src="/images/cloudbutton.png"> </a> </div> <div class="col-md-2"> <h4>Thanks to</h4> <p>JetBrains Intellij IDEA</p> <a alt="JetBrains Intellij IDEA" href="https://www.jetbrains.com/idea/" target="_NEW"> <img src="/images/icon_IntelliJIDEA.png"> </a> </div> </div> <div class="col-md-10"> <p style="margin-top: 5px; font-size: 80%;"> © Copyright 2009-2019 Red Hat, Inc. <br> <i class="icon-fire"></i> Made with <a href="https://github.com/jbossorg/bootstrap-community" style="text-decoration: underline;" target="_NEW">JBoss Community Bootstrap</a> and <a href="http://awestruct.org/" style="text-decoration: underline;" target="_NEW">Awestruct</a> <br> <i class="icon-globe"></i> This website is open source! If you want to improve it, <a href="https://github.com/infinispan/infinispan.github.io" style="text-decoration: underline;" target="_NEW">fork the project,</a> and hack on it, then send a pull request. You can also view the <a href="https://www.seethestats.com/site/infinispan.org" style="text-decoration: underline;" target="_NEW">visitor stats.</a> <br> <i class="icon-share"></i> Website and documentation released under <a href="https://creativecommons.org/licenses/by/3.0/" style="text-decoration: underline;" target="_NEW">CC BY 3.0.</a> </p> </div> </footer> <div class="container" id="companyfooter"> <div class="redhatlogo"> <div id="logospacer"></div> <a href="http://www.redhat.com/"><img src="//static.jboss.org/theme/images/common/redhat_logo.png"></a> </div> </div> <span class="backToTop"> <a href="#top">back to top</a> </span> <script src="//static.jboss.org/theme/js/libs/bootstrap-community/3.2.0.2/bootstrap-community.min.js"></script> <script>
        if (("undefined" !== typeof _satellite) && ("function" === typeof _satellite.pageBottom)) {
          _satellite.pageBottom();
        }
      </script> </div> </body> </html>