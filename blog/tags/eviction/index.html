<!DOCTYPE html> <html lang="en"> <head> <title> Blog - Infinispan</title> <meta charset="utf-8"> <meta content="width=device-width, initial-scale=1.0" name="viewport"> <meta content="DENY" http-equiv="X-Frame-Options"> <meta content="1; mode=block" http-equiv="X-XSS-Protection"> <meta content="nosniff" http-equiv="X-Content-Type-Options"> <link href="https://static.jboss.org/theme/css/bootstrap-community/3.2.0.2/bootstrap-community.min.css" media="screen" rel="stylesheet"> <link crossorigin="anonymous" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" rel="stylesheet"> <script crossorigin="anonymous" src="https://kit.fontawesome.com/4167a38cfa.js"></script> <script id="dpal" src="https://www.redhat.com/dtm.js" type="text/javascript"></script> <link href="/images/favicon.png" rel="shortcut icon" type="image/png"> <link href="//static.jboss.org/images/example/apple-touch-icon-144x144-precomposed.png" rel="apple-touch-icon-precomposed" sizes="144x144"> <link href="//static.jboss.org/images/example/apple-touch-icon-114x114-precomposed.png" rel="apple-touch-icon-precomposed" sizes="114x114"> <link href="//static.jboss.org/images/example/apple-touch-icon-72x72-precomposed.png" rel="apple-touch-icon-precomposed" sizes="72x72"> <link href="//static.jboss.org/images/example/apple-touch-icon-precomposed.png" rel="apple-touch-icon-precomposed"> <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/github.min.css" rel="stylesheet"> <link href="https://static.jboss.org/css/rhbar.css" media="screen" rel="stylesheet"> <style>
      .jumbotron {
        padding: 0.5em 0.1em 0.5em 0.1em;
        background-image: none;
        background-color: #ffec9f;
      }
      .jumbotron p, 
      .jumbotron h1 {
        color: #656565;
      }
      .dropup {
        z-index: 1032;
      }
      .navbar {
        font-size: x-large;
      }
      .navbar ul {
        padding-top: 0.7em;
      }
      .navbar-brand {
        height: 80px;
      }
      .navbar-default {
        background-color: white;
      }
      .navbar-default .navbar-nav > li > a {
        color: #336699;
      }
      .navbar-default .navbar-nav > li > a:hover {
        color: #204060;
      }
      .navbar-default .navbar-nav > .open > a,
      .navbar-default .navbar-nav > .open > a:hover,
      .navbar-default .navbar-nav > .open > a:focus {
        background-color: #4a5d75;
      }
      h3.well {
        border-color: #ffd630;
        background-color: #ffec9f;
      }
      .panel-sidebar {
        border-color: #f5f5f5;
      }
      .panel-sidebar > .panel-heading {
        border-color: #e3e3e3;
        background-color: #f5f5f5;
        color: #656565;
      }
      .btn-primary {
        border-color: #ffd630;
        background-color: #ffec9f;
        color: #656565;
      }
      footer.container {
        background-color: white;
      }
      footer.container h1, footer.container h2, footer.container h3, footer.container h4, footer.container h5, footer.container h6, footer.container p, footer.container a {
        color: #656565;
      }
      footer.container ul {
        padding: 0;
      }
      i.enormous-icon {
        margin-top: 0.3em;
      }
      .home-examples {
        font-size: 16px;
      }
    </style> <script src="//static.jboss.org/theme/js/libs/jquery/jquery-1.9.1.min.js"></script> <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.7/highlight.min.js"></script> <script>
      hljs.initHighlightingOnLoad();
    </script> <script>
     (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
     
    ga('create', 'UA-8601422-1', 'auto');
    ga('send', 'pageview');
    
    </script> </head> <body> <div id=""> <ul class="visuallyhidden" id="top"> <li> <a accesskey="n" href="#nav" title="Skip to navigation">Skip to navigation</a> </li> <li> <a accesskey="c" href="#page" title="Skip to content">Skip to content</a> </li> </ul> <div id="rhbar"> <a class="jbdevlogo" href="http://www.jboss.org/projects/about"></a> <a class="rhlogo" href="http://www.redhat.com/"></a> </div> <div class="container" id="content"> <nav class="navbar navbar-default navbar-fixed-top"> <div class="container"> <div class="navbar-header"> <button aria-expanded="false" class="navbar-toggle collapsed" data-target="#thenavbar" data-toggle="collapse"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> <a class="navbar-brand" href="/"> <img alt="Infinispan" src="/images/infinispan_nav_brand.png"> </a> </div> <div class="navbar-collapse collapse" id="thenavbar"> <ul class="nav navbar-nav"> <li class="dropdown"> <a class="dropdown-toggle" data-toggle="dropdown" href="/about">About <b class="caret"></b></a> <ul class="dropdown-menu"> <li><a href="/about">Introduction</a></li> <li><a href="/features">Features</a></li> <li><a href="/release-notes">Release notes</a></li> <li><a href="/blog">Blog</a></li> <li><a href="/references">References</a></li> <li><a href="/experiments/">Experiments</a></li> </ul> </li> <li class="dropdown"> <a class="dropdown-toggle" data-toggle="dropdown" href="/documentation">Learn <b class="caret"></b></a> <ul class="dropdown-menu"> <li><a href="/documentation">Documentation</a></li> <li><a href="/tutorials">Tutorials</a></li> <li><a href="/videos">Videos</a></li> </ul> </li> <li class="dropdown"> <a class="dropdown-toggle" data-toggle="dropdown" href="/download">Download <b class="caret"></b></a> <ul class="dropdown-menu"> <li><a href="/download">Infinispan Releases</a></li> <li><a href="/cache-store-implementations">Cache Store Implementations</a></li> <li><a href="/hotrod-clients">Hot Rod Clients</a></li> <li><a href="/integrations">Integrations</a></li> <li><a href="/download-archive">Archive</a></li> </ul> </li> <li class="dropdown"> <a class="dropdown-toggle" data-toggle="dropdown" href="/community">Community <b class="caret"></b></a> <ul class="dropdown-menu"> <li><a href="/community">Ask for Help</a></li> <li><a href="/getinvolved">Get Involved</a></li> </ul> </li> <li class=""><a href="/roadmap">Road Map</a></li> <li class="divider"></li> </ul> </div> </div> </nav> <div class="post"></div> <h3> Wednesday, 07 February 2018 </h3> <h1> <a href="/blog/2018/02/07/data-container-changes-part-3/">Data Container Changes Part 3</a> </h1> <div class="content"> <div id="preamble"> <div class="sectionbody"> <div class="paragraph"> <p>Just over a year ago we detailed some improvements to the data container, including the availability of Off Heap storage in <a href="http://blog.infinispan.org/2017/01/data-container-changes-part-2.html">part 2</a>. There have been quite a <a href="https://issues.jboss.org/browse/ISPN-8454?jql=project%20%3D%20ISPN%20AND%20resolution%20%3D%20Done%20AND%20component%20%3D%20%22Off%20Heap%22">few fixes</a> for Off Heap especially around memory size estimations with Infinispan 9.2. There is also a brand new "eviction" strategy that has a bit of a twist.</p> </div> </div> </div> <div class="sect1"> <h2 id="_eviction_strategy_resurrected"><a class="anchor" href="#_eviction_strategy_resurrected"></a>Eviction Strategy Resurrected</h2> <div class="sectionbody"> <div class="paragraph"> <p>Some of you may have remembered that Infinispan used to have an eviction strategy. This was originally used to decide what eviction algorithm was used, such as LRU or LIRS. This was removed when the new data container was introduced. Well&#8230;&#8203; it is back again, but it will be used for a slightly different purpose.</p> </div> <div class="paragraph"> <p>The eviction strategy still has <strong>NONE</strong> &amp; <strong>MANUAL</strong> which are exactly the same as before.</p> </div> <div class="sect2"> <h3 id="_remove_strategy"><a class="anchor" href="#_remove_strategy"></a>Remove strategy</h3> <div class="paragraph"> <p>There is a new <strong>REMOVE</strong> strategy that is configured by default if eviction size is greater than 0. This strategy essentially enables eviction and removes old entries as new ones are inserted.</p> </div> </div> <div class="sect2"> <h3 id="_exception_strategy"><a class="anchor" href="#_exception_strategy"></a>Exception strategy</h3> <div class="paragraph"> <p>We have a brand new "eviction" strategy that provides new functionality. It is unique in that it doesn&#8217;t really evict, but rather prevent entries from being inserted.Â  This is the <strong>EXCEPTION</strong> strategy which blocks new entries from being inserted (or updated if they exceed memory size) by throwing a ContainerFullException when the size is reached.</p> </div> <div class="paragraph"> <p>This strategy only works on transactional caches that always have 2 phase commit enabled. This can be useful if you want to always have only so many entries and to give priority to currently inserted entries. This strategy has better performance than <strong>REMOVE</strong> since it doesn&#8217;t have to bookkeep all entries to know what to remove as well.</p> </div> <div class="paragraph"> <p>Note this strategy works across all storage types: OBJECT, BINARY and OFFHEAP and works with both MEMORY and SIZE based "eviction types. This makes it just as flexible as the <strong>REMOVE</strong> eviction strategy and hope it finds some uses by people.</p> </div> </div> <div class="sect2"> <h3 id="_how_to_configure_exception_strategy"><a class="anchor" href="#_how_to_configure_exception_strategy"></a>How to Configure EXCEPTION Strategy</h3> <div class="paragraph"> <p>This is how you can enable MEMORY based EXCEPTION "eviction" using xml configuration.</p> </div> <div class="paragraph"> <p>This is how you configure the same thing but programmatically.</p> </div> </div> </div> </div> <div class="sect1"> <h2 id="_off_heap_memory_size_allocations_estimations"><a class="anchor" href="#_off_heap_memory_size_allocations_estimations"></a>Off Heap Memory Size Allocations &amp; Estimations</h2> <div class="sectionbody"> <div class="paragraph"> <p>Before the off heap memory based eviction only counted the allocated memory chunks for the stored entries themselves. This unfortunately meant that the size estimate is a bit less than what it should have been. There are a few things that we improved since then, including reducing the overhead of our allocations. Note all of the below things require no configuration changes and users should just get the benefits.</p> </div> <div class="sect2"> <h3 id="_reduced_per_object_overhead"><a class="anchor" href="#_reduced_per_object_overhead"></a>Reduced per object overhead</h3> <div class="paragraph"> <p>Prior the overhead for immutable entries with eviction, Infinispan itself use to allocate 2 chunks of memory with one being 28 bytes and adding 8 bytes to the actual object. Now we only allocate an additional 16 bytes to the object memory block itself (saving the extra allocation and requiring less on the object) when using eviction. Due to memory allocation overhead this saves much more than the 20 bytes as the allocator also has its own overhead.</p> </div> <div class="paragraph"> <p>We also shaved off 4 bytes off of all entries if expiration was not used, meaning overhead for an immutable cache entry without eviction only requires 21 bytes of overhead from ISPN when using off heap (retained in the same allocation block).</p> </div> </div> <div class="sect2"> <h3 id="_per_allocation_memory_sizing_estimations"><a class="anchor" href="#_per_allocation_memory_sizing_estimations"></a>Per allocation memory sizing estimations</h3> <div class="paragraph"> <p>Internally ISPN allocates a new chunk of memory for each object. This is done currently to leverage the underlying OS allocator to handle features such as fragmentation or compaction (if the allocator does so). Unfortunately this means that each object has its own overhead from the allocator. Thus we now take that into account when estimating the memory used by adding 8 bytes overhead and aligning to 16 bytes. This seems to be a pretty common way for allocators to work. If possible we could allow for tweaking these values, but they are hard coded currently.</p> </div> </div> <div class="sect2"> <h3 id="_accounting_for_address_count"><a class="anchor" href="#_accounting_for_address_count"></a>Accounting for Address Count</h3> <div class="paragraph"> <p>As was mentioned in the prior blog post about off heap, we allocate a single block of memory to hold address counters for our lookups when using Off Heap. Unfortunately we didn&#8217;t account for that in the memory eviction count. We now account for that in the eviction mechanism, thus your memory eviction size must be greater than the address count rounded up to the nearest power of 2, multiplied by 8. What a mouthful&#8230;&#8203;</p> </div> </div> <div class="sect2"> <h3 id="_wrap_up"><a class="anchor" href="#_wrap_up"></a>Wrap up</h3> <div class="paragraph"> <p>Off heap has been overhauled quite a bit to try to reduce memory usage, fix bugs and more accurately estimate the memory used. We hope that along with the new eviction strategy are welcome additions to various applications.</p> </div> <div class="paragraph"> <p>Please make sure to contact us if you have any feedback, find any bugs or have any questions! You can get in contact with various places listed on our <a href="http://infinispan.org/community/">website</a>.</p> </div> </div> </div> </div> </div> <hr> <div class="post"></div> <h3> Friday, 25 September 2015 </h3> <h1> <a href="/blog/2015/09/25/memory-based-eviction/">Memory based eviction</a> </h1> <div class="content"> <div class="sect1"> <h2 id="_eviction_today"><a class="anchor" href="#_eviction_today"></a>Eviction Today</h2> <div class="sectionbody"> <div class="paragraph"> <p>Infinispan since its inception has supported a way to help users control how much memory the in memory cache entries consume in the JVM.Â  This has always been limited to a number of entries.Â  In the past users have had to estimate the average amount of bytes their entries used on the heap.Â  With this average you can easily calculate how many entries could safely be stored in memory without running into issues.Â  For users who have keys and values that are relatively similar this can work well.Â  However when the case requires entries that vary in size this can be problematic and you end up calculating the average size based on the worse case.</p> </div> </div> </div> <div class="sect1"> <h2 id="_enter_memory_based_eviction"><a class="anchor" href="#_enter_memory_based_eviction"></a>Enter Memory Based Eviction</h2> <div class="sectionbody"> <div class="paragraph"> <p>Infinispan 8 introduces memory based eviction counting.Â  That is Infinispan will automatically keep track of how large the key, value and overhead if possible.Â  It can use these values then to try to limit the number of entries instead to a memory count such as 1 Gigabyte.</p> </div> <div class="sect2"> <h3 id="_keyvalue_limitations"><a class="anchor" href="#_keyvalue_limitations"></a>Key/Value limitations</h3> <div class="paragraph"> <p>Unfortunately this is currently limited to only using keys and values stored as primitives, primitive wrappers (ie. Integer), java.lang.String(s) and any of the previously mentioned stored in an array.Â  This means this feature cannot be used with any custom classes.Â  If enough feedback is provided we could provide a SPI to allow the user to plug in their own counter for their own classes, but this is not planned currently.</p> </div> <div class="paragraph"> <p>There are a couple ways to easily get around this.Â  One is to use <a href="http://infinispan.org/docs/8.0.x/user_guide/user_guide.html#_store_as_binary">storeAsBinary</a>, which will store your keys and/or values as byte arrays for you automatically, satisfying this limitation.Â  A second way is when you are using the client such as HotRod, in this case the data is stored in the serialized (byte[]) form.Â  Note that <a href="http://infinispan.org/docs/8.0.x/user_guide/user_guide.html#_enable_compatibility_mode">compatibility mode</a> will prevent this from occurring and you are unable to use these configurations together.</p> </div> </div> <div class="sect2"> <h3 id="_eviction_type_limitation"><a class="anchor" href="#_eviction_type_limitation"></a>Eviction Type limitation</h3> <div class="paragraph"> <p>Due to the complexity of LIRS, memory based eviction is only supported with LRU at this time. See the types <a href="http://infinispan.org/docs/8.0.x/user_guide/user_guide.html#_eviction_strategies">here</a>.Â  This could be enhanced at a later point, but is also not planned.</p> </div> </div> </div> </div> <div class="sect1"> <h2 id="_how_to_enable"><a class="anchor" href="#_how_to_enable"></a>How to enable</h2> <div class="sectionbody"> <div class="paragraph"> <p>You can enable memory based eviction either through programmatic or declarative configuration.Â  Note that Infinispan added long support (limited to 2^48) for the size value which directly helps memory based eviction if users want to utilize caches larger than 2 GB.</p> </div> <div class="sect2"> <h3 id="_programmatic"><a class="anchor" href="#_programmatic"></a>Programmatic</h3> </div> <div class="sect2"> <h3 id="_declarative"><a class="anchor" href="#_declarative"></a>DeclarativeÂ </h3> <div class="paragraph"> <p>==</p> </div> </div> </div> </div> <div class="sect1"> <h2 id="_supported_jvms"><a class="anchor" href="#_supported_jvms"></a>Supported JVMs</h2> <div class="sectionbody"> <div class="paragraph"> <p>This was tested and written specifically for Oracle and OpenJDK JVMs.Â  In testing these JVMs showed memory accuracy within 1% of desired value. Other JVMs may shown incorrect values.</p> </div> <div class="paragraph"> <p>The algorithm takes into account JVM options, such as compressed pointers and 32 bit JVM vs 64 bit JVM.Â  Keep in mind this is only for the data container and doesn&#8217;t take into account additional overhead such as created threads or other runtime objects.</p> </div> <div class="paragraph"> <p>Other JVMs are not handled such as the IBM JVM which was briefly tested and showed incorrect numbers greater than 10% of the desired amount.Â  Support for other JVMs can be added later as interest is shown for them.</p> </div> </div> </div> <div class="sect1"> <h2 id="_closing_notes"><a class="anchor" href="#_closing_notes"></a>Closing Notes</h2> <div class="sectionbody"> <div class="paragraph"> <p>I hope this feature helps people to better handle their memory constraints while using Infinispan!Â  Let us know if you have any <a href="http://infinispan.org/getinvolved/">feedback or concerns</a>.</p> </div> <div class="paragraph"> <p>Cheers!</p> </div> <div class="paragraph"> <p>Â - Will</p> </div> </div> </div> </div> <hr> <div class="post"></div> <h3> Thursday, 19 March 2015 </h3> <h1> <a href="/blog/2015/03/19/eviction-improvements-in-infinispan/">Eviction Improvements in Infinispan 7.2.0.Beta1</a> </h1> <div class="content"> <div id="preamble"> <div class="sectionbody"> <div class="paragraph"> <p>As many of you are most likely aware Infinispan provides a way to limit how many entries are stored in a single node&#8217;s memory at a given time.Â  This is configurable via the eviction element in xml or EvictionConfiguraitonBuilder through the programmatic configuration.</p> </div> <div class="paragraph"> <p>In 7.2.0.Beta1 we have made some internal changes to our internal eviction support.Â  This mostly entailed moving our implementation to the new <a href="https://issues.jboss.org/browse/ISPN-3023">ConcurrentHashMap that was updated for Java 8</a>.Â  This provides for a few new benefits and behaviors.</p> </div> </div> </div> <div class="sect1"> <h2 id="_long_size_support"><a class="anchor" href="#_long_size_support"></a>Long Size Support</h2> <div class="sectionbody"> <div class="paragraph"> <p>Previously our eviction entry amount was limited to the maximum value of an int (2^31) and was always rounded up to the nearest power of 2 (ie. 100 would be changed to 128 which is 2^7).</p> </div> <div class="paragraph"> <p>With the new changes you can store up to a long worth of entries and it is not constrained to a power of 2.Â  Unfortunately Beta1 does not contain the changes to allow for a long to be configured yet, but this should be <a href="https://issues.jboss.org/browse/ISPN-5306">fixed</a> before 7.2.0.Final is done.</p> </div> </div> </div> <div class="sect1"> <h2 id="_memory_wide_eviction_size"><a class="anchor" href="#_memory_wide_eviction_size"></a>Memory wide eviction size</h2> <div class="sectionbody"> <div class="paragraph"> <p>The old bounded map performed it&#8217;s eviction based on evicting elements stored in the same segment.Â  This could cause the map to evict entries before it actually hit the maximum size.Â  This is described in detail <a href="http://infinispan.org/docs/7.1.x/faqs/faqs.html#_cache_s_number_of_entries_never_reaches_configured_maxentries_why_is_that">here</a>.</p> </div> <div class="paragraph"> <p>The new ConcurrentHashMap for Java 8 automatically resizes its number of segments.Â  As such the old method of eviction will not work.Â  Instead we keep track of all entries in the entire map and only evict when we go over the max size.Â  This prevents entries from being evicted that may not be the the least recent (previously in the case of when many elements in the same segment were added).</p> </div> </div> </div> <div class="sect1"> <h2 id="_better_scalability"><a class="anchor" href="#_better_scalability"></a>Better scalability</h2> <div class="sectionbody"> <div class="paragraph"> <p>Since we utilize the new ConcurrentHashMap this automatically resizes the segments based on the amount of entries in the cache.Â  Increasing the number of segments has some various benefits.</p> </div> <div class="sect2"> <h3 id="_less_blocking"><a class="anchor" href="#_less_blocking"></a><strong>Less blocking</strong></h3> <div class="paragraph"> <p>With more segments, that means there is more fine grained locking when updating an entry.Â  The determination whether an entry needs evicting is done outside of any lock, further reducing contention.</p> </div> </div> <div class="sect2"> <h3 id="_lower_time_complexity"><a class="anchor" href="#_lower_time_complexity"></a>Lower time complexity</h3> <div class="paragraph"> <p>Since there are more segments there should be fewer hash collisions, which should provide O(1) complexity much more frequently for accessing a given key.</p> </div> <div class="paragraph"> <p>Cheers,</p> </div> <div class="paragraph"> <p>Will</p> </div> </div> </div> </div> </div> <hr> <div class="post"></div> <h3> Tuesday, 17 March 2015 </h3> <h1> <a href="/blog/2015/03/17/infinispan-720beta1-released/">Infinispan 7.2.0.Beta1 released</a> </h1> <div class="content"> <div id="preamble"> <div class="sectionbody"> <div class="paragraph"> <p>Dear Infinispan community,</p> </div> <div class="paragraph"> <p>We are proud to announce the release of Infinispan <a href="http://infinispan.org/download/">7.2.0.Beta1</a> today.</p> </div> <div class="paragraph"> <p>Along the usual assortment of bug fixes, this release includes a few exciting new features:</p> </div> <div class="ulist"> <ul> <li> <p>Server-side scripting with JSR-223 (<a href="https://issues.jboss.org/browse/ISPN-5013">ISPN-5013</a>)</p> </li> <li> <p>Initial support for the JCache API over HotRod (<a href="https://issues.jboss.org/browse/ISPN-4955">ISPN-4955</a>)</p> </li> <li> <p>Improved size-based eviction, implemented on top of Doug Lea&#8217;s ConcurrentHashMapV8 (<a href="https://issues.jboss.org/browse/ISPN-3023">ISPN-3023</a>)</p> </li> </ul> </div> <div class="paragraph"> <p>For a complete list of features and bug fixes included in this release, please refer to the <a href="https://issues.jboss.org/secure/ReleaseNote.jspa?projectId=12310799&amp;version=12326574">release notes</a>. Â </p> </div> <div class="paragraph"> <p>Feel free to join us and shape the future releases on our <a href="http://www.jboss.org/infinispan/forums">forums</a>, our <a href="https://lists.jboss.org/mailman/listinfo/infinispan-dev">mailing lists</a> or our <a href="http://webchat.freenode.net/?channels=%23infinispan">#infinispan</a> IRC channel.</p> </div> <div class="paragraph"> <p>Many thanks to everyone who contributed to this release!</p> </div> </div> </div> </div> <hr> <div class="post"></div> <h3> Tuesday, 30 March 2010 </h3> <h1> <a href="/blog/2010/03/30/infinispan-eviction-batching-updates/">Infinispan eviction, batching updates and LIRS</a> </h1> <div class="content"> <div id="preamble"> <div class="sectionbody"> <div class="paragraph"> <p>DataContainer abstraction represents the heart of Infinispan. It is a container structure where actual cache data resides. Every put, remove, get and other invoked cache operations eventually end up in the data container. Therefore, it is of utmost importance the data container is implemented in a way that does not impede overall system throughput. Also recall that the data container&#8217;s memory footprint can not grow indefinitely because we would eventually run out of memory; we have to periodically evict certain entries from the data container according to a chosen eviction algorithm.</p> </div> <div class="paragraph"> <p>LRU eviction algorithm, although simple and easy to understand, under performs in cases of weak access locality (one time access entries are not timely replaced, entries to be accessed soonest are unfortunately replaced, and so on). Recently, a new eviction algorithm - <a href="http://portal.acm.org/citation.cfm?id=511334.511340">LIRS</a> has gathered a lot of attention because it addresses weak access locality shortcomings of LRU yet it retains LRU&#8217;s simplicity.</p> </div> <div class="paragraph"> <p>However, no matter what eviction algorithm is utilized, if eviction is not implemented in a scalable, low lock contention approach, it can seriously degrade overall system performance. In order to do any meaningful selection of entries for eviction we have to lock data container until appropriate eviction entries are selected. Having such a lock protected data container in turn causes high lock contention offsetting any eviction precision gained by sophisticated eviction algorithms. In order to get superior throughput while retaining high eviction precision we need both low lock contention data container and high precision eviction algorithm implementation â a seemingly impossible feat.</p> </div> <div class="paragraph"> <p>Instead of making a trade-off between the high precision eviction algorithm and the low lock contention there is <a href="http://portal.acm.org/citation.cfm?id=1546683.1547428">a third approach</a>: we keep lock protected data container but we amortize locking cost through batching updates. The basic idea is to wrap any eviction algorithm with a framework that keeps track of cache access per thread (i.e. ThreadLocal) in a simple queue. For each cache hit associated with a thread, the access is recorded in the threadâs queue. If thread&#8217;s queue is full or the number of accesses recorded in the queue reaches a certain pre-determined threshold, we acquire a lock and then execute operations defined by the eviction algorithm - once for all the accesses in the queue. A thread is allowed to access many cache items without requesting a lock to run the eviction replacement algorithm, or without paying the lock acquisition cost. We fully exploit a non-blocking lock APIs like tryLock. As you recall tryLock makes an attempt to get the lock and if the lock is currently held by another thread, it fails without blocking its caller thread. Although tryLock is cheap it is not used for every cache access for obvious reasons but rather on certain pre-determined thresholds. In case when thread&#8217;s queue is totally full a lock must be explicitly requested. Therefore, using batching updates approach we significantly lower the cost of lock contention, streamline access to locked structures and retain the precision of eviction algorithm such as LIRS. The key insight is that batching the updates on the eviction algorithm doesn&#8217;t materially affect the accuracy of the algorithm.</p> </div> <div class="paragraph"> <p>How are these ideas implemented in Infinispan? We introduced BoundedConcurrentHashMap class based on Doug Lea&#8217;s ConcurrentHashMap. BoundedConcurrentHashMap hashes entries based on their keys into lock protected segments. Instead of recording entries accessed per thread we record them in a lock free queue on a segment level. The main reason not to use ThreadLocal is that we could potentially have hundreds of threads hitting the data container, some of them very short lived thus possibly never reaching batching thresholds. When predetermined thresholds are reached eviction algorithms is executed on a segment level. Would running eviction algorithm on a segment level rather than entire data container impact overall eviction precision? In our performance tests we have not found any evidence of that.</p> </div> <div class="paragraph"> <p>Infinispan&#8217;s eviction algorithm is specified using strategy attribute of eviction XML element. In addition to old eviction approaches, starting with release 4.1.ALPHA2, you can now select LIRS eviction algorithm. LRU remains the default. Also note that starting with 4.1ALPHA2 release there are two distinct approaches to actually evict entries from the cache: piggyback and the default approach using a dedicated EvictionManager thread. Piggyback eviction thread policy, as it name implies, does eviction by piggybacking on user threads that are hitting the data container. Dedicated EvictionManager thread is unchanged from the previous release and it remains the default option. In order to support these two eviction thread policies a new eviction attribute threadPolicy has been added to eviction element of Infinispan configuration schema.</p> </div> <div class="paragraph"> <p>Does eviction redesign based on batching updates promise to live up to its expectations? Ding et al, authors of the original batching proposal, found that their framework increased throughput nearly twofold in comparison with unmodified eviction in postgreSQL 8.2.3. We do not have any numbers to share yet, however, initial testing of BoundedConcurrentHashMap were indeed promising. One of our partner companies replaced their crucial caching component with BoundedConcurrentHashMap and realized a 54% performance improvement on the Berlin SPARQL benchmark for their flagship product. Stay tuned for more updates.</p> </div> <div class="paragraph"> <p>Cheers,</p> </div> <div class="paragraph"> <p>Vladimir</p> </div> </div> </div> </div> <hr> <div class="post"></div> <h3> Tuesday, 20 October 2009 </h3> <h1> <a href="/blog/2009/10/20/infinispan-based-hibernate-cache/">Infinispan based Hibernate Cache Provider available now!</a> </h1> <div class="content"> <div id="preamble"> <div class="sectionbody"> <div class="paragraph"> <p>Update (2009/11/13)! Infinispan 4.0.0.Beta2 based Hibernate second level cache provider <a href="http://in.relation.to/12696.lace">now available in Hibernate 3.5 Beta2</a>. However, neither Infinispan 4.0.0.Beta2 nor the Infinispan Cache Provider jar are available in the zip distribution. Instead, please download Infinispan 4.0.0.Beta2 from <a href="http://sourceforge.net/projects/infinispan/files/">our download site</a> and the Infinispan Cache Provider <a href="http://repository.jboss.org/maven2/org/hibernate/hibernate-infinispan/3.5.0-Beta-2/">from our Maven repository</a>.</p> </div> <div class="paragraph"> <p>I&#8217;ve just finished the development of an Infinispan 4.0 based Hibernate second level cache provider. This will be included from next Hibernate 3.5 release onwards but if you cannot wait and wanna play with it in the mean time, just checkout <a href="http://anonsvn.jboss.org/repos/hibernate/core/trunk/">Hibernate trunk from our SVN repository</a> and run 'mvn install'.</p> </div> <div class="paragraph"> <p>I&#8217;ve also written <a href="http://www.jboss.org/community/docs/DOC-14105">a wiki called "Using Infinispan as JPA/Hibernate Second Level Cache Provider" </a> that should help users understand how to configure the Infinispan cache provider and how to make the most of it!</p> </div> <div class="paragraph"> <p>So, what&#8217;s good about it? Why should I use it? First of all, since the cache provider is based on Infinispan, you benefit from all the improvements we&#8217;ve done to Infinispan in terms of performance and memory consumption so far and there are more to come!</p> </div> <div class="paragraph"> <p>On top of that, starting with this cache provider, we&#8217;re aiming to reduce the number of files needed to modify in order to define the most commonly tweaked parameters. So, for example, by enabling eviction/expiration configuration on a per generic Hibernate data type or particular entity/collection type via hibernate.cfg.xml or persistence.xml, users don&#8217;t have to touch to Infinispan&#8217;s cache configuration file any more. You can find detailed information on how to do this in the <a href="http://www.jboss.org/community/docs/DOC-14105">"Using Infinispan as JPA/Hibernate Second Level Cache Provider" wiki</a></p> </div> <div class="paragraph"> <p>Please direct any feedback to the <a href="http://www.jboss.org/index.html?module=bb&amp;op=viewforum&amp;f=309">Infinispan user forum</a>.</p> </div> <div class="paragraph"> <p>Galder</p> </div> </div> </div> </div> <hr> <div class="post"></div> <h3> Tuesday, 12 May 2009 </h3> <h1> <a href="/blog/2009/05/12/implementing-performant-thread-safe/">Implementing a performant, thread-safe ordered data container</a> </h1> <div class="content"> <div id="preamble"> <div class="sectionbody"> <div class="paragraph"> <p>To achieve efficient ordering of entries in the <a href="http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/container/DataContainer.html">DataContainer</a> interface for configurations that support eviction, there was a need for a linked HashMap implementation that was thread-safe and performant. Below, I specifically discuss the implementations of the <a href="http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/container/FIFODataContainer.html">FIFODataContainer</a> and <a href="http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/container/LRUDataContainer.html">LRUDataContainer</a> in Infinispan 4.0.x. Wherever this document references <a href="http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/container/FIFODataContainer.html">FIFODataContainer</a>, this also applies to <a href="http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/container/LRUDataContainer.html">LRUDataContainer</a> - which extends <a href="http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/container/FIFODataContainer.html">FIFODataContainer</a>. The only difference is that <a href="http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/container/LRUDataContainer.html">LRUDataContainer</a> updates links whenever an entry is visited as well as added.</p> </div> <div class="paragraph"> <p>After analysing and considering a few different approaches, the one I settled on is a subset of the algorithms described by H. Sundell and P. Tsigas in their 2008 paper titled <a href="http://www.md.chalmers.se/%7Etsigas/papers/Lock-Free-Deques-Doubly-Lists-JPDC.pdf">Lock-Free Deques and Doubly Linked Lists</a>, combined with the approach used by Sun&#8217;s JDK6 for reference marking in <a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/ConcurrentSkipListMap.html">ConcurrentSkipListMap</a>'s implementation.</p> </div> <div class="paragraph"> <p>Reference marking? What&#8217;s that?</p> </div> <div class="paragraph"> <p>Compare-and-swap (CAS) is a common technique today for atomically updating a variable or a reference without the use of a mutual exclusion mechanism like a lock. But this only works when you modify a single memory location at a time, be it a reference or a primitive. Sometimes you need to atomically update two separate bits of information in a single go, such as a reference, as well as some information about that reference. Hence reference marking. In C, this is sometimes done by making use of the assumption that an entire word in memory is not needed to store a pointer to another memory location, and some bits of this word can be used to store additional flags via bitmasking. This allows for atomic updates of both the reference and this extra information using a single CAS operation.</p> </div> <div class="paragraph"> <p>This is possible in Java too using <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/atomic/AtomicMarkableReference.html">AtomicMarkableReference</a>, but is usually considered overly complex, slow and space-inefficient. Instead, what we do is borrow a technique from <a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/ConcurrentSkipListMap.html">ConcurrentSkipListMap</a> and use an intermediate, delegating entry. While this adds a little more complexity in traversal (you need to be aware of the presence of these marker entries when traversing the linked list), this performs better than an <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/atomic/AtomicMarkableReference.html">AtomicMarkableReference</a>.</p> </div> <div class="paragraph"> <p>In this specific implementation, the 'extra information' stored in a reference is the fact that the entry holding the reference is in the process of being deleted. It is a common problem with lock-free linked lists when you have concurrent insert and delete operations that the newly inserted entry gets deleted as well, since it attaches itself to the entry being concurrently deleted. When the entry to be removed marks its references, however, this makes other threads aware of the fact and cause CAS operations on the reference to fail and retry.</p> </div> <div class="paragraph"> <p>Performance</p> </div> <div class="paragraph"> <p>Aside from maintaining order of entries and being thread-safe, performance was one of the other goals. The target is to achieve constant-time performance - O(1) - for all operations on <a href="http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/container/DataContainer.html">DataContainer</a>.</p> </div> <div class="paragraph"> <p>The clhttp://3.bp.blogspot.com/_ca0W9t-Ryos/SgGwA2iw_vI/AAAAAAAAAKA/TpVMWo2Rq9U/s1600-h/FIFODataContainer.jpeg[<span class="image"><img src="http://3.bp.blogspot.com/_ca0W9t-Ryos/SgGwA2iw_vI/AAAAAAAAAKA/TpVMWo2Rq9U/s400/FIFODataContainer.jpeg" alt="image"></span>]ass diagram (click to view in full-size) depicts the <a href="http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/container/FIFODataContainer.html">FIFODataContainer</a> class. At its heart the <a href="http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/container/FIFODataContainer.html">FIFODataContainer</a> mimics a JDK <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ConcurrentHashMap.html">ConcurrentHashMap</a> (CHM), making use of hashtable-like lockable segments. Unlike the segments in CHM, however, these segments are simpler as they support a much smaller set of operations.</p> </div> <div class="paragraph"> <p>Retrieving data from the container The use of segments allow for constant-time thread-safe get() and containsKey() operations. Iterators obtained from the <a href="http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/container/DataContainer.html">DataContainer</a> - which implements Iterable, and hence usable in for-each loops - and keySet() are immutable, thread-safe and efficient, using traversal of the linked list - making use of getNext() and getPrev() helpers. See below for details. Traversal is efficient and constant-time.</p> </div> <div class="paragraph"> <p>Updating the container When removing an entry, remove() locks the segment in question, removes the entry, and unlinks the entry. Both operations are thread-safe and constant-time. Locking the segment and removing the entry is pretty straightforward. Unlinking involves marking references, and then an attempt at CAS&#8217;ing next and previous references to bypass the removed entry. Order here is important - updates to the next reference needs to happen first, read on for more details as to why.</p> </div> <div class="paragraph"> <p>When performing a put(), the entry is created, segment locked and entry inserted into the segment. The entry is then inserted at the tail of the linked list. Again, both operations are thread-safe and constant-time. Linking at the tail involves careful CAS&#8217;ing of references on the new entry, the tail dummy entry and the former last entry in the list.</p> </div> <div class="paragraph"> <p>Maintaining a lock-free, concurrent doubly linked list It is important to note that the entries in this implementation are doubly linked. This is critical since, unlike the JDK&#8217;s <a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/ConcurrentSkipListMap.html">ConcurrentSkipListMap</a>, we use a hashtable to look up entries to be removed, to achieve constant time performance in lookup. Locating the parent entry to update a reference needs to be constant-time as well, and hence the need for a previous reference. Doubly-linked lists make things much trickier though, as there two references to update atomically (yes, that sounds wrong!)</p> </div> <div class="paragraph"> <p>Crucially, what we do not care about - and do not support - is reverse-order traversal. This means that we only really care about maintaining accuracy in the forward direction of the linked list, and treat the previous reference as an approximation to an entry somewhere behind the current entry. Previous references can then be corrected - using the correctPrev() helper method described below - to locate the precise entry behind the current entry. By placing greater importance on the forward direction of the list, this allows us to reliably CAS the forward reference even if the previous reference CAS fails. It is hence critical that whenever any references are updated, the next reference is CAS&#8217;d first, and only on this success the previous reference CAS is attempted. The same order applies with marking references. Also, it is important that any process that touches an entry that observes that the next pointer is marked but the previous pointer is not, attempts to mark the previous pointer before attempting any further steps.</p> </div> <div class="paragraph"> <p>The specific functions we need to expose, to support <a href="http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/container/DataContainer.html">DataContainer</a> operations, are:</p> </div> <div class="listingblock"> <div class="content"> <pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> linkAtEnd(LinkedEntry entry);&#x000A;  &#x000A;  <span class="type">void</span> unlink(LinkedEntry entry);&#x000A;  &#x000A;  LinkedEntry correctPrev(LinkedEntry suggestedPrev, LinkedEntry current);&#x000A;  &#x000A;  LinkedEntry getNext(LinkedEntry current);&#x000A;  &#x000A;  LinkedEntry getPrev(LinkedEntry current);</code></pre> </div> </div> <div class="paragraph"> <p>These are exposed as protected final methods, usable by <a href="http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/container/FIFODataContainer.html">FIFODataContainer</a> and its subclasses. The implementations themselves use a combination of CAS&#8217;s on a LinkedEntry&#8217;s next and previous pointers, marking references, and helper correction of previous pointers when using getNext() and getPrevious() to traverse the list. Note that it is important that only the last two methods are used when traversing rather than directly accessing a LinkedEntry&#8217;s references - since markers need to be stepped over and links corrected.</p> </div> <div class="paragraph"> <p>Please refer to <a href="http://www.md.chalmers.se/%7Etsigas/papers/Lock-Free-Deques-Doubly-Lists-JPDC.pdf">Lock-Free Deques and Doubly Linked Lists</a> for details of the algorithm steps.</p> </div> </div> </div> </div> <hr> <div class="pagination-links"><span class="current-page">1</span> </div> </div> <footer class="container"> <hr> <div class="row"> <div class="col-md-2 col-md-offset-1"> <h4>Navigate</h4> <ul> <li> <a href="/about" title="About">About</a> </li> <li> <a href="/documentation" title="Learn">Learn</a> </li> <li> <a href="/community" title="Community">Community</a> </li> <li> <a href="/getinvolved" title="Get Involved">Get Involved</a> </li> <li> <a href="/download" title="Download">Download</a> </li> </ul> </div> <div class="col-md-2"> <h4>Contribute</h4> <ul> <li> <a href="https://issues.jboss.org/browse/ISPN" title="Submit a bug">Submit a bug</a> </li> <li> <a href="https://github.com/infinispan" title="Write code">Write Code</a> </li> </ul> <h4>Follow Us</h4> <ul> <li> <a href="https://blog.infinispan.org" title="Blog">Blog</a> </li> <li> <a href="https://twitter.com/infinispan" title="Twitter">Twitter</a> </li> </ul> </div> <div class="col-md-2"> <h4>Open Source</h4> <p> Infinispan is released under the <b>Apache 2.0 open source license.</b> Learn more about the Apache 2.0 license <a href="https://www.apache.org/licenses/LICENSE-2.0">here.</a> </p> </div> <div class="col-md-2"> <h4>A member of</h4> <a alt="CloudTM" href="http://www.cloudtm.eu/" target="_NEW"> <img src="/images/cloudtm.png"> </a> <a alt="LEADS" href="http://leads-project.eu/" target="_NEW"> <img src="/images/leads.png"> </a> <a alt="CloudButton" href="http://cloudbutton.eu/" target="_NEW"> <img src="/images/cloudbutton.png"> </a> </div> <div class="col-md-2"> <h4>Thanks to</h4> <p>JetBrains Intellij IDEA</p> <a alt="JetBrains Intellij IDEA" href="https://www.jetbrains.com/idea/" target="_NEW"> <img src="/images/icon_IntelliJIDEA.png"> </a> </div> </div> <div class="col-md-10"> <p style="margin-top: 5px; font-size: 80%;"> Â© Copyright 2009-2019 Red Hat, Inc. <br> <i class="icon-fire"></i> Made with <a href="https://github.com/jbossorg/bootstrap-community" style="text-decoration: underline;" target="_NEW">JBoss Community Bootstrap</a> and <a href="http://awestruct.org/" style="text-decoration: underline;" target="_NEW">Awestruct</a> <br> <i class="icon-globe"></i> This website is open source! If you want to improve it, <a href="https://github.com/infinispan/infinispan.github.io" style="text-decoration: underline;" target="_NEW">fork the project,</a> and hack on it, then send a pull request. You can also view the <a href="https://www.seethestats.com/site/infinispan.org" style="text-decoration: underline;" target="_NEW">visitor stats.</a> <br> <i class="icon-share"></i> Website and documentation released under <a href="https://creativecommons.org/licenses/by/3.0/" style="text-decoration: underline;" target="_NEW">CC BY 3.0.</a> </p> </div> </footer> <div class="container" id="companyfooter"> <div class="redhatlogo"> <div id="logospacer"></div> <a href="http://www.redhat.com/"><img src="//static.jboss.org/theme/images/common/redhat_logo.png"></a> </div> </div> <span class="backToTop"> <a href="#top">back to top</a> </span> <script src="//static.jboss.org/theme/js/libs/bootstrap-community/3.2.0.2/bootstrap-community.min.js"></script> <script>
        if (("undefined" !== typeof _satellite) && ("function" === typeof _satellite.pageBottom)) {
          _satellite.pageBottom();
        }
      </script> </div> </body> </html>